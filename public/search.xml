<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux内核编译详解]]></title>
    <url>%2F2017%2F10%2F17%2FLinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[内核主要通过Makefile把整个内核里的文件联系起来进行编译，最后得到内核镜像文件vmlinux。顶层Makefile文件多达1500行，本文仅分析其中比较重要的代码以概括内核编译流程。 123456789include $(srctree)/arch/$(SRCARCH)/Makefile…………init-y := init/drivers-y := drivers/ sound/ firmware/net-y := net/libs-y := lib/core-y := usr/…………core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ 类似init-y形式，是编译过程的核心，告知顶层Makefile哪些目录需要编译。之后进入相应目录进行编译，完成之后，再链接为built-in.o目标文件。例如，init-y编译完成后会在init目录下形成built-in.o文件。 include \$(srctree)/arch/\$(SRCARCH)/Makefile 表明需要把目录 \$(srctree)/arch/\$(SRCARCH)/ 编译进内核。如果在编译前，配置顶层Makefile的ARCH=arm，表明把arch/arm目录纳入内核编译。可根据需要调整编译架构。 一言概之，顶层Makefile指定需要编译的目录。 以x86架构为例，进入arch/x86目录后编译器就要依靠Makefile编译。 123456789101112131415…………head-y := arch/x86/kernel/head_$(BITS).ohead-y += arch/x86/kernel/head$(BITS).ohead-y += arch/x86/kernel/head.ohead-y += arch/x86/kernel/init_task.olibs-y += arch/x86/lib/# See arch/x86/Kbuild for content of core part of the kernelcore-y += arch/x86/# drivers-y are linked after core-ydrivers-$(CONFIG_MATH_EMULATION) += arch/x86/math-emu/drivers-$(CONFIG_PCI) += arch/x86/pci/………… \$(\)形式，根据.config是否有配该选项生效来决定用y或者n或者m代替$(**)。y或n表示是否编译进内核，而m表示以模块形式进行编译。 最后会继续回到根目录进行编译： 123456789101112131415init-y := $(patsubst %/, %/built-in.o, $(init-y))core-y := $(patsubst %/, %/built-in.o, $(core-y))drivers-y := $(patsubst %/, %/built-in.o, $(drivers-y))net-y := $(patsubst %/, %/built-in.o, $(net-y))libs-y1 := $(patsubst %/, %/lib.a, $(libs-y))libs-y2 := $(patsubst %/, %/built-in.o, $(libs-y))libs-y := $(libs-y1) $(libs-y2)…………vmlinux-init := $(head-y) $(init-y)vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)vmlinux-all := $(vmlinux-init) $(vmlinux-main)vmlinux-lds := arch/$(SRCARCH)/kernel/vmlinux.lds…………# vmlinux image - including updated kernel symbolsvmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) vmlinux.o init-y := \$(patsubst %/, %/built-in.o, $(init-y)) 形式是把init-y变为 /init/built-in.o形式。vmlinux-*为vmlinux构成文件，所列出的最后一行会将这些文件链接为vmlinux镜像文件。]]></content>
      <tags>
        <tag>编译</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言关键字]]></title>
    <url>%2F2017%2F10%2F17%2FC%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[ANSI C标准C语言共有32个关键字，9种控制语句，程序书写形式自由，区分大小写。把高级语言的基本结构和语句与低级语言的实用性结合起来。 C 语言可以像汇编语言一样对位、字节和地址进行操作，而这三者是计算机最基本的工作单元。 关键字如下： auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while 1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字： inline、restrict、_Bool、_Complex和_Imaginary。 2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字： _Alignas、_Alignof、_Atomic、_Static_assert、_Noreturn、_Thread_local和_Generic。 根据关键字的作用，可以将关键字分为数据类型关键字和流程控制关键字两大类。 数据类型关键字数据基本类型（5个） void ：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。 定义函数时，以void为形参，表示函数没有参数；为空时，表示函数需要不确定个参数。 对于C语言，C99标准只定义了如下两种可接受的函数原型： int main ( void ) int main ( int argc, char *argv[] ) char ：字符型类型数据，属于整型数据的一种。 int ：整型数据，通常为编译器指定的机器字长。 float ：单精度浮点型数据，属于浮点数据的一种。 double ：双精度浮点型数据，属于浮点数据的一种。 类型修饰关键字（4个） short ：修饰int，短整型数据，可省略被修饰的int。 long ：修饰int，长整形数据，可省略被修饰的int。 signed ：修饰整型数据，有符号数据类型。 unsigned ：修饰整型数据，无符号数据类型。 复杂类型关键字（5个） struct ：结构体声明。 union ：共用体声明。 enum ：枚举声明。 typedef ：声明类型别名。 sizeof ：得到特定类型或特定类型变量的大小。 存储级别关键字（6个） auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配。 static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。 定义全局静态变量。全局静态变量有以下特点： 在全局数据区内分配内存。 如果没有初始化，其默认值为0。 该变量在本文件内从定义开始到文件结束可见。 定义局部静态变量。局部静态变量有以下特点： 该变量在全局数据区分配内存。 如果不显示初始化，那么将被隐式初始化为0。 它始终驻留在全局数据区，直到程序运行结束。 其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 定义静态函数。静态函数有以下特点： 静态函数只能在本源文件中使用。 在文件作用域中声明的inline函数默认为static。 register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数。 extern ：指定对应变量为外部变量，即标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。 const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）。 volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值。 易变性 不可优化性 顺序性 关于volatile可参考C/C++ Volatile关键词深度剖析。 流程控制关键字跳转结构（4个） return ：用在函数体中，返回特定值（或者是void值，即不返回值）。 continue ：结束当前循环，开始下一轮循环。 break ：跳出当前循环或switch结构。 goto ：无条件跳转语句。 分支结构（5个） if ：条件语句，后面不需要放分号。 else ：条件语句否定分支（与if连用）。 switch ：开关语句（多重分支语句）。 case ：开关语句中的分支标记。 default ：开关语句中的“其他”分支，可选。 循环结构（3个） for：一种循环语句。 do ：循环语句的循环体。 while ：循环语句的循环条件。 以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC编译过程详解]]></title>
    <url>%2F2017%2F10%2F16%2FGCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[GCC简介GCC（GNU Compiler Collection，GNU编译器套件），是由 GNU 开发的编程语言编译器。GCC原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，GCC同样适用于微软的Windows。GCC由自由软件基金会以GPL协议发布。 GCC 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。后来又扩展能够支持更多编程语言，如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 编译器的工作是将源代码(通常使用高级语言编写)翻译成目标代码(通常是低级的目标代码或者机器语言)，在现代编译器的实现中，这个工作一般是分为两个阶段来实现： 编译器的前端接受输入的源代码，经过词法、语法和语义分析等等得到源程序的某种中间表示方式。 编译器的后端将前端处理生成的中间表示方式进行一些优化，并最终生成在目标机器上可运行的代码。 GCC 设计中有两个重要的目标： 硬件无关性：在构建支持不同硬件平台的编译器时，它的代码能够最大程度的被复用。 要生成高质量的可执行代码，这就需要对代码进行集中的优化。 为了实现这两个目标，GCC 内部使用了一种硬件平台无关的语言，它能对实际的体系结构做一种抽象，这个中间语言为 RTL(Register Transfer Language)。 GCC的工作流程GCC是一个驱动程序，它接受并解释命令行参数，根据对命令行参数分析的结果决定下一步动作，GCC提供了多种选项以达到控制GCC编译过程的目的，可以在 GCC 手册中查找这些编译选项的详细信息。 GCC的使用是比较简单的，但是要深入到其内部去了解编译流程，情况就比较复杂了。有两个比较好的方法解析GCC： 阅读源码，对感兴趣的函数可以跟踪过去看一看，阅读代码看起来可怕，但其实代码中会有很多注释说明它的功能，使得我们的阅读变得更简单一些，这种方法便于从整体上把握GCC。 调试GCC，就是使用调试器来跟踪 GCC 的编译过程，这样可以看清 GCC 编译的实际流程，也可以追踪我们感兴趣的细节部分。 GCC的基本用法1gcc [options] infile 其中options就是编译器所需要的参数，infile给出相关的文件名称。 下表列出一些常用的参数说明： 参数 说明 -E 预处理后即停止，不进行编译。 -S 编译后即停止，不进行汇编。 -c 编译或汇编源文件，但是不作连接。 -o file 指定输出文件为file，该选项不在乎GCC产生什么输出。 GCC的基本规则gcc所遵循的部分约定规则： .c为后缀的文件，C语言源代码文件； .a为后缀的文件，是由目标文件构成的档案库文件； .C，.cc或.cxx 为后缀的文件，是C++源代码文件且必须要经过预处理； .h为后缀的文件，是程序所包含的头文件； .i 为后缀的文件，是C源代码文件且不应该对其执行预处理； .ii为后缀的文件，是C++源代码文件且不应该对其执行预处理； .m为后缀的文件，是Objective-C源代码文件； .mm为后缀的文件，是Objective-C++源代码文件； .o为后缀的文件，是编译后的目标文件； .s为后缀的文件，是汇编语言源代码文件； .S为后缀的文件，是经过预编译的汇编语言源代码文件。 GCC的编译过程GCC的编译过程可以分为以下四个阶段：预处理、编译、汇编、链接，如下图所示： 以下面代码为例： 1234567#include &lt;stdio.h&gt;int main()&#123; printf("Hello World\n"); return 0;&#125; include两种方式： #include&lt;&gt; 引用的是编译器的类库路径里面的头文件。 #include” “ 引用的是程序目录的相对路径中的头文件。 预处理123# gcc –E test.c –o test.i或者# cpp -o test.i test.c 以下为test.i部分内容： 1234567891011121314151617# 1 "test.c"# 1 "&lt;built-in&gt;"# 1 "&lt;command-line&gt;"# 1 "/usr/include/stdc-predef.h" 1 3 4# 1 "&lt;command-line&gt;" 2# 1 "test.c"# 1 "/usr/include/stdio.h" 1 3 4# 27 "/usr/include/stdio.h" 3 4# 1 "/usr/include/features.h" 1 3 4…………# 2 "test.c" 2int main()&#123; printf("Hello World\n"); return 0;&#125; 预编译过程主要处理那些源代码中以#开始的预编译指令，主要处理规则如下： 将所有的#define删除，并且展开所有的宏定义； 处理所有条件编译指令，如#if，#ifdef等； 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。该过程递归进行，及被包含的文件可能还包含其他文件。 删除所有的注释//和 /**/； 添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息； 保留所有的#pragma编译器指令，因为编译器须要使用它们； 编译编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件。 123# gcc -S test.i -o test.s或者# ccl -o test.s test.i 以下为test.s部分内容： 1234567891011121314151617181920212223242526 .file &quot;test.c&quot; .section .rodata.LC0: .string &quot;Hello World&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $.LC0, %edi call puts movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-16)&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 汇编汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可。 123# gcc -c test.c -o test.o或者# as -o test.o test.s test.o的内容为机器码，不能以文本形式方便的呈现。利用hexdump 查看如下： 123456789101112131415161718192021# hexdump test.o 0000000 457f 464c 0102 0001 0000 0000 0000 00000000010 0001 003e 0001 0000 0000 0000 0000 00000000020 0000 0000 0000 0000 0298 0000 0000 00000000030 0000 0000 0040 0000 0000 0040 000d 000a0000040 4855 e589 00bf 0000 e800 0000 0000 00b80000050 0000 5d00 48c3 6c65 6f6c 5720 726f 646c0000060 0000 4347 3a43 2820 4e47 2955 3420 382e0000070 352e 3220 3130 3035 3236 2033 5228 64650000080 4820 7461 3420 382e 352e 312d 2936 00000000090 0014 0000 0000 0000 7a01 0052 7801 011000000a0 0c1b 0807 0190 0000 001c 0000 001c 000000000b0 0000 0000 0015 0000 4100 100e 0286 0d4300000c0 5006 070c 0008 0000 2e00 7973 746d 626100000d0 2e00 7473 7472 6261 2e00 6873 7473 747200000e0 6261 2e00 6572 616c 742e 7865 0074 642e00000f0 7461 0061 622e 7373 2e00 6f72 6164 61740000100 2e00 6f63 6d6d 6e65 0074 6e2e 746f 2e650000110 4e47 2d55 7473 6361 006b 722e 6c65 2e610000120 6865 665f 6172 656d 0000 0000 0000 00000000130 0000 0000 0000 0000 0000 0000 0000 0000 链接链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。如下形式： 1ld –static crt1.o crti.o crtbeginT.o test.o –start-group –lgcc –lgcc_eh –lc-end-group crtend.o crtn.o (省略了文件的路径名) 123# gcc -o test test.o或者# ld -o test test.o test程序调用了printf 函数，这个函数是标准C库中的一个函数，它保存在一个名为printf.o 的文件中，这个文件必须以某种方式合并到test.o的程序中。 链接器ld负责处理这种合并。结果得到test可执行文件，可以被加载到内存中由系统执行。 小结以上过程可以参考下图： 参考资料GCC编译过程分解 gcc编译过程简述 GCC-百度百科 GCC中文手册]]></content>
      <tags>
        <tag>GCC</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 升级内核]]></title>
    <url>%2F2017%2F10%2F04%2FCentos-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[Linux 只是个内核。在正常操作期间，内核负责执行两个重要任务： 作为硬件和系统上运行的软件之间的接口。 尽可能高效地管理系统资源。 为此，内核通过内置的驱动程序或以后可作为模块安装的驱动程序与硬件通信。 随着新的设备和技术定期出来，如果我们想充分利用它们，保持最新的内核就很重要。此外，更新内核将帮助我们利用新的内核函数，并保护自己免受先前版本中发现的漏洞的攻击。 包管理工具升级检查已安装的内核版本让我们安装了一个发行版，它包含了一个特定版本的内核。为了展示当前系统中已安装的版本，我们可以： 1# uname -sr 12s 打印出内核名；r 打印出内核release版本; Linux官网可看到当前最新的内核版本。如果你当前使用的版本接近它的生命周期结束，那么在该日期后将不会提供更多的 bug 修复。关于更多信息，请参阅内核发布页。 在 CentOS 中升级内核大多数现代发行版提供了一种使用 yum 等包管理系统和官方支持的仓库升级内核的方法。这会使内核升级到仓库中可用的最新版本，而非官网中可用的最新版本。不幸的是，Red Hat 只允许使用前者升级内核。 与 Red Hat 不同，CentOS 允许使用 ELRepo，这是一个第三方仓库，可以将内核升级到最新版本。要在 CentOS 7 上启用 ELRepo 仓库，请运行： 12# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org# rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm 12此方法基于ELRepo项目，因此需要导入此项目的KEY;release-7.0 是指 centos7 或 RH7，具体可参考 http://www.elrepo.org。 仓库启用后，你可以使用下面的命令列出可用的内核相关包： 1# yum --disablerepo="*" --enablerepo="elrepo-kernel" list available 12禁用ELRepo项目中所有存储库，之后使能名为“elrepo-kernel”的存储库。其他存储库有“elrepo-extras”、“elrepo-testing”。 接下来，安装最新的主线稳定内核： 1# yum --enablerepo=elrepo-kernel install kernel-ml 12kernel-ml 指 Linux mainline（主线）分支；kernel-lt 指 Linux longterm（长期维护）分支； 最后，重启机器并选择最新内核，接着运行下面的命令检查最新内核版本： 1# uname -sr 设置 GRUB 默认的内核版本打开并编辑 /etc/default/grub 并设置 GRUB_DEFAULT=0。意思是 GRUB 初始化页面的第一个内核将作为默认内核。 1234567GRUB_TIMEOUT=5GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"GRUB_DEFAULT=0GRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT="console"GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet"GRUB_DISABLE_RECOVERY="true" 接下来运行命令来重新创建内核配置： 1# grub2-mkconfig -o /boot/grub2/grub.cfg 重启并验证最新的内核已作为默认内核。 源码升级检查已安装的内核版本1# uname -sr 下载内核包并解压123# wget -c http://www.kernel.org/pub/linux/kernel/v3.0/linux-3.2.2.tar.bz2# tar jxvf linux-3.2.2.tar.bz2# cd linux-3.2.2 配置内核并安装清除环境变量1# make mrproper 删除所有的编译生成文件， 还有内核配置文件， 再加上各种备份文件。或者仅仅使用 1# make clean 删除大多数的编译生成文件， 但是会保留内核的配置文件.config， 还有足够的编译支持来建立扩展模块。 编译配置表配置时，以下方式选其一即可。 当前系统拷贝选取/boot/config-XXX文件，拷贝到代码目录。 1# cp /boot/config-3.10.0-693.2.2.el7.x86_64 .config defconfig命令1# make defconfig 获取当前系统参数并写入.config文件。之后可使用“make menuconfig”进行定制化。 问答式配置1# make localmodconfig 可一直回车选择默认配置。 命令界面配置1# make oldconfig 自动载入既有的.config配置文件，并且只有在遇到先前没有设定过的选项时，才会要求手动设定。 交互模式1# make menuconfig 找到以下选中选项并选中networking support → networking options → network packet filtering framework(netfilter) Core netfilter configuration 勾中”Netfilter connection tracking support” -m state相关模块是依赖它的，不选则没有。 将netbios name service protocal support(new) 编译成模块,不然后面升级iptables后启动时会出错。 勾中“Netfilter Xtables support (required for ip_tables)” IP: Netfilter Configuration 将 “IPv4 connection tracking support (require for NAT)” 编译成模块。 勾中IP tables support (required for filtering/masq/NAT) 。 将 “Full NAT” 下的 “MASQUERADE target support” 和 “REDIRECT target support” 编译成模块 其它模块可以根据自己的需要进行选择,若不懂可以参考内核配置手册。 编译内核生成内核文件 1# make bzImage 编译模块 1# make modules 或者直接 make 。 make = make bzImage + make modules。 安装模块 1# make modules_install 安装内核 1# make install 此步会： 重新制作内核映像文件，mkinitramfs -o /boot/initrd.img-XXX 更新制作的内核映像文件，update-initramfs -c -k XXX 自动修改系统引导配置，产生或更新boot/grub/grub.cfg启动文件，文件中增加了新内核版本号的启动项，update-grub2 之后重启即可。 重启之后内核未改变，则编辑 /etc/grub.conf 文件，将 default=1 改为 default=0。 内核包(YUM)升级获取源从下面三个地址从获取想要的内核： 官方源 香港源 scientific源，根据需要选择不同的源，例如，http://ftp.scientificlinux.org/linux/scientific/7.0/x86_64/updates/security/。 安装可下载到本地或者直接在线安装： 1# yum install -y http://hkg.mirror.rackspace.com/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-4.5.2-1.el7.elrepo.x86_64.rpm 修改文件升级完内核，自动按最新内核启动，修改/etc/default/grub，GRUB_DEFAULT=0。 重新编译内核启动文件，以后升级完内核也要执行一次。 1# grub2-mkconfig -o /boot/grub2/grub.cfg 删除旧内核 列出当前所用内核 1# uname -sr 列出系统所有内核 1# rpm -qa | grep kernel Debian/ Ubuntu Linux 用户，使用： 1# dpkg --list 'linux-image*' 删除内核 1# rpm -e kernel-XXX 或 1# yum autoremove kernel-XXX Debian/ Ubuntu Linux 用户，使用： 1# apt-get remove kernel-XXX 参考资料Debian、CentOS 升级内核至当前最新稳定版 如何在 CentOS 7 中安装或升级最新的内核 CentOS Linux 升级内核步骤、方法 安全删除linux旧内核的方法]]></content>
      <tags>
        <tag>Centos</tag>
        <tag>内核升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程]]></title>
    <url>%2F2017%2F09%2F20%2FLinux-%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程是任何多道程序设计操作系统中的基本概念。 进程、轻量级进程和线程进程是程序执行的一个实例，是充分描述程序已经执行到何种程度的数据结构的汇集。 从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。 拥有很多相对独立执行流的用户程序共享应用程序的大部分数据结构。一个进程由几个用户线程(或简单地说，线程)组成，每个线程都代表进程的一个执行流。大部分多线程应用程序都是用pthread(POSIX thread)库的标准库函数集编写的。 Linux内核的早期版本没有提供多线程应用的支持。从内核观点看，多线程应用程序仅仅是一个普通进程。多线程应用程序多个执行流的创建、处理、调度整个都是在用户态进行的(通常使用POSIX兼容的pthread库)。 但是，这种多线程应用程序的实现方式不那么令人满意。程序的多个线程，一个线程阻塞时，另外的线程也会阻塞。 Linux使用轻量级进程(lightwetght process)对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。只要其中一个修改共享资源，另一个就立即查看这种修改。当然，当两个线程访问共享资源时就必须同步它们自己。 实现多线程应用程序的一个简单方式就是把轻量级进程与每个线程关联起来。这样，线程之间就可以通过简单地共享同一内存地址空间、同一打开文件集等来访问相同的应用程序数据结构集。同时，每个线程都可以由内核独立调度，以便一个睡眠的同时另一个仍然是可运行的。POSIX兼容的pthread库使用Linux轻量级进程有3个例子，它们是LinuxThreads， Native Posix Thread Library(NPTL)和IBM的下一代Posix线程包NGPT(Next Generation Posix Threading Package)。 POSIX兼容的多线程应用程序由支持“线程组”的内核来处理。在Linux中，一个线程组基本上就是实现了多线程应用的一组轻量级进程，对于像getpid()，kill()，和_exit()这样的一些系统调用，它像一个组织，起整体的作用。 进程描述符为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在CPU上运行还是因某些事件而被阻塞，给它分配了什么样的地址空间，允许它访问哪个文件等等。这正是进程描述符(process descriptor)的作用——进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。它不仅包含了很多进程属性的字段，而且一些字段还包括了指向其他数据结构的指针，依此类推。 进程状态进程描述符中的state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态，且状态是互斥的。 标志 描述 可运行状态(TASK_RUNNING) 进程要么在CPU上执行，要么准备执行。 可中断的等待状态(TASK_INTERRUPTIBLE) 进程被挂起(睡眠)，直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件(把进程的状态放回到TASK_RUNNING。 不可中断的等待状态(TASK_UNINTERRUPTIBLE) 与可中断的等待状态类似，但是，把信号传递到睡眠进程不能改变它的状态。这种状态在一些特定的情况下(进程必须等待，直到一个不能被中断的事件发生)是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。 暂停状态(TASK_STOPPED) 进程的执行被暂停。当进程接收到SIGSTOP， SIGTSTP， SIGTTIN或SIGTTOU信号后，进入暂停状态。 跟踪状态(TASK_TRACED) 进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时(例如 debugger执行ptrace()系统调用监控一个测试程序)，任何信号都可以把这个进程置于TASK_TRACED状态。 僵死状态(EXIT_ZOMBIE) 可存放在exit_state字段中。进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。 僵死撤消状态(EXIT_DEAD) 可存放在exit_state字段中。最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用(这是一种竞争条件)，而把进程的状态由僵死(EXIT_ZOMBIE)状态改为僵死撤消状态 (EXIT_DEAD)。 内核使用set_task_state和set_current_state宏分别设置指定进程的状态和当前执行进程的状态。此外，这些宏确保编译程序或CPU控制单元不把赋值操作与其他指令混合。混合指令的顺序有时会导致灾难性的后果。 标识一个进程能被独立调度的每个执行上下文都必须拥有它自己的进程描述符。因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的task_struct结构。 进程和进程描述符之间有非常严格的一一对应关系，这使得用32位进程描述符地址标识进程成为一种方便的方式。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。 另一方面，类Unix操作系统允许用户使用一个叫做进程标识符process ID(或PID)的数来标识进程，PID存放在进程描述符的pid字段中。PID被顺序编号。不过，PID的值有一个上限，当内核使用的PID达到这个上限值的时候就必须开始循环使用已闲置的小PID号。系统管理员可以通过往/proc/sys/kernel/pid_max这个文件中写入一个值来更改PID的上限值。 由于循环使用PID编号，内核必须通过管理一个pidmap-array位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中pidmap-array位图存放在一个单独的页中。然而，在64位体系结构中，当内核分配了超过当前位图大小的PID号时，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。 Linux把不同的PID与系统中每个进程或轻量级进程相关联(多处理器系统上稍有例外)。这种方式能提供最大的灵活性，因为系统中每个执行上下文都可以被唯一地识别。 另一方面，Unix程序员希望同一组中的线程有共同的PID。例如，把指定PID的信号发送给组中的所有线程。事实上，POSIX 1003.1c标准规定一个多线程应用程序中的所有线程都必须有相同的PID。 遵照这个标准，Linux引入线程组的表示。一个线程组中的所有线程使用和该线程组的领头线程(thread group leader)相同的PID，也就是该组中第一个轻量级进程的PID，它被存入进程描述符的tgid字段中。getpid()系统调用（sys_getpid()）返回当前进程的tgid值而不是pid的值，因此，一个多线程应用的所有线程共享相同的PID。线程组的领头线程其tgid的值与pid的值相同，因而getpid()系统调用对这类进程所起的作用和一般进程是一样的。 从进程的PID中有效地导出它的描述符指针，效率至关重要，因为像kill()这样的很多系统调用使用PID表示所操作的进程。 进程描述符处理进程是动态实体，其生命周期范围从几毫秒到几个月。因此，内核必须能够同时处理很多进程，并把进程描述符存放在动态内存中，而不是放在永久分配给内核的内存区(线性地址在3GB之上)。 对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内：一个是内核态的进程堆栈，另一个是紧挨进程描述符的小数据结构thread_info，叫做线程描述符。这块存储区域的大小通常为8192个字节(两个页框)。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是213的倍数。当几乎没有可用的动态内存空间时，就会很难找到这样的两个连续页框，因为空闲空间可能存在大量碎片。因此，在80x86体系结构中，在编译时可以进行设置，以使内核栈和线程描述符跨越一个单独的页框(4096个字节)。 内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。因为内核控制路径使用很少的栈，因此只需要几千个字节的内核态堆栈。所以，对栈和thread_info结构来说，8KB足够了。不过，当使用一个页框存放内核态堆栈和thread_info结构时，内核要采用一些额外的栈以防止中断和异常的深度嵌弃而引起的溢出。 下图显示了在2页(8KB)内存区中存放两种数据结构的方式。线程描述符驻留于这个内存区的开始，而栈从末端向下增长。该图还显示了分别通过task和thread_info字段使thread_info结构与task_struct结构互相关联。 esp寄存器是CPU栈指针，用来存放栈顶单元的地址。在80x86系统中，栈起始于末端，并朝这个内存区开始的方向增长。从用户态刚切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器指向这个栈的顶端。 一旦数据写入堆栈，esp的值就递减。因为thread_info结构是52个字节长，因此内核栈能扩展到8140个字节。 C语言使用下列的联合结构方便地表示一个进程的线程描述符和内核栈： 1234union thread_union &#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];/*2048 or 1024*/&#125;; 如上图所示，thread_info结构从0x015f 0000地址处开始存放，而栈从0x015f c000地址处开始存放。esp寄存器的值指向地址为0x012f a878的当前栈顶。 内核使用alloc_thread_info和free_thread_info宏分配和释放存储thread_info结构和内核栈的内存区。 标识当前进程从效率的观点来看，threadinfo结构与内核态堆栈之间的紧密结合提供的主要好处是：内核很容易从esp寄存器的值获得当前在CPU上正在运行进程的thread info结构的地址。如果thread_union结构长度是8K(213字节)，则内核屏蔽掉esp的低13位有效位就可以获得thread_info结构的基地址。而如果thread_union结构长度是4K，内核需要屏蔽掉esp的低12位有效位。这项工作由currentthread info()函数来完成，它产生如下一些汇编指令： 123movl $0xffffe000， %ecx /*或者是用于4K堆栈的Oxfffff000*/andl %esp， %ecxmovl %ecx， p 这三条指令执行以后，p就包含在执行指令的CPU上运行的进程的thread_info结构的指针。 进程最常用的是进程描述符的地址而不是thread_info结构的地址。为了获得当前在CPU上运行进程的描述符指针，内核要调用current宏，该宏本质上等价于current_thread_info()-&gt;task，它产生如下汇编语言指令： 123movl $0xffffe000， %ecx /*或者是用于4K堆栈的Oxfffff000*/andl %esp，%ecxmovl (%ecx)，p 因为task字段在thread_info结构中的偏移量为0，所以执行完这三条指令之后，p就包含在CPU上运行进程的描述符指针。 current宏经常作为进程描述符字段的前缀出现在内核代码中，例如，current-&gt;pid返回在CPU上正在执行的进程的PID。 用栈存放进程描述符的另一个优点体现在多处理器系统上：如前所述，对于每个硬件处理器，仅通过检查栈就可以获得当前正确的进程。早先的Linux版本没有把内核栈与进程描述符存放在一起，而是强制引入全局静态变量current来标识正在运行进程的描述符。在多处理器系统上，有必要把current定义为一个数组，每一个元素对应一个可用CPU。 进程链表每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。 进程链表的头是init_task描述符，它是所谓的0进程(process 0)或swapper进程的进程描述符。init_task的tasks.prev字段指向链表中最后插入的进程描述符的tasks字段。 SET_LINKS和REMOVE_LINKS宏分别用于从进程链表中插入和删除一个进程描述符。这些宏考虑了进程间的父子关系。 还有一个很有用的宏就是for_each_process，它的功能是扫描整个进程链表，其定义如下： 1234define next_task(p) list_entry((p)-&gt;tasks.next， struct task_struct， tasks)define prev_task(p) list_entry((p)-&gt;tasks.prev， struct task_struct， tasks)define for_each_process(p) \ for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; ) 这个宏是循环控制语句，内核开发者利用它提供循环。注意init_task进程描述符是如何起到链表头作用的。这个宏从指向init_task的指针开始，把指针移到下一个任务，然后继续，直到又到init_task为止。在每一次循环时，传递给这个宏的参变量中存放的是当前被扫描进程描述符的地址，这与list_entry宏的返回值一样。 TASK_RUNNING状态的进程链表当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程(即处在TASK_RUNNING状态的进程)。 早先的Linux版本把所有的可运行进程都放在同一个叫做运行队列(runqueue)的链表中，由于维持链表中的进程按优先级排序开销过大，因此，早期的调度程序不得不为选择“最佳”可运行进程而扫描整个队列。 Linux2.6实现的运行队列有所不同。其目的是让调度程序能在固定的时间内选出“最佳”可运行进程，与队列中可运行的进程数无关。 提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个task_struct描述符包含一个list_head类型的字段run_list。如果进程的优先权等于k(其取值范围是0到139)，run_list字段把该进程链人优先权为k的可运行进程的链表中。此外，在多处理器系统中，每个CPU都有它自己的运行队列，即它自己的进程链表集。这是一个通过使数据结构更复杂来改善性能的典型例子：调度程序的操作效率的确更高了，但运行队列的链表却为此而被拆分成140个不同的队列！ 内核必须为系统中每个运行队列保存大量的数据，不过运行队列的主要数据结构还是组成运行队列的进程描述符链表，所有这些链表都由一个单独的prio_array_t数据结构来实现，其字段说明如下表所示： 类型 字段 描述 int nr_active 链表中进程描述符的数量 unsigned long [5] bitmap 优先权位图：当且仅当某个优先权的进程链表不为空时设置相应的位标志 struct list_head [140] queue 140个优先权队列的头结点 enqueue_task(p,array)函数把进程描述符插入某个运行队列的链表，其代码本质上等同于： 12345678static void enqueue_task(struct task_struct *p, prio_array_t *array)&#123; sched_info_queued(p); list_add_tail(&amp;p-&gt;run_list, array-&gt;queue + p-&gt;prio); __set_bit(p-&gt;prio, array-&gt;bitmap); array-&gt;nr_active++; p-&gt;array = array;&#125; 进程描述符的prio字段存放进程的动态优先权，而array字段是一个指针，指向当前运行队列的prio_array_t数据结构。类似地，dequeue_task(p,array)函数从运行队列的链表中删除一个进程的描述符。 进程间的关系程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。在进程描述符中引入几个字段来表示这些关系，表示给定进程P的这些字段列在下表中。进程0和进程1是由内核创建的。稍后我们将看到，进程1 (init)是所有进程的祖先。 字段名 说明 real_parent 指向创建了P的进程的描述符，如果P的父进程不再存在，就指向进程1 (init)的描述符(因此，如果用户运行一个后台进程而且退出了shell，后台进程就会成为init的子进程) parent 指向P的当前父进程(这种进程的子进程终止时，必须向父进程发信号)。它的值通常与real_parent一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时 children 链表的头部，链表中的所有元素都是P创建的子进程 sibling 指向兄弟进程链表中的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P 上图显示了一组进程间的亲属关系。进程P0接连创建了P1,P2和P3。进程P3又创建了P4。 特别要说明的是，进程之间还存在其他关系：一个进程可能是一个进程组或登录会话的领头进程，也可能是一个线程组的领头进程，它还可能跟踪其他进程的执行。下表列出了进程描述符中的一些字段，这些字段建立起了进程P和其他进程之间的关系。 字段名 说明 group_leader P所在进程组的领头进程的描述符指针 signal-&gt;pgrp P所在进程组的领头进程的PID tgid P所在线程组的领头进程的PID signal-&gt;session P的登录会话领头进程的PID ptrace_children 链表的头，该链表包含所有被debugge程序跟踪的P的子进程 ptrace_list 指向所跟踪进程其实际父进程链表的前一个和下一个元素(用于P被跟踪的时候) pidhash表及链表在几种情况下，内核必须能从进程的PID导出对应的进程描述符指针。例如，为kill()系统调用提供服务时就会发生这种情况：当进程P1希望向另一个进程P2发送一个信号时，P1调用kill()系统调用，其参数为P2的PID，内核从这个PID导出其对应的进程描述符，然后从P2的进程描述符中取出记录挂起信号的数据结构指针。 顺序扫描进程链表并检查进程描述符的pid字段是可行但相当低效的。为了加速查找，引入了4个散列表。需要4个散列表是因为进程描述符包含了表示不同类型PID的字段(见下表)，而且每种类型的PID需要它自己的散列表。 Hash表的类型 字段名 说明 PIDTYPE_PID pid 进程的PID PIDTYPE_TGID tgid 线程组领头进程的PID PIDTYPE_PGID pgrp 进程组领头进程的PID PIDTYPE_SID session 会话领头进程的PID 内核初始化期间动态地为4个散列表分配空间，并把它们的地址存入pid_hash数组。一个散列表的长度依赖于可用RAM的容量，例如：一个系统拥有512MB的RAM，那么每个散列表就被存在4个页框中，可以拥有2048个表项。 用pid_hashfn宏把PID转化为表索引，pid_hashfn宏展开为： 1#define pid_hashfn(nr) hash_long((unsigned long)nr, pidhash_shift) 变量pidhash_shift用来存放表索引的长度(以位为单位的长度，在我们的例子里是11位)。很多散列函数都使用hash_long()，在32位体系结构中它基本等价于： 12345678910#define GOLDEN_RATIO_PRIME 0x9e370001UL#define BITS_PER_LONG 32static inline unsigned long hash_long(unsigned long val, unsigned int bits)&#123; unsigned long hash = val; /* On some cpus multiply is faster, on others gcc will do shifts */ hash *= GOLDEN_RATIO_PRIME; /* High bits are more random, so use them. */ return hash &gt;&gt; (BITS_PER_LONG - bits);&#125; 因为在我们的例子中pidhash_shift等于11，所以pid_hashfn的取值范围是0到211-1=2047。 散列(hash)函数并不总能确保PID与表的索引一一对应。两个不同的PID散列(hash)到相同的表索引称为冲突(colliding)。 1魔数常量：常量0x9e370001究竟是怎么得出的？这种散列函数是基于表索引乘以一个适当的大数，于是结果溢出，就把留在32位变量中的值作为模数操作的结果。Knuth建议，要得到满意的结果，这个大乘数就应当是接近黄金比例的2^32的一个素数(32位是80x86寄存器的大小)。这里，0x9e370001就是接近2^32的一个素数。 Linux利用链表来处理冲突的PID：每一个表项是由冲突的进程描述符组成的双向链表。 具有链表的散列法比从PID到表索引的线性转换更优越，这是因为在任何给定的实例中，系统中的进程数总是远远小于32768(所允许的进程PID的最大数)。如果在任何给定的实例中大部分表项都不使用的话，那么把表定义为32768项会是一种存储浪费。 由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。看一个例子：假设内核必须回收一个指定线程组中的所有进程，这意味着这些进程的tgid的值是相同的，都等于一个给定值。如果根据线程组号查找散列表，只能返回一个进程描述符，就是线程组领头进程的描述符。为了能快速返回组中其他所有进程，内核就必须为每个线程组保留一个进程链表。在查找给定登录会话或进程组的进程时也会有同样的情形。 PID散列表的数据结构解决了所有这些难题，因为它们可以为包含在一个散列表中的任何PID号定义进程链表。最主要的数据结构是四个pid结构的数组，它在进程描述符的pids字段中，下表显示pid结构的字段。 类型 名称 描述 int nr pid的数值 struct hlist_node pid_chain 链接散列表的下一个和前一个元素 struct list_head pid_list 每个pid的进程链表头 上图给出了PIDTYPE_TGID类型散列表的例子。pid_hash数组的第二个元素存放散列表的地址，也就是用hlist_head结构的数组表示链表的头。在散列表第71项为起点形成的链表中，有两个PID号为246和4351的进程描述符(双箭头线表示一对向前和向后的指针)。PID的值存放在pid结构的nr字段中，而pid结构在进程描述符中。(顺便提一下，由于线程组的号和它的首创者的PID相同，因此这些PID值也存在进程描述符的pid字段中。)我们考虑线程组4351的PID链表:散列表中的进程描述符的pid_list字段中存放链表的头，同时每个PID链表中指向前一个元素和后一个元素的指针也存放在每个链表元素的pid_list字段中。 下面是处理PID散列表的函数和宏： 名称 描述 #define do_each_task_pid(who, type, task) #define while_each_task_pid(who, type, task) 标记do-while循环的开始和结束，循环作用在PID值等于nr的PID链表上，链表的类型由参数type给出，task参数指向当前被扫描的元素的进程描述符。 find_task_by_pid_type(int type, int nr) 在type类型的散列表中查找PID等于nr的进程。该函数返回所匹配的进程描述符指针，若没有匹配的进程，函数返回NULL。 #define find_task_by_pid(nr) 与find_task_by_pid_type(int type, int nr)相同。 attach_pid(task_t *task, enum pid_type type, int nr) 把task指向的PID等于nr的进程描述符插人type类型的散列表中。如果一个PID等于nr的进程描述符已经在散列表中，这个函数就只把task插入已有的PID进程链表中。 detach_pid(task_t *task, enum pid_type type) 从type类型的PID进程链表中删除task所指向的进程描述符。如果删除后PID进程链表没有变为空，则函数终止，否则，该函数还要从type类型的散列表中删除进程描述符。最后，如果PID的值没有出现在任何其他的散列表中，为了这个值能够被反复使用，该函数还必须清除PID位图中的相应位。 next_thread(const task_t *p) 返回PIDTYPE_TGID类型的散列表链表中task指示的下一个轻量级进程的进程描述符。由于散列链表是循环的，若应用于传统的进程，那么该宏返回进程本身的描述符地址。 如何组织进程运行队列链表把处于TASK_RUNNING状态的所有进程组织在一起。没有为处于TASK_STOPPED, EXIT_ZOMBIE或EXIT_DEAD状态的进程建立专门的链表。由于对处于暂停、僵死、死亡状态进程的访问比较简单，或者通过PID,或者通过特定父进程的子进程链表，所以不必对这三种状态进程分组。 等待队列等待队列在内核中有很多用途，尤其用在中断处理、进程同步及定时。进程必须经常等待某些事件的发生，例如，等待一个磁盘操作的终止，等待释放系统资源，或等待时间经过固定的间隔。等待队列实现了在事件上的条件等待:希望等待特定事件的进程把自己放进合适的等待队列，并放弃控制权。因此，等待队列表示一组睡眠的进程，当某一条件变为真时，由内核唤醒它们。 等待队列由双向链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头(wait queue head)，等待队列头是一个类型为wait_queue_head_t的数据结构： 12345struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t; 因为等待队列是由中断处理程序和主要内核函数修改的，因此必须对其双向链表进行保护以免对其进行同时访问而导致不可预测的后果。同步是通过等待队列头中的lock自旋锁达到的。task_list字段是等待进程链表的头。 等待队列链表中的元素类型为wait_queue_t： 12345678struct __wait_queue &#123; unsigned int flags;#define WQ_FLAG_EXCLUSIVE 0x01 struct task_struct * task; wait_queue_func_t func; struct list_head task_list;&#125;;typedef struct __wait_queue wait_queue_t; 等待队列链表中的每个元素代表一个睡眠进程，该进程等待某一事件的发生;它的描述符地址存放在task字段中。task_list字段中包含的是指针，由这个指针把一个元素链接到等待相同事件的进程链表中。 然而，要唤醒等待队列中所有睡眠的进程有时并不方便。例如，如果两个或多个进程正在等待互斥访问某一要释放的资源，仅唤醒等待队列中的一个进程才有意义。这个进程占有资源，而其他进程继续睡眠。(这就避免了所谓“雷鸣般兽群”问题，即唤醒多个进程只为了竟争一个资源，而这个资源只能有一个进程访问，结果是其他进程必须再次回去睡眠。) 因此，有两种睡眠进程:互斥进程(等待队列元素的flags字段为1)由内核有选择地唤醒，而非互斥进程(falgs值为0)总是由内核在事件发生时唤醒。等待访问临界资源的进程就是互斥进程的典型例子。等待相关事件的进程是非互斥的。例如，我们考虑等待磁盘传输结束的一组进程:一但磁盘传输完成，所有等待的进程都会被唤醒。正如我们将在下面所看到的那样，等待队列元素的fun。字段用来表示等待队列中睡眠进程应该用什么方式唤醒。 等待队列操作DECLARE_WAIT_QUEUE_HEAD(name)宏静态地声明一个叫name的等待队列的头变量并对该变量的lock和task_list字段进行初始化。函数init_waitqueue_head()可以初始化动态分配的等待队列的头变量。 函数init_waitqueue_entry(wait_queue_t q, struct task_struct p)初始化wait_queue_t结构的变量q： 123q-&gt;flags = 0;q-&gt;task = p;q-&gt;func = default_wake_function; 非互斥进程p将由default_wake_function()唤醒： 12345int default_wake_function(wait_queue_t *curr, unsigned mode, int sync, void *key)&#123; task_t *p = curr-&gt;task; return try_to_wake_up(p, mode, sync);&#125; 也可以选择DEFINE_WAIT宏声明一个wait_queue_t类型的新变量，并用CPU上运行的当前进程的描述符和唤醒函数autoremove_wake_function()的地址初始化这个新变量。这个函数调用default_wake_function()来唤醒睡眠进程，然后从等待队列的链表中删除对应的元素(每个等待队列链表中的一个元素其实就是指向睡眠进程描述符的指针)。最后，内核开发者可以通过init_waitqueue_func_entry()函数来自定义唤醒函数，该函数负责初始化等待队列的元素。 一旦定义了一个元素，必须把它插人等待队列。add_wait_queue()函数把一个非互斥进程插入等待队列链表的第一个位置。add_wait_queue_exclusive()函数把一个互斥进程插入等待队列链表的最后一个位置。remove_wait_queue()函数从等待队列链表中删除一个进程。waitqueue_active()函数检查一个给定的等待队列是否为空。 要等待特定条件的进程可以调用如下列表中的任何一个函数： sleep_on()对当前进程进行操作： 12345678910111213141516171819202122232425#define SLEEP_ON_VAR \ unsigned long flags; \ wait_queue_t wait; \ init_waitqueue_entry(&amp;wait, current);#define SLEEP_ON_HEAD \ spin_lock_irqsave(&amp;q-&gt;lock,flags); \ __add_wait_queue(q, &amp;wait); \ spin_unlock(&amp;q-&gt;lock);#define SLEEP_ON_TAIL \ spin_lock_irq(&amp;q-&gt;lock); \ __remove_wait_queue(q, &amp;wait); \ spin_unlock_irqrestore(&amp;q-&gt;lock, flags);void fastcall __sched sleep_on(wait_queue_head_t *q)&#123; SLEEP_ON_VAR current-&gt;state = TASK_UNINTERRUPTIBLE; SLEEP_ON_HEAD schedule(); SLEEP_ON_TAIL&#125; 该函数把当前进程的状态设置为TASK_UNINTERRUPTIBLE，并把它插入到特定的等待队列。然后，它调用调度程序，而调度程序重新开始另一个程序的执行。当睡眠进程被唤醒时，调度程序重新开始执行sleep_on()函数，把该进程从等待队列中删除。 interruptible_sleep_on()函数sleep_on()函数是一样的，但此函数把当前进程状态设置为TASK_INTERRUPTIBLE，因此，接受一个信号就可以唤醒当前进程。 12345678910void fastcall __sched interruptible_sleep_on(wait_queue_head_t *q)&#123; SLEEP_ON_VAR current-&gt;state = TASK_INTERRUPTIBLE; SLEEP_ON_HEAD schedule(); SLEEP_ON_TAIL&#125; sleep_on_timeout()和interruptible_sleep_on timeout()与前面函数类似，但它们允许调用者定义一个时间间隔，过了这个间隔以后，进程将由内核唤醒。为了做到这点，它们调用schedule_timeout()函数而不是schedule()函数。 在Linux 2.6中引入的prepare_to_wait(), prepare_to_wait_exclusive()和finish_wait()函数提供了另外一种途径来使当前进程在一个等待队列中睡眠。它们的典型应用如下： 1234567DEFINE_WAIT(wait);prepare_to_wait exclusive(&amp;wq, &amp;wait，TASK_INTERRUPTIBLE); /*wq是等待队列的头*/...if(!condition) schedule();finish_wait(&amp;wq,&amp;wait) 函数prepare_to_wait()和prepare_towait exclusive()用传递的第三个参数设置进程的状态，然后把等待队列元素的互斥标志flag分别设置为0(非互斥)或1(互斥)，最后，把等待元素wait插人到以wq为头的等待队列的链表中。 进程一但被唤醒就执行finish_wait()函数，它把进程的状态再次设置为TASK RUNNING(仅发生在调用schedule()之前，唤醒条件变为真的情况下)，并从等待队列中删除等待元素(除非这个工作已经由唤醒函数完成)。 wait_event和wait_event_interruptible宏使它们的调用进程在等待队列上睡眠，一直到修改了给定条件为止。例如，宏wait_event(wq,condition)本质上实现下面的功能： 12345678910111213141516171819#define __wait_event(wq, condition) \do &#123; \ DEFINE_WAIT(__wait); \ \ for (;;) &#123; \ prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE); \ if (condition) \ break; \ schedule(); \ &#125; \ finish_wait(&amp;wq, &amp;__wait); \&#125; while (0)#define wait_event(wq, condition) \do &#123; \ if (condition) \ break; \ __wait_event(wq, condition); \&#125; while (0) sleep_on()类函数在以下条件下不能使用，那就是必须测试条件并且当条件还没有得到验证时又紧接着让进程去睡眠;由于那些条件是众所周知的竞争条件产生的根源，所以不鼓励这样使用。此外，为了把一个互斥进程插人等待队列，内核必须使用prepare_to_wait_exclusive()函数[或者只是直接调用add_wait_queue_exclusive()]。所有其他的相关函数把进程当作非互斥进程来插人。最后，除非使用DEFINE_WAIT或finish_wait()，否则内核必须在唤醒等待进程后从等待队列中删除对应的等待队列元素。 内核通过下面的任何一个宏唤醒等待队列中的进程并把它们的状态置为TASK_RUNNING：wake_up、wake_up_nr、wake_up_all、wake_up_interruptible、wake_up_interruptible_nr、wake_up_interruptible_all、wake_up_interruptible_sync和wake_up_locked。从每个宏的名字我们可以明白其功能： 所有宏都考虑到处于TASK_INTERRUPTIBLE状态的睡眠进程；如果宏的名字中不含字符串”interruptible”，那么处于TASK_UNINTERRUPTIBLE状态的睡眠进程也被考虑到。 所有宏都唤醒具有请求状态的所有非互斥进程(参见上一项)。 名字中含有“nr”字符串的宏唤醒给定数的具有请求状态的互斥进程；这个数字是宏的一个参数。名字中含有“all”字符串的宏唤醒具有请求状态的所有互斥进程。最后，名字中不含“nr”或“all”字符串的宏只唤醒具有请求状态的一个互斥进程。 名字中不含有“sync”字符串的宏检查被唤醒进程的优先级是否高于系统中正在运行进程的优先级，并在必要时调用schedule()。这些检查并不是由名字中含有“sync”字符串的宏进行的，造成的结果是高优先级进程的执行稍有延迟。 wake_up_locked宏和wake_up宏相类似，仅有的不同是当wait_queue_head_t中的自旋锁已经被持有时要调用wake_up_locked。 例如，wake_up宏等价于下列代码片段： 12345678910void wake_up(wait_queue_head_t *q)&#123; struct list_head *tmp; wait_queue_t *curr; list_for_each(tmp, &amp;q-&gt;task_list)&#123; curr=list_entry(tmp, wait_queue_t，task_list) if (curr-&gt;func(curr, TASK_INTERRUPTIBLE|TASK_UNINTERRUPTIBLE, 0, NULL) &amp;&amp; curr-&gt;flags) break; &#125;&#125; list_for_each宏扫描双向链表q-&gt;task_list中的所有项，即等待队列中的所有进程。对每一项，list_entry宏都计算wait_queue_t变量对应的地址。这个变量的func字段存放唤醒函数的地址，它试图唤醒由等待队列元素的task字段标识的进程。如果一个进程已经被有效地唤醒(函数返回1)并且进程是互斥的(curr-&gt;flags等于1)，循环结束。因为所有的非互斥进程总是在双向链表的开始位置，而所有的互斥进程在双向链表的尾部，所以函数总是先唤醒非互斥进程然后再唤醒互斥进程，如果有进程存在的话(一个队列同时包含互斥和非互斥进程的情况是非常罕见的)。 进程资源限制每个进程都有一组相关的资源限制(resource limit)，限制指定了进程能使用的系统资源数量。这些限制避免用户过分使用系统资源(CPU、磁盘空间等)。 对当前进程的资源限制存放在current-&gt;signal-&gt;rlim字段，即进程的信号描述符的一个字段。该字段是类型为rlimit结构的数组，每个资源限制对应一个元素： 1234struct rlimit &#123; unsigned long rlim_cur; unsigned long rlim_max;&#125;; 字段名 说明 RLIMIT_CPU (0) 进程使用CPU的最长时间(以秒为单位)。如果进程超过了这个限制，内核就向它发一个SIGXCPU信号，然后如果进程还不终止，再发一个SIGKILL信号 RLIMIT_FSIZE 文件大小的最大值(以字节为单位)。如果进程试图把一个文件的大小扩充到大于这个值，内核就给这个进程发SIGXFSZ信号 RLIMIT_DATA 堆大小的最大值(以字节为单位)。在扩充进程的堆之前，内核检查这个值 RLIMIT_STACK 栈大小的最大值(以字节为单位)。内核在扩充进程的用户态堆栈之前检查这个值 RLIMIT_CORE 内存信息转储文件的大小(以字节为单位)。当一个进程异常终止时，内核在进程的当前目录下创建内存信息转储文件之前检查这个值。如果这个限制为0，那么，内核就不创建这个文件 RLIMIT_RSS (5) 进程所拥有的页框最大数(目前是非强制的) RLIMIT_NPROC 用户能拥有的进程最大数(参见本章“clone(), fork()及vfork()系统调用”一节) RLIMIT_NOFILE 打开文件描述符的最大数。当打开一个新文件或复制一个文件描述符时，内核检查这个值 RLIMIT_MEMLOCK 非交换内存的最大值(以字节为单位)。当进程试图通过mlock()或mlockall()系统调用锁住一个页框时，内核检查这个值 RLIMIT_AS 进程地址空间的最大数(以字节为单位)。当进程使用malloc()或相关函数扩大它的地址空间时，内核检查这个值 RLIMIT_LOCKS (10) 文件锁的最大值(目前是非强制的) RLIMIT_SIGPENDING 进程挂起信号的最大数 RLIMIT_MSGQUEUE POSIX消息队列中的最大字节数 RLIMIT_NICE RLIMIT_RTPRIO 最大实时优先级 rlim_cur 表示资源的当前限制，例如 current-&gt;signal-&gt;rlim[RLIMIT_CPU]，rlim_cur表示正运行进程所占用CPU时间的当前限制。 rlim_max字段是资源限制所允许的最大值。利用getrlimit()和setrlimit()系统调用，用户总能把一些资源的rlim_cur限制增加到rlim_max。然而，只有超级用户(或更确切地说，具有CAP_SYS_RESOURCE权能的用户)才能改变rlim_max字段，或把rlim_cur字段设置成大于相应rlim_max字段的一个值。 大多数资源限制包含值RLIMIT_INFINITY(0xffffffff)，它意味着没有对相应的资源施加用户限制(当然，由于内核设计上的限制，可用RAM、可用磁盘空间等，实际的限制还是存在的)。然而，系统管理员可以给一些资源选择施加更强的限制。只要用户注册进系统，内核就创建一个由超级用户拥有的进程，超级用户能调用setrlimit()以减少一个资源rlim_max和rlim_cur字段的值。随后，同一进程执行一个login shell, 该进程就变为由用户拥有。由用户创建的每个新进程都继承其父进程rlim数组的内容，因此，用户不能忽略系统强加的限制。 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换(process switch)、任务切换(task switch)或上下文切换(context switch)。 硬件上下文每个进程有属于自己的地址空间，但共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程时的值。 进程恢复执行前必须装入寄存器的一组数据称为硬件上下文(hardware context)。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核态堆栈中。 在下面的描述中，我们假定用prev局部变量表示切换出的进程的描述符，next表示切换进的进程的描述符。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。 早期的Linux版本利用80x86体系结构所提供的硬件支持，并通过far jmp指令(far jmp 指令既修改cs寄存器，也修改eip寄存器，而简单的jmp指令只修改eip寄存器)跳到next进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装人新的硬件上下文来执行硬件上下文切换。但基于以下原因，Linux 2.6使用软件执行进程切换： 通过一组mov指令逐步执行切换，这样能较好地控制所装入数据的合法性。尤其是，这使检查ds和es段寄存器的值成为可能，这些值有可能被恶意伪造。当用单独的far jmp指令时，不可能进行这类检查。 旧方法和新方法所需时间大致相同。然而，尽管当前的切换代码还有改进的余地，却不能对硬件上下文切换进行优化。 进程切换只发生在内核态。在执行进程切换之前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上，这也包括ss和esp这对寄存器的内容(存储用户态堆栈指针的地址)。 任务状态段80x86体系结构包括了一个特殊的段类型，叫任务状态段(Task State Segment ,TSS)来存放硬件上下文。尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS。这样做的两个主要理由为： 当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。 当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可权位图(Permission Bitmap)以检查该进程是否有访问端口的权力。 tss_struct结构描述TSS的格式。init_tss数组为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，TSS反映了CPU上的当前进程的特权级，但不必为没有在运行的进程保留TSS。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Processor.h (include\asm-i386)struct tss_struct &#123; unsigned short back_link,__blh; unsigned long esp0; unsigned short ss0,__ss0h; unsigned long esp1; unsigned short ss1,__ss1h; /* ss1 is used to cache MSR_IA32_SYSENTER_CS */ unsigned long esp2; unsigned short ss2,__ss2h; unsigned long __cr3; unsigned long eip; unsigned long eflags; unsigned long eax,ecx,edx,ebx; unsigned long esp; unsigned long ebp; unsigned long esi; unsigned long edi; unsigned short es, __esh; unsigned short cs, __csh; unsigned short ss, __ssh; unsigned short ds, __dsh; unsigned short fs, __fsh; unsigned short gs, __gsh; unsigned short ldt, __ldth; unsigned short trace, io_bitmap_base; /* * The extra 1 is there because the CPU will access an * additional byte beyond the end of the IO permission * bitmap. The extra byte must be all 1 bits, and must * be within the limit. */ unsigned long io_bitmap[IO_BITMAP_LONGS + 1]; /* * Cache the current maximum and the last task that used the bitmap: */ unsigned long io_bitmap_max; struct thread_struct *io_bitmap_owner; /* * pads the TSS to be cacheline-aligned (size is 0x100) */ unsigned long __cacheline_filler[35]; /* * .. and then another 0x100 bytes for emergency kernel stack */ unsigned long stack[64];&#125; __attribute__((packed)); 每个TSS有它自己8字节的任务状态段描述符(Task State Segment Descriptor, TSSD )。这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志位被清0，以表示相应的TSS是系统段。 Type字段置为11或9以表示这个段实际上是一个TSS。在Intel的原始设计中，系统中的每个进程都应当指向自己的TSS；Type字段的第二个有效位叫做Busy位，如果进程正由CPU执行，则该位置1，否则置0。在Linux的设计中，每个CPU只有一个TSS,因此，Busy位总置为1。 由Linux创建的TSSD存放在全局描述符表(GDT)中，GDT的基地址存放在每个CPU的gdtr寄存器中。每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包含了两个隐藏的非编程字段：TSSD的Base字段和Limit字段。这样，处理器就能直接对TSS寻址而不用从GDT中检索TSS的地址。 thread字段在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像Intel原始设计那样把它保存在TSS中，因为Linux为每个处理器而不是为每个进程使用TSS。 因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后我们会看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括诸如eax,ebx等这些通用寄存器，它们的值保留在内核堆栈中。 执行进程切换进程切换可能只发生在精心定义的点：schedule()函数。从本质上说，每个进程切换由两步组成： 切换页全局目录以安装一个新的地址空间。 切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。 switch_to宏schedule() -&gt; context_switch() -&gt; switch_to() 进程切换的第二步由switch_to宏执行。它是内核中与硬件关系最密切的例程之一，首先，该宏有三个参数，它们是prev，next和last。prev和next是局部变量prev和next的占位符，分别表示被替换进程和新进程描述符的地址在内存中的位置。 在任何进程切换中，涉及到三个进程而不是两个。假设内核决定暂停进程A而激活进程B。在schedule()函数中，prev指向A的描述符而next指向B的描述符。switch_to宏一但使A暂停，A的执行流就冻结。 随后，当内核想再次此激活A，就必须暂停另一个进程C(这通常不同于B)，于是就要用prev指向C而next指向A来执行另一个switch_to宏。当A恢复它的执行流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。此时，代表进程A执行的内核就失去了对C的任何引用。但是，事实表明这个引用对于完成进程切换是很有用的。 switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了(这是在A恢复执行之后完成的)。在进程切换之前，宏把第一个输入参数prev(即在A的内核堆栈中分配的prev局部变量)表示的变量的内容存人CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个输出参数——last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，参数last指向A的局部变量prev，所以prev被C的地址覆盖。 下图显示了进程A，B，C内核堆栈的内容以及eax寄存器的内容。必须注意的是：图中显示的是在被eax寄存器的内容覆盖以前的prev局部变量的值。 由于switch_to宏采用扩展的内联汇编语言编码，所以可读性比较差。实际上这段代码通过特殊位置记数法使用寄存器，而实际使用的通用寄存器由编译器自由选择。我们将采用标准汇编语言而不是麻烦的内联汇编语言来描述switch_to宏在80x86微处理器上所完成的典型工作。 在eax和edx寄存器中分别保存prev和next的值： 12movl prev, %eaxmovl next, %edx 把eflags和ebp寄存器的内容保存在prev内核栈中。必须保存它们的原因是编译器认为在switch_to结束之前它们的值应当保持不变。 12pushflpushl %ebp 把esp的内容保存到prev-&gt;thread.esp中以使该字段指向prev内核栈的栈顶： 1movl %esp, 484(%eax) 484(%eax)操作数表示内存单元的地址为eax内容加上484。 把next-&gt;thread.esp装人esp。此时，内核开始在next的内核栈上操作，因此这条指令实际上完成了从prev到next的切换。由于进程描述符的地址和内核栈的地址紧挨着，所以改变内核栈意味着改变当前进程。 1movl 484(%edx)，%esp 把标记为1的地址(本节后面所示)存入prev-&gt;thread.eip。当被替换的进程重新恢复执行时，进程执行被标记为1的那条指令： 1movl $lf, 480(%eax) 宏把next-&gt;thread.eip的值(绝大多数情况下是一个被标记为1的地址)压入next的内核栈： 1pushl 480(%edx) 跳到__switch_to() C函数： 1jmp __switch_to 这里被进程B替换的进程A再次获得CPU:它执行一些保存eflags和ebp寄存器内容的指令，这两条指令的第一条指令被标记为1。 1231: popl %%ebp popfl 注意这些pop指令是怎样引用prev进程的内核栈的。当进程调度程序选择了prev作为新进程在CPU上运行时，将执行这些指令。于是，以prev作为第二个参数调用switch_to。因此，esp寄存器指向prev的内核栈。 拷贝eax寄存器(上面步骤1中被装载)的内容到switch_to宏的第三个参数last标识的内存区域中 1movl %eax, last 正如先前讨论的，eax寄存器指向刚被替换的进程的描述符(当前执行的schedule()函数重新使用了prev局部变量，于是汇编语言指令就是：movl %eax, prev)。 __switch_to()函数__switch_to()函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和nextp参数，分别表示前一个进程和新进程。这个函数的调用不同于一般函数的调用，因为\_switch_to()从eax和edx取参数prev_p和nextp(fastcall，ecx、edx，我们在前面已看到这些参数就是保存在那里)，而不像大多数函数一样从栈中取参数。为了强迫函数从寄存器取它的参数，内核利用\_attribute__和regparm关键字，这两个关键字是C语言非标准的扩展名，由gcc编译程序实现。在include/asm-1386/system.h头文件中，__switch_to()函数的声明如下： 12__switch_to(struct task_struct *prev, struct task_struct *next&#125;__attribute__(regparm(3)); 函数执行的步骤如下： 执行由__unlazy_fpu()宏产生的代码，以有选择地保存prev_p进程的FPU, MMX及XMM寄存器的内容。 1__unlazy_fpu(prev_p); 执行smp_processor_id()宏获得本地(local)CPU的下标，即执行代码的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标并将它保存到cpu局部变量。 把next-&gt;thread.esp0装入对应于本地CPU的TSS的esp0字段；任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中： 1init_tss[cpu].esp0=next-&gt;thread.esp0; 把next_p进程使用的线程局部存储(TLS)段装入本地CPU的全局描述符表；三个段选择符保存在进程描述符内的tls_array数组中。 123cpu_gdt_table[cpu&#125;[6] = next-&gt;thread.tls_array[0];cpu_gdt_table[cpu][7] = next-&gt;thread.tls_array[1];cpu_gdt_table[cpu][8] = next-&gt;thread.tls_array[2]; 把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中，对应的汇编语言指令是： 12movl %fs，40(%esi)movl %gs，44(%esi) esi寄存器指向prev_p-&gt;thread结构。 如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用(也就是说如果它们有一个非0的值)，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器中。这一步在逻辑上补充了前一步中执行的操作。主要的汇编语言指令如下： 12movl 40(%ebx)，%fsmovl 44(%ebx)，%gs ebx寄存器指向next_p-&gt;thread结构。代码实际上更复杂，因为当它检测到一个无效的段寄存器值时，CPU可能产生一个异常。代码采用一种“修正(fix-up)”途径来考虑这种可能性。 用next_p-&gt;thread.debugreg数组的内容装载dr0，…，dr7中的6个调试寄存器(x86调试器允许进程被硬件监控。最多可定义4个断点区域)。只有在next_p被挂起时正在使用调试寄存器(也就是说，next_p-&gt;thread.debugreg[7]字段不为0)，这种操作才能进行。这些寄存器不需要被保存，因为只有当一个调试器想要监控prev时prev_p-&gt;thread.debugreg才会被修改。 123456789if (next_p-&gt;thread.debugreg[7])&#123; loaddebug(&amp;next_p-&gt;thread, 0); loaddebug(&amp;next_p-&gt;thread, 1); loaddebug(&amp;next_p-&gt;thread, 2); loaddebug(&amp;next_p-&gt;thread, 3); /*没有4和5*/ loaddebug(&amp;next_p-&gt;thread, 6); loaddebug(&amp;next_p-&gt;thread, 7);&#125; 如果必要，更新TSS中的I/O位图。当next_p或prev_p有其自己的定制I/O权限位图时必须这么做： 12if (prev&#125;一&gt;thread.io_bitmap_ptr || next_p-&gt;thread.io_ bitmap_ptr)handle_io_bitmap(&amp;next_p-&gt;thread, &amp;init_tss[cpu]); 因为进程很少修改I/O权限位图，所以该位图在“懒”模式中被处理：当且仅当一个进程在当前时间片内实际访问I/O端口时，真实位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。handle_io_bitmap()函数为next_p进程设置本地CPU使用的TSS的io_bitmap字段如下： 如果next_p进程不拥有自己的I/O权限位图，则TSS的io_bitmap字段被设为0x8000。 如果next_p进程拥有自己的I/O权限位图，则TSS的io_bitmap字段被设为0x9000。 TSS的io_bitmap字段应当包含一个在TSS中的偏移量，其中存放实际位图。无论何时用户态进程试图访问一个1/O端口，0x8000和0x9000指向TSS界限之外并将因此引起“General protection”异常。 do_general_protection()异常处理程序将检查保存在io_bitmap字段的值;如果是0x8000,函数发送一个SIGSEGV信号给用户态进程;如果是0x9000,函数把进程位图(由thread_info结构中的io_bitmap_ptr字段指示)拷贝到本地CPU的TSS中，把io_bitmap字段设为实际位图的偏移(104)，并强制再一次执行有缺陷的汇编语言指令。 终止。__switch_to() C函数通过使用下列声明结束： 1return prev_p; ​ 由编译器产生的相应汇编语言指令是： 12movl %edi, %eaxret ​ prevp参数(现在在edi中)被拷贝到eax，因为缺省情况下任何C函数的返回值被传递给eax寄存器。注意eax的值因此在调用\_switch_to()的过程中被保护起来;这非常重要，因为调用switch_to宏时会假定eax总是用来存放将被替换的进程描述符的地址。 ​ 汇编语言指令ret把栈顶保存的返回地址装人eip程序计数器。不过，通过简单地跳转到__switch_to()函数来调用该函数。因此，ret汇编指令在栈中找到标号为1的指令的地址，其中标号为1的地址是由switchto宏推入栈中的。如果因为next第一次执行而以前从未被挂起，\_switch_to()就找到ret_from_fork()函数的起始地址(参见本章后面“clone(),fork()和vfork()系统调用一节”)。 创建进程Unix操作系统紧紧依赖进程创建来满足用户的需求。例如，只要用户输入一条命令，shell进程就创建一个新进程，新进程执行shell的另一个拷贝。 现代Unix内核通过引入三种不同的机制解决了这个问题： 写时复制技术允许父子进程读相同的物理页。只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。 轻量级进程允许父子进程共享每进程在内核的很多数据结构，如页表(也就是整个用户态地址空间)、打开文件表及信号处理。 vfork()系统调用创建的进程能共享其父进程的内存地址空间。为了防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到子进程退出或执行一个新的程序为止。 clone()、fork()及vfork()系统调用在Linux中，轻量级进程是由名为clone()的函数创建的，这个函数使用下列参数： 参数 描述 fn 指定一个由新进程执行的函数。当这个函数返回时，子进程终止。函数返回一个整数，表示子进程的退出代码。 arg 指向传递给fn()函数的数据。 flags 各种各样的信息。低字节指定子进程结束时发送到父进程的信号代码，通常选择SIGCHLD信号。剩余的3个字节给clone标志组用于编码。 child_stack 表示把用户态堆栈指针赋给子进程的esp寄存器。调用进程(指调用clone()的 父进程)应该总是为子进程分配新的堆栈。 tls 表示线程局部存储段(TLS)数据结构的地址，该结构是为新轻量级进程定义的。只有在CLONE_SETTLS标志被设置时才有意义。 ptid 表示父进程的用户态变量地址，该父进程具有与新轻量级进程相同的PID。只有在CLONE_PARENT_SETTID标志被设置时才有意义。 ctid 表示新轻量级进程的用户态变量地址，该进程具有这一类进程的PID。只有在CLONECHILD SETTID标志被设置时才有意义。 clone标志： 标志名称 说明 CLONE_VM 共享内存描述符和所有的页表 CLONE_FS 共享根目录和当前工作目录所在的表，以及用于屏蔽新文件初始许可权的位掩码值(所谓文件的umask ) CLONE_FILES 共享打开文件表 CLONE_SIGHAND 共享信号处理程序的表、阻塞信号表和挂起信号表。如果这个标志为true,就必须设置CLONE_VM标志 CLONE_PTRACE 如果父进程被跟踪，那么，子进程也被跟踪。尤其是，debugger程序可能希望以自己作为父进程来跟踪子进程，在这种情况下，内核把该标志强置为1 CLONE_VFORK 在发出vfork()系统调用时设置(参见本节后面) CLONE_PARENT 设置子进程的父进程(进程描述符中的parent和real_parent字段)为调用进程的父进程 CLONE_THREAD 把子进程插入到父进程的同一线程组中，并迫使子进程共享父进程的信号描述符。因此也设置子进程的tgid字段和group_leader字段。如果这个标志位为true，就必须设置CLONE_SIGRAND标志 CLONE_NEWNS 当clone需要自己的命名空间时(即它自己的已挂载文件系统视图)设置这个标志。不能同时设置CLONE_NEWNS和CLONE_FS CLONE_SYSVSEM 共享System V IPC取消信号量的操作 CLONE_SETTLS 为轻量级进程创建新的线程局部存储段(TLS)，该段由参数tls所指向的结构进行描述 CLONE_PARENT_SETTID 把子进程的PID写入由ptid参数所指向的父进程的用户态变量 CLONE_CHILD_CLEARTID 如果该标志被设置，则内核建立一种触发机制，用在子进程要退出或要开始执行新程序时。在这些情况下，内核将清除由参数ctid所指向的用户态变量，并唤醒等待这个事件的任何进程 CLONE_DETACHED 遗留标志.内核会忽略它 CLONE_UNTRACED 内核设置这个标志以使CLONE_PTRACE标志失去作用(用来禁止内核线程跟踪进程，参见本章稍后的“内核线程”一节) CLONE_CHILD_SETTID 把子进程的PID写入由ctid参数所指向的子进程的用户态变量中 CLONE_STOPPED 强迫子进程开始于TASK_STOPPED状态 实际上，clone()是在C语言库中定义的一个封装(wrapper)函数，它负责建立新轻量级进程的堆栈并且调用对编程者隐藏的clone()系统调用。实现clone()系统调用的sys_clone()服务例程没有fn和arg参数。实际上，封装函数把fn指针存放在子进程堆栈的某个位置处，该位置就是该封装函数本身返回地址存放的位置。arg指针正好存放在子进程堆栈中fn的下面。当封装函数结束时，CPU从堆栈中取出返回地址，然后执行fn(arg)函数。 传统的fork()系统调用在Linux中是用clone()实现的，其中clone()的flags参数指定为SIGCHLD信号及所有清0的clone标志，而它的child_stack参数是父进程当前的堆栈指针。因此，父进程和子进程暂时共享同一个用户态堆栈。但是，要感谢写时复制机制，通常只要父子进程中有一个试图去改变栈，则立即各自得到用户态堆栈的一份拷贝。 前一节描述的vfork()系统调用在Linux中也是用clone()实现的，其中clone()的参数flags指定为SIGCHLD信号和CLONE_VM及CLONEVFORK标志，clone()的参数child stack等于父进程当前的栈指针。 do_fork()函数do_fork()函数负责处理clone(),fork()和vfork()系统调用，执行时使用下列参数： 参数 描述 clone_flags 与clone()的参数flags相同 stack_start 与clone()的参数child_stack相同 regs 指向通用寄存器值的指针，通用寄用器的值是在从用户态切换到内核态时被保存到内核态堆栈中的 stack_size 未使用(总是被设置为O) parent_tidptr child_tidptr 与clone()中的对应参数ptid和ctid相同 do_fork()利用辅助函数copy_process()来创建进程描述符以及子进程执行所需要的所有其他内核数据结构。下面是do_fork()执行的主要步骤： 通过查找pidmap_array位图，为子进程分配新的PID。 检查父进程的ptrace字段(current-&gt;ptrace)：如果它的值不等于0，说明有另外一个进程正在跟踪父进程，因而，do_fork()检查debugger程序是否自己想跟踪子进程(独立于由父进程指定的CLONE_PTRACE标志的值)。在这种情况下，如果子进程不是内核线程(CLONE_UNTRACED标志被清0)，那么do_fork()函数设置CLONE_PTRACE标志。 调用copy_process()复制进程描述符。如果所有必须的资源都是可用的，该函数返回刚创建的task_struct描述符的地址。这是创建过程的关键步骤。 如果设置了CLONE_STOPPED标志，或者必须跟踪子进程，即在p-&gt;ptrace中设置了PT_PTRACED标志，那么子进程的状态被设置成TASK_STOPPED，并为子进程增加挂起的SIGSTOP信号。在另外一个进程(不妨假设是跟踪进程或是父进程)把子进程的状态恢复为TASK_RUNNING之前(通常是通过发送SIGCONT信号)，子进程将一直保持TASK_STOPPED状态。 如果没有设置CLONE_STOPPED标志，则调用wake_up_new_task()函数以执行下述操作： 调整父进程和子进程的调度参数。 如果子进程将和父进程运行在同一个CPU上(当内核创建新进程时，父进程可能被转移到另一个CPU上执行)，而且父进程和子进程不能共享同一组页表(CLONE_VM标志被清0)，那么，就把子进程插入父进程运行队列，插入时让子进程恰好在父进程前面，因此而迫使子进程先于父进程运行。如果子进程刷新其地址空间，并在创建之后执行新程序，那么这种简单的处理会产生较好的性能。而如果我们让父进程先运行，那么写时复制机制将会执行一系列不必要的页面复制。 否则，如果子进程与父进程运行在不同的CPU上，或者父进程和子进程共享同一组页表(CLONE_VM标志被设置)，就把子进程插入父进程运行队列的队尾。 如果CLONE_STOPPED标志被设置，则把子进程置为TASK_STOPPED状态。 如果父进程被跟踪，则把子进程的PID存入current的ptrace_message字段并调用ptrace_notify()。ptrace_notify()使当前进程停止运行，并向当前进程的父进程发送SIGCHLD信号。子进程的祖父进程是跟踪父进程的debugger进程。SIGCHLD信号通知debugger进程：current已经创建了一个子进程，可以通过查找current-&gt;ptrace_message字段获得子进程的PID。 如果设置了CLONE_VFORK标志，则把父进程插入等待队列，并挂起父进程直到子进程释放自己的内存地址空间(也就是说，直到子进程结束或执行新的程序)。 结束并返回子进程的PID。 copy_process()函数copy_process()创建进程描述符以及子进程执行所需要的所有其他数据结构。它的参数与do_fork()的参数相同，外加子进程的PID。下面描述copy_process()的最重要的步骤： 检查参数clone_flags所传递标志的一致性。在下列情况下，它返回错误代号： CLONE_NEWNS和CLONE_FS标志都被设置。 CLONE_THREAD标志被设置，但CLONE_SIGRAND标志被清0(同一线程组中的轻量级进程必须共享信号)。 CLONE_SIGHAND标志被设置，但CLONE_VM被清0(共享信号处理程序的轻量级进程也必须共享内存描述符)。 通过调用security_task_create()以及稍后调用的security_task_alloc()执行所有附加的安全检查。Linux 2.6提供扩展安全性的钩子函数，与传统Unix相比，它具有更加强壮的安全模型。 调用dup_task_struct()为子进程获取进程描述符。该函数执行如下操作（参数为current）： 如果需要，则在当前进程中调用__unlazy_fpu()，把FPU,MMX和SSE/SSE2寄存器的内容保存到父进程的thread_info结构中。稍后，dup_task_struct()将把这些值复制到子进程的thread_info结构中。 执行alloc_task_struct()宏，为新进程获取进程描述符(task_struct结构)，并将描述符地址保存在tsk局部变量中。 执行alloc_thread_info宏以获取一块空闲内存区，用来存放新进程的thread_info结构和内核栈，并将这块内存区字段的地址存在局部变量ti中。这块内存区字段的大小是8KB或4KB。 将current进程描述符的内容复制到tsk所指向的taskstruct结构中，然后把tsk-&gt;thread info置为ti。 把current进程的thread_info描述符的内容复制到ti所指向的结构中，然后把ti-&gt;task置为tsk。 把新进程描述符的使用计数器(tsk-&gt;usage)置为2，用来表示进程描述符正在被使用而且其相应的进程处于活动状态(进程状态即不是EXIT_ ZOMBIE,也不是EXIT_DEAD)。 返回新进程的进程描述符指针(tsk)。 检查存放在current-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur变量中的值是否小于或等于用户所拥有的进程数。如果是，则返回错误码，除非进程没有root权限。该函数从每用户数据结构user_struct中获取用户所拥有的进程数。通过进程描述符user字段的指针可以找到这个数据结构。 递增userstruct结构的使用计数器(tsk-&gt;user-&gt;\_count字段)和用户所拥有的进程的计数器(tsk-&gt;user-&gt;processes)。 检查系统中的进程数量(存放在nr_threads变量中)是否超过max_threads变量的值。这个变量的缺省值取决于系统内存容量的大小。总的原则是：所有thread_info描述符和内核栈所占用的空间不能超过物理内存大小的1/8。不过，系统管理员可以通过写/proc/sys/kernel/threads-max文件来改变这个值。 如果实现新进程的执行域和可执行格式的内核函数都包含在内核模块中，则递增它们的使用计数器。 设置与进程状态相关的几个关键字段： 把大内核锁计数器tsk-&gt;lock_depth初始化为-1。 把tsk-&gt;did_exec字段初始化为0；它记录了进程发出的execve()系统调用的次数。 更新从父进程复制到tsk-&gt;flags字段中的一些标志:首先清除PF_SUPERPRIV标志，该标志表示进程是否使用了某种超级用户权限。然后设置PF_FORKNOEXEC标志，它表示子进程还没有发出execve()系统调用。 把新进程的PID存人tsk-&gt;pid字段。 如果clone_flags参数中的CLONE_PARENT_SETTID标志被设置，就把子进程的PID复制到参数parent_tidptr指向的用户态变量中。 初始化子进程描述符中的list_head数据结构和自旋锁，并为与挂起信号、定时器及时间统计表相关的几个字段赋初值。 调用copy_semundo()，copy_files()，copy_fs()，copy_sighand()，copy_signal() , copy_mm()和copy namespace()来创建新的数据结构，并把父进程相应数据结构的值复制到新数据结构中，除非clone_flags参数指出它们有不同的值。 调用copy_thread()，用发出clone()系统调用时CPU寄存器的值(这些值已经被保存在父进程的内核栈中)来初始化子进程的内核栈。不过，copy_thread()把eax寄存器对应字段的值[这是fork()和clone()系统调用在子进程中的返回值]字段强行置为0。子进程描述符的thread.esp字段初始化为子进程内核栈的基地址，汇编语言函数(ret_from_fork())的地址存放在thread.eip字段中。如果父进程使用I/O权限位图，则子进程获取该位图的一个拷贝。最后，如果CLONE_SETTLS标志被设置，则子进程获取由clone()系统调用的参数tls指向的用户态数据结构所表示的TLS段(tls并不被传递给do_fork()和嵌套函数。在第十章会看到，通过拷贝系统调用的参数的值到某个CPU寄存器来把它们传递给内核；因此，这些值与其他寄存器一起被保存在内核态堆栈中。copy_thread()只查看esi的值在内核堆栈中对应的位置保存的地址)。 如果clone_flags参数的值被置为CLONE_CHILD_SETTID或CLONE_CHILD_CLEARTID,就把child_tidptr参数的值分别复制到tsk-&gt;setchid_tid或tsk-&gt;clear_child_tid字段。这些标志说明：必须改变子进程用户态地址空间的child_tidptr所指向的变量的值，不过实际的写操作要稍后再执行。 清除子进程thread_info结构的TIF_SYSCALL_TRACE标志，以使ret_from_fork()函数不会把系统调用结束的消息通知给调试进程。(因为对子进程的跟踪是由tsk-&gt;ptrace中的PTRACE_SYSCALL标志来控制的，所以子进程的系统调用跟踪不会被禁用。) 用clone_flags参数低位的信号数字编码初始化tsk-&gt;exit_signal字段，如果CLONE_THREAD标志被置位，就把tsk-&gt;exit_sinal字段初始化为-1。只有当线程组的最后一个成员(通常是线程组的领头)“死亡”，才会产生一个信号，以通知线程组的领头进程的父进程。 调用sched_fork()完成对新进程调度程序数据结构的初始化。该函数把新进程的状态设置为TASK_RUNNING，并把thread_info结构的preempt_count字段设置为1，从而禁止内核抢占。此外，为了保证公平的进程调度，该函数在父子进程之间共享父进程的时间片。 把新进程的thread_info结构的cpu字段设置为由smp_processor_id()所返回的本地CPU号。 初始化表示亲子关系的字段。尤其是，如果CLONE_PARENT或CLONE_THREAD被设置，就用curent-&gt;real_parent的值初始化tsk-&gt;real_parent和tsk-&gt;parent,因此，子进程的父进程似乎是当前进程的父进程。否则，把tsk-&gt;real_parent和tsk-&gt;parent置为当前进程。 如果不需要跟踪子进程(没有设置CLONE_PTRAC标志)，就把tsk-&gt;ptrace字段设置为O。tsk-&gt;ptrace字段会存放一些标志，而这些标志是在一个进程被另外一个进程跟踪时才会用到的。采用这种方式，即使当前进程被跟踪，子进程也不会被跟踪。 执行SET_LINKS宏，把新进程描述符插人进程链表。 如果子进程必须被跟踪(tsk-&gt;ptrace字段的PT_PTRACED标志被设置)，就把current-&gt;parent赋给tsk-&gt;parent，并将子进程插入调试程序的跟踪链表中。 调用attach_pid()把新进程描述符的PID插入pidhash[PIDTYPE_PID]散列表。 如果子进程是线程组的领头进程(CLONE_THREAD标志被清0)： 把tsk-&gt;tgid的初值置为tsk-&gt;pid。 把tsk-&gt;group_leader的初值置为tsk。 调用三次attach_pid()，把子进程分别插入PIDTYPE_TGID, PIDTYPE_PGID和PIDTYPE_SID类型的PID散列表。 否则，如果子进程属于它的父进程的线程组(CLONE_THREAD标志被设置)： 把tsk-&gt;tgid的初值置为tsk-&gt;current-&gt;tgid。 把tsk-&gt;group_leader的初值置为current-&gt;group_leader的值。 调用attach_pid()，把子进程插入PIDTYPE_TGID类型的散列表中(更具体地说，插入current-&gt;group_leader进程的每个PID链表)。 现在，新进程已经被加入进程集合:递增nr_threads变量的值。 递增total_forks变量以记录被创建的进程的数量。 终止并返回子进程描述符指针(tsk)。 现在，我们有了处于可运行状态的完整的子进程。但是，它还没有实际运行，调度程序要决定何时把CPU交给这个子进程。在以后的进程切换中，调度程序继续完善子进程:把子进程描述符thread字段的值装入几个CPU寄存器。特别是把thread.esp(即把子进程内核态堆栈的地址)装人esp寄存器，把函数ret_from_fork()的地址装人eip寄存器。这个汇编语言函数调用schedule_tail()函数(它依次调用finish_task_switch()来完成进程切换)，用存放在栈中的值再装载所有的寄存器，并强迫CPU返回到用户态。然后，在fork(),vfork()或clone()系统调用结束时，新进程将开始执行。系统调用的返回值放在eax寄存器中:返回给子进程的值是0，返回给父进程的值是子进程的PID。回顾copy_thread()对子进程的eax寄存器所执行的操作(copy_process()的第13步)，就能理解这是如何实现的。 除非fork系统调用返回0，否则，子进程将与父进程执行相同的代码(参见copy_process()的第13步)。应用程序的开发者可以按照Unix编程者熟悉的方式利用这一事实，在基于PID值的程序中插人一个条件语句使子进程与父进程有不同的行为。 内核线程传统的Unix系统把一些重要的任务委托给周期性执行的进程，这些任务包括刷新磁盘高速缓存，交换出不用的页框，维护网络连接等等。事实上，以严格线性的方式执行这些任务的确效率不高，如果把它们放在后台调度，不管是对它们的函数还是对终端用户进程都能得到较好的响应。因为一些系统进程只运行在内核态，所以现代操作系统把它们的函数委托给内核线程(kernel thread)，内核线程不受不必要的用户态上下文的拖累。在Linux中，内核线程在以下几方面不同于普通进程： 内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。 因为内核线程只运行在内核态，它们只使用大于PAGE_OFFSET的线性地址空间。另一方面，不管在用户态还是在内核态，普通进程可以用4GB的线性地址空间。 创建一个内核线程kernel_thread()函数创建一个新的内核线程，它接受的参数有：所要执行的内核函数的地址(fn)、要传递给函数的参数(arg)、一组clone标志(flags)。该函数本质上以下面的方式调用do_fork()： 12345678910111213141516171819int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)&#123; struct pt_regs regs; memset(&amp;regs, 0, sizeof(regs)); regs.ebx = (unsigned long) fn; regs.edx = (unsigned long) arg; regs.xds = __USER_DS; regs.xes = __USER_DS; regs.orig_eax = -1; regs.eip = (unsigned long) kernel_thread_helper; regs.xcs = __KERNEL_CS; regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2; /* Ok, create the new process.. */ return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &amp;regs, 0, NULL, NULL);&#125; CLONE_VM标志避免复制调用进程的页表:由于新内核线程无论如何都不会访问用户态地址空间，所以这种复制无疑会造成时间和空间的浪费。CLONE_UNTRACED标志保证不会有任何进程跟踪新内核线程，即使调用进程被跟踪。 传递给do_fork()的参数regs表示内核栈的地址，copy_thread()函数将从这里找到为新线程初始化CPU寄存器的值。kernel_thread()函数在这个栈中保留寄存器值的目的是： 通过copy_thread()把ebx和edx分edx设置为参数fn和arg的值。 把eip寄存器的值设置为下面汇编语言代码段的地址： 12345movl %edx, %eaxpushl %edxcall *%ebxpushl %eaxcall do_exit 因此，新的内核线程开始执行fn(arg)函数，如果该函数结束，内核线程执行系统调用_exit()，并把fn()的返回值传递给它。 进程0所有进程的祖先叫做进程0，idle进程或因为历史的原因叫做swapper进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构(所有其他进程的数据结构都是动态分配的)： 存放在init_task变量中的进程描述符，由INIT_TASK宏完成对它的初始化。 存放在init_thread_union变量中的thread_info描述符和内核堆栈，由INIT_THREAD_INFO宏完成对它们的初始化。 | 线程 | 描述 || ———– | —————————————- || keventd(事件) | 执行keventd_wq工作队列中的函数。 || kapmd | 处理与高级电源管理(APM)相关的事件。 || kswapd | 执行内存回收，在第十七章“周期回收”一节将进行描述。 || pdflush | 刷新“脏”缓冲区中的内容到磁盘以回收内存，在第十五章“pdflush内核线程”一 || kblockd | 执行kblockd_workqueue工作队列中的函数。周期性地激活块设备驱动程序。 || ksoftirqd | 运行tasklet。系统中每个CPU都有这样一个内核线程。 | 主内核页全局目录存放在swapper_pg_dir中。 start_kernel()函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程1的内核线程(一般叫做init进程)： 1kernel_thread(init, NULL, CLONE_FS | CLONE_SIGHAND); 新创建内核线程的PID为1，并与进程0共享每进程所有的内核数据结构。此外，当调度程序选择到它时，init进程开始执行init()函数。 创建init进程后，进程0执行cpu_idle()函数，该函数本质上是在开中断的情况下重复执行hlt汇编语言指令。只有当没有其他进程处于TASK_RUNNING状态时，调度程序才选择进程O。 在多处理器系统中，每个CPU都有一个进程0。只要打开机器电源，计算机的BIOS就启动某一个CPU，同时禁用其他CPU。运行在CPU 0上的swapper进程初始化内核数据结构，然后激活其他的CPU，并通过copy_process()函数创建另外的swapper进程，把0传递给新创建的swapper进程作为它们的新PID。此外，内核把适当的CPU索引赋给内核所创建的每个进程的thread_info描述符的cpu字段。 进程1由进程0创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init。结果，init内核线程变为一个普通进程，且拥有自己的每进程(per-process)内核数据结构。在系统关闭之前，init进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。 其他内核线程Linux使用很多其他内核线程。其中一些在初始化阶段创建，一直运行到系统关闭；而其他一些在内核必须执行一个任务时“按需”创建，这种任务在内核的执行上下文中得到很好的执行。 一些内核线程的例子(除了进程0和进程1)是： 线程 描述 keventd(也被称为事件) 执行keventd_wq工作队列中的函数。 kapmd 处理与高级电源管理(APM)相关的事件。 kswapd 执行内存回收，在第十七章“周期回收”一节将进行描述。 pdflush 刷新“脏”缓冲区中的内容到磁盘以回收内存，在第十五章“pdflush内核线程”一 kblockd 执行kblockd_workqueue工作队列中的函数。实质上，它周期性地激活块设备驱动程序。 ksoftirqd 运行tasklet。系统中每个CPU都有这样一个内核线程。 撤销进程很多进程终止了它们本该执行的代码，从这种意义上说，这些进程“死”了。当这种情况发生时，必须通知内核以便内核释放进程所拥有的资源，包括内存、打开文件及其他我们在本书中讲到的零碎东西，如信号量。 进程终止的一般方式是调用exit()库函数，该函数释放c函数库所分配的资源，执行编程者所注册的每个函数，并结束从系统回收进程的那个系统调用。exit()函数可能由编程者显式地插入。另外，C编译程序总是把exit()函数插入到main()函数的最后一条语句之后。 内核可以有选择地强迫整个线程组死掉。这发生在以下两种典型情况下： 当进程接收到一个不能处理或忽视的信号时。 当内核正在代表进程运行时在内核态产生一个不可恢复的CPU异常时。 进程终止在Linux 2.6中有两个终止用户态应用的系统调用： exit_grpup()系统调用，它终止整个线程组，即整个基于多线程的应用。do_group_exit()是实现这个系统调用的主要内核函数。这是C库函数exit()应该调用的系统调用。 exit()系统调用，它终止某一个线程，而不管该线程所属线程组中的所有其他进程。do_exit()是实现这个系统调用的主要内核函数。这是被诸如pthread_exit()的Linux线程库的函数所调用的系统调用。 do_group_exit()函数do_group_exit()函数杀死属于current线程组的所有进程。它接受进程终止代号作为参数，进程终止代号可能是系统调用exit_group()(正常结束)指定的一个值，也可能是内核提供的一个错误代号(异常结束)。该函数执行下述操作： 检查退出进程的SIGNAL_GROUP_EXIT标志是否不为0，如果不为0，说明内核已经开始为线程组执行退出的过程。在这种情况下，就把存放在current-&gt;signal-&gt;group_exit_code中的值当作退出码，然后跳转到第4步。 否则，设置进程的SIGNAL_GROUP_EXIT标志并把终止代号存放到current-&gt;signal-&gt;group_exit_code字段。 调用zap_other_threads()函数杀死current线程组中的其他进程(如果有的话)。为了完成这个步骤，函数扫描与current-&gt;tgid对应的PIDTYPE_TGID类型的散列表中的每个PID链表，向表中所有不同于current的进程发送SIGKILL信号，结果，所有这样的进程都将执行do_exit()函数，从而被杀死。 调用do_exit()函数，把进程的终止代号传递给它。do_exit()杀死进程而且不再返回。 do_exit()函数所有进程的终止都是由do_exit()函数来处理的，这个函数从内核数据结构中删除对终止进程的大部分引用。do_exit()函数接受进程的终止代号作为参数并执行下列操作： 把进程描述符的flag字段设置为PF_EXITING标志，以表示进程正在被删除。 如果需要，通过函数del_timer_sync()从动态定时器队列中删除进程描述符。 分别调用exit_mm(),exitsem(),\_exitfiles(),\_exit_fs(),exit_namespace()和exit_thread()函数从进程描述符中分离出与分页、信号量、文件系统、打开文件描述符、命名空间以及I/O权限位图相关的数据结构。如果没有其他进程共享这些数据结构，那么这些函数还删除所有这些数据结构中。 如果实现了被杀死进程的执行域和可执行格式的内核函数包含在内核模块中，则函数递减它们的使用计数器。 把进程描述符的exit_code字段设置成进程的终止代号，这个值要么是_exit()或exit_group()系统调用参数(正常终止)，要么是由内核提供的一个错误代号(异常终止)。 调用exit_notify()函数执行下面的操作： 更新父进程和子进程的亲属关系。如果同一线程组中有正在运行的进程，就让终止进程所创建的所有子进程都变成同一线程组中另外一个进程的子进程，否则让它们成为init的子进程。 检查被终止进程其进程描述符的exit_signal字段是否不等于-1，并检查进程是否是其所属进程组的最后一个成员(注意：正常进程都会具有这些条件，参见前面“clone(),fork()和vfork()系统调用”一节中对copy_process()的描述，第16步)。在这种情况下，函数通过给正被终止进程的父进程发送一个信号(通常是SIGCHLD)，以通知父进程子进程死亡。 否则，也就是exit_signal字段等于-1，或者线程组中还有其他进程，那么只要进程正在被跟踪，就向父进程发送一个SIGCHLD信号(在这种情况下，父进程是调试程序，因而，向它报告轻量级进程死亡的信息)。 如果进程描述符的exit_signal字段等于-1，而且进程没有被跟踪，就把进程描述符的exit_state字段置为EXIT_DEAD，然后调用release_task()回收进程的其他数据结构占用的内存，并递减进程描述符的使用计数器(见下一节)。使用记数器变为1(参见copy_process()函数的第3f步)，以使进程描述符本身正好不会被释放。 否则，如果进程描述符的exit_signal字段不等于-1，或进程正在被跟踪，就把exit_state字段置为EXIT_ZOMBIE。在下一节我们将看到如何处理僵死进程。 把进程描述符的flags字段设置为PF_DEAD标志。 调用schedule()函数选择一个新进程运行。调度程序忽略处于EXIT_ZOMBIE状态的进程，所以这种进程正好在schedule()中的宏switch_to被调用之后停止执行。正如在第七章我们将看到的:调度程序将检查被替换的僵死进程描述符的PF_DEAD标志并递减使用计数器，从而说明进程不再存活的事实。 进程删除Unix允许进程查询内核以获得其父进程的PID,或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如wait()这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么，它的终止代号将告诉父进程这个任务是否已成功地完成。 为了遵循这些设计选择，不允许Unix内核在进程一终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait()类系统调用之后，才允许这样做。这就是引入僵死状态的原因:尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。 如果父进程在子进程结束之前结束会发生什么情况呢?在这种情况下，系统中会到处是僵死的进程，而且它们的进程描述符永久占据着RAM。如前所述，必须强迫所有的孤儿进程成为init进程的子进程来解决这个问题。这样，init进程在用wait()类系统调用检查其合法的子进程终止时，就会撤消僵死的进程。 release_task()函数从僵死进程的描述符中分离出最后的数据结构；对僵死进程的处理有两种可能的方式： 如果父进程不需要接收来自子进程的信号，就调用do_exit()。 如果已经给父进程发送了一个信号，就调用wait4()或waitpid()系统调用。 在后一种情况下，函数还将回收进程描述符所占用的内存空间，而在前一种情况下，内存的回收将由进程调度程序来完成。该函数执行下述步骤： 递减终止进程拥有者的进程个数。这个值存放在本章前面提到的user_struct结构中(参见copy_process()的第4步)。 如果进程正在被跟踪，函数将它从调试程序的ptrace_children链表中删除，并让该进程重新属于初始的父进程。 调用__exit_signal()删除所有的挂起信号并释放进程的signal_struct描述符。如果该描述符不再被其他的轻量级进程使用，函数进一步删除这个数据结构。此外，函数调用exit_itimers()从进程中剥离掉所有的POSIX时间间隔定时器。 调用__exit_sighand()删除信号处理函数。 调用__unhash_process() ,该函数依次执行下面的操作： 变量nr_threads减1。 两次调用detach_pid()，分别从PIDTYPE_PID和PIDTYPE_TGID类型的PID散列表中删除进程描述符。 如果进程是线程组的领头进程，那么再调用两次detach_pid()，从PIDTYPE_PGID和PIDTYPE_SID类型的散列表中删除进程描述符。 用宏REMOVE_LINKS从进程链表中解除进程描述符的链接。 如果进程不是线程组的领头进程，领头进程处于僵死状态，而且进程是线程组的最后一个成员，则该函数向领头进程的父进程发送一个信号，通知它进程已死亡。 调用sched_exit()函数来调整父进程的时间片(这一步在逻辑上作为对copy_process()第17步的补充)。 调用put_task_struct()递减进程描述符的使用计数器，如果计数器变为0，则函数终止所有残留的对进程的引用。 递减进程所有者的userstruct数据结构的使用计数器(\_count字段)(参见copy_process()的第5步)，如果使用计数器变为0，就释放该数据结构。 释放进程描述符以及thread_info描述符和内核态堆栈所占用的内存区域。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>深入理解Linux内核</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内存寻址]]></title>
    <url>%2F2017%2F09%2F09%2FLinux-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[内存地址分类逻辑地址：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 线性地址（或 虚拟地址）：一个32位（或64位）无符号整数，在32位系统中可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 * 1024 * 1024 * 1024个内存单元（字节）。 物理地址（physical address）：芯片级内存单元寻址。与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。 内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。 硬件中的分段段选择符和段寄存器逻辑地址由两部分组成：段选择符和指定段内相对地址的偏移量。段选择符（Segment Selector）是一个16位长的字段，而偏移量是一个32位长的字段。 字段名 描述 索引 指定了放在GDT或LDT中的相应段描述符 TI TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） RPL 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 处理器提供段寄存器来存放段选择符以保证查找段选择符的效率。这些段寄存器称为cs, ss, ds, es, fs和gs。程序可以把同一个段寄存器用于不同的目的：先将其值保存在内存中，用完后再恢复。6个段寄存器中3个有专门的用途： cs 代码段寄存器，指向包含程序指令的段。 ss 栈段寄存器，指向包含当前程序栈的段。 ds 数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。 其他3个段寄存器作一般用途，可以指向任意的数据段。cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。0代表最高优先级——内核态，而3代表最低优先级——用户态。 段描述符每个段由一个 8字节（64 bit） 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。 字段名 描述 基地址（Base） 包含段的首字节的线性地址 （32 bit） G 粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计 Limit 最大段偏移量，段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化 S 系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段 Type 描述了段的类型特征和它的存取权限 DPL 描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级 P Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去 D或B 取决于是代码段还是数据段 AVL 操作系统使用，但被Linux忽略 为加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。 分段单元下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作： 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。 有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。 Linux中的分段2.6版的Linux只有在x86结构下才需要分段。 运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：内核代码段和内核数据段。 下表显示了这4个重要段的段描述符字段的值： 段 Base G Limit S Type DPL D/B p 用户代码段 0x0000 0000 1 0xfffff 1 10 3 1 1 用户数据段 0x0000 0000 1 0xfffff 1 2 3 1 1 内核代码段 0x0000 0000 1 0xfffff 1 10 0 1 1 内核数据段 0x0000 0000 1 0xfffff 1 2 0 1 1 G为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB 相应的段选择符由宏定义。 1__USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS 为了对内核代码段寻址，内核只需把__KERNEL_CS宏产生的值装进cs段寄存器即可。 注意，与段相关的线性地址从0开始，达到223 - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。 所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。 当对指向指令或者数据结构的指针进行保存时，内核不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏KERNEL_CS定义，所以只要当CPU切换到内核态时将KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。 Linux GDT在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。这些符号都在文件arch/i386/kernel/head.S中被定义。 下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。 每一个GDT中包含的18个段描述符指同下列的段： 用户态和内核态下的代码段和数据段，共4个。 任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb, 因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置 为0，因为不允许用户态下的进程访问TSS段。 1个包括缺省局部描述符表的段，这个段通常被所有进程共享。 3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。 与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。 与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。 被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。 系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项： 每个处理器都有它自己的TSS段。 GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。 在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。 Linux LDT大多数用户态下的Linux程序不使用局部描述符表，因此内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。 硬件中的分页分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。 为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。 分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。 把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。 从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。&lt;需要了解控制寄存器(cr0~cr3)的结构及作用&gt; 常规分页从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域： Directory（目录）：最高10位 Table（页表）：中间10位 Offset（偏移量）：最低12位 线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )。 页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。 使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达220个表项(4GB/4KB = 220 ，也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些“虚拟内存区”请求页表来减少内存容量。 每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。 正在使用的页目录的物理地址存放在控制寄存器cr3中。 页目录项和页表项有相同的结构，每项都包含下面的字段： 字段 描述 Present标志 置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。 包含页框物理地址最高20位的字段 由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。 Accessed标志 每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。 Dirty标志 只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。 Read/Write标志 含有页或页表的存取权限。 User/Supervisor标志 含有访问页或页表所需的特权级。 PCD和PWT标志 控制硬件高速缓存处理页或页表的方式。 Page Size标志 只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。 Global标志 只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。 扩展分页从Pentium模型开始，80x86微处理器引入了扩展分页（extended paging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。 通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段： Directory：最高10位 Offset：其余22位 扩展分页和正常分页的目录项基本相同，除了： Page Size标志必须被设置。 32位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。 通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。 硬件保护方案分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。 此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。 物理地址扩展（PAE）分页机制处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。 然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到236 = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。 从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。 通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。 Intel为了支持PAE改变了分页机制： 64GB的RAM被分为224个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。 引入一个叫做页目录指针表(Page Directory Pointer Table, PDPT)的页表新级别，它由4个64位表项组成。 cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(25)的倍数上对齐，因此27位足以表示这种表的基地址。 当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释： cr3：指向一个PDPT 位31-30：指向PDPT中4个项中的一个 位29-21：指向页目录中512个项目中的一个 位20-12：指向页表中512项中的一个 位11-0：4KB页中的偏移量 当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释： cr3：指向一个PDPT 位31-30：指向PDPT中4个项中的一个 位29-21：指向页目录中512个项中的一个 位20-0：2MB页中的偏移量 总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。 64位系统中的分页 平台名称 页大小 寻址使用的位数 分页级别数 线性地址分级 alpha 8KB 43 3 10+10+10+13 ia64 4KB 39 3 9+9+9+12 ppc64 4KB 41 3 10+10+9+12 sh64 4KB 41 3 10+10+9+12 x86_64 4KB 48 4 9+9+9+9+12 转换后援缓冲器（TLB）x86处理器包含了一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。 在多处理系统中，每个CPU都有自己的TLB，叫做该CPU的本地TLB。 当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。 Linux中的分页Linux采用了一种同时适用于32位和64位系统的普通分页模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为： 页全局目录(Page Global Directory ) 页上级目录(Page Upper Directory ) 页中级目录(Page Middle Directory ) 页表(Page Table) 对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。 启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。 最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。 Linux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行： 给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。 区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。 每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。 物理内存布局可参考 地址空间布局 在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。 内核将下列页框记为保留： 在不可用的物理地址范围内的页框。 含有内核代码和已初始化的数据结构的页框。 保留页框中的页绝不能被动态分配或交换到磁盘上。 一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小于3MB的RAM中。 为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如： 页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。 第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。 在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。 随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。 开始 结束 类型 0x0000 0000 0x0009 ffff Usable 0x000f 0000 0x000f ffff Reserved 0x0010 0000 0x07fe ffff Usable 0x07ff 0000 0x07ff 2ffff ACPI data 0x07ff 3000 0x07ff ffff ACPI NVS 0xffff 0000 0xffff ffff Reserved 上表显示了具有128MB(0x0800 0000) RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。 内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局。 为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM： 符号_text对应于物理地址0x0010 0000 （16MB），表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在_etext后开始，在_edata处结束。紧接着是未初始化的数据并以_end结束。 图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。 进程页表进程的线性地址空间分成两部分： 从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。 从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。 进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。 宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。 内核页表内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。 内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。 第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。 第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。 临时内核页表临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。 临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。 分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。 内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化： 0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。 把这四个项中的Present、Read/Write和User/Supervisor标志置位。 把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。 汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段： 12345movl $swapper_pg_dir-0xc0000000,%eaxmovl %eax,%cr3 /*设置页表指针*/movl %cr0,%eaxorl $0x80000000,%eaxmovl %eax,%cr0 /*设置分页(PG)位“/]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>深入理解Linux内核</tag>
        <tag>内存寻址</tag>
        <tag>分段</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理器发展的两种处理模式：实模式和保护模式]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Intel从80286开始引入保护模式，并与之前已存在的实模式并存。作为CPU运行的两种工作方式，具体有何区别，本文对其做简要说明。 实模式80286之前，处理器的内部数据总线、外部数据总线及位宽都是16位，但地址总线（物理引脚）为20位。因此它的可访问物理地址空间为 1MB（220字节）。 但是，由于其数据总线及位宽都是16位，最大只能代表有64KB的空间，小于地址总线能代表的1MB空间。为了解决这个问题，设计人员通过用16位的段寄存器内容左移4位，并和16位的段内偏移相加组成的20位代表1MB空间：物理地址 = (段寄存器内容 &lt;&lt; 4) + 段内偏移。 通过这种方式能表示的内存地址最大范围即为：0xfff &lt;&lt; 4 + 0xffff = 0x10 ffef。已大于1MB，为使地址正常访问，对已得地址对1MB取模，此方法称为 wrap-around。 现代处理器地址总线数已远超20，但是为了向下兼容，系统刚加电时依旧使用实模式。 保护模式实模式带来了一些问题，主要是物理地址可见带来的无法保证地址空间的安全性问题：不区分系统程序及用户程序，用户可随意更改处于物理内存的敏感数据，极易导致系统崩溃。因此引入保护模式。 以现在32位处理器为例：内部数据总线、外部数据总线、位宽及地址总线都为32位。 处于保护模式时，寻址方式发生些许改变：由逻辑地址转换为物理地址（开启分页时，中间需通过线性地址进行转换，本文不开启分页）。 逻辑地址由 16位段选择符和32位偏移量组成。段选择符格式如下图： 字段名 描述 索引 指定了放在GDT或LDT中的相应段描述符的入口 TI TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） RPL 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 索引指向存放在GDT（Global Descriptor Table，全局描述符表）或LDT（Local Descriptor Table，局部描述符表）中的段描述符，而段描述符中会存放段基地址，将得到的段基地址与逻辑地址中的段偏移量相加即得物理内存地址。 总结实模式中内存被划分成段，每个段的大小为64KB，而这样的段地址可以用16位来表示。内存段的处理是通过和段寄存器相关联的内部机制来处理的，这些段寄存器（CS、DS、 SS和ES）的内容形成了物理地址的一部分。具体来说，最终的物理地址是由16位的段寄存器和16位的段内偏移地址组成的。 在保护模式下，段是通过一系列被称之为“描述符表”的表所定义的。段寄存器存储的段选择符，指向GDT或LDT中的位置。]]></content>
      <categories>
        <category>处理器工作方式</category>
      </categories>
      <tags>
        <tag>实模式</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU 寄存器]]></title>
    <url>%2F2017%2F09%2F09%2FCPU-%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。 寄存器是集成电路中非常重要的一种存储单元，通常由D触发器组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。 寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。 16位寄存器以8086（16位处理器，14个寄存器）为例。按其用途可分为： 通用寄存器（8个）： 数据寄存器 AH&amp;AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的I/O指令都使用这一寄存器与外界设备传送数据。 BH&amp;BL=BX(base)：基址寄存器，常用于地址索引。 CH&amp;CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在移位指令,循环(loop)和串处理指令中用作隐含的计数器。 DH&amp;DL=DX(data)：数据寄存器，常用于数据传递。 这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低八位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。 指针寄存器和变址寄存器： SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。 BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。 SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。 DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。 这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。 指令指针（1个）： 指令指针（Instruction Pointer，IP）是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。 BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。 标志寄存器（1个）： 标志寄存器（Flags Register，FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。 在FR中有意义的有9位，其中6位是状态位，3位是控制位。 标志 描述 CF(carry flag) 进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 PF(parity flag) 奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 AF(adjust flag) 辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。 ZF(zero flag) 零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 SF(sign flag) 符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。 TF(trap flag) 跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。 IF(interrupt enable flag) 中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 DF(direction flag) 方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。 OF(overflow flag) 溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 段寄存器（4个）： CS（Code Segment）：代码段寄存器 DS（Data Segment）：数据段寄存器 SS（Stack Segment）：堆栈段寄存器 ES（Extra Segment）：附加段寄存器 当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻 址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。 备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。 32位寄存器32位CPU 寄存器及数据结构图： 通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI 尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。 EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。 EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。 EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。 标志寄存器（1个）：EFLAGS 控制任务状态和模式切换、中断处理、指令追踪和访问权限控制。寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)。 在16位标志寄存器的基础上增加了几个标志： 标志 描述 IOPL(I/O privilege level field) 指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 NT(Nested task flag) 控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。 RF(Resume flag) 控制处理器对调试异常的响应。 VM(Virtual-8086 mode flag) 置1以允许虚拟8086模式，清除则返回保护模式。 AC(Alignment check flag) 该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 VIF(Virtual interrupt flag) 该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions) VIP(Virtual interrupt pending flag) 该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。 ID(Identification flag) 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。 控制寄存器（Control Register）（5个）：CR0-CR4 控制寄存器决定处理器的操作模式和当前执行任务的一些特征。 CR0：控制系统的工作模式和处理器的状态；x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。 标志 描述 PE(Protected-Mode Enable) PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。 MP 协处理器监视标志位 EM 该位表明是否需要仿真协处理器的功能 TS 每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位 ET 扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令 NE 数字错误标志位(与浮点协处理器共同使用) WP 写保护 AM 对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用) NW 直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 ) CD cache 缺失设置位 PG(Paging Enable) 控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。 ​ CR1：保留 ​ CR2：存放发生页错误时的虚拟地址 CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。 标志 描述 PWT(Page-Level Writethrough) 控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效 PCD(Page-Level Cache Disable) PCD=1，表示最高目录表不可缓存，PCD=0，相反 Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。 Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以 page_directory_table base address为27位，指向32B对齐的页目录指针表。 ​ CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。 标志 描述 VME(virtual 8086 mode extension) 虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。 PVI(protected mode virtual interrupts) 保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。 TSD(time stamp disable) 禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。 DE(debugging extensions) 调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。 PSE(page size extensions) 允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。 PAE(physical address extension) 允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。 MCE(machine check exception) 允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。 PGE(Page-Global Enable) 将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。 PCE(Performance-Monitoring Counter Enable) 将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。 OSFXSR(FXSAVE/FXRSTOR Support) 设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。 OSXMMEXCPT(Unmasked Exception Support) 当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常 OSXSAVE(XSAVE and Extended States) 设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。 调试寄存器（Debug Register）（8个）：DR0-DR7 ​ 调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。 ​ DR0-DR3：保留32位断点的线性地址。 ​ DR4-DR5：保留。 ​ DR6： 标志 描述 B0-B3 断点状态的监测 BD 调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器 BS 单步执行标志位 BT 任务转换标志位 ​ DR7： 标志 描述 L0-L3 局部断点使能标志位 G0-G3 全局断点使能标志位 LE GE 置位，表明处理器可以监测导致数据断点的指令。推荐置位为1 GD 通用监测使能标志位。表明是否开启调试寄存器保护 LEN0 - LEN3 用来表明相应断点地址寄存器内存位置的大小 R/W0 - R/W3 相应断点的状态 系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。 IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。 LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。 TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。 16位段寄存器（6个）：CS、DS、ES、FS、GS、SS 段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。 在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。 其他寄存器：EIP、TSC等 指令指针指示器–EIP 32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。 时间戳寄存器–TSC 每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。 浮点寄存器 由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。 主要技术重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。 乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。 特点寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点： 寄存器位于CPU内部，数量很少，仅十四个 寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit） 每个内部寄存器都有一个名字，而没有类似存储器的地址编号 参考资料80X86寄存器详解 寄存器（百度百科） Intel X86 CPU系列的寄存器 CR0-4寄存器介绍]]></content>
      <categories>
        <category>寄存器</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intel CPU 发展简史]]></title>
    <url>%2F2017%2F09%2F09%2FIntel-CPU-%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[1971年11月15日：40041971年11月15日，Intel公司的工程师霍夫发明了世界上第一个商用微处理器—4004。这款4位微处理器集成了2250个晶体管，晶体管之间的距离是10微米，能够处理4bit的数据，每秒运算6万次，频率为108KHz，前端总线为0.74MHz （4bit）。原为日本Busicom公司的计数器开发。 编号为4004，第一个“4”代表此芯片是客户订购的产品编号，后一个“4”代表此芯片是英特尔公司制作的第四个订制芯片，之前还有4001（动态内存DRAM）、4002（只读存储器ROM）、4003（Register），这种数字代号却延用至今。采用4004芯片后，再配用一块程序存储器，数据存储器，移位寄存器，再加上键盘和数码管，就构成了一台完整的微型计算机。 4004的最高频率有740kHz，能执行4位运算，支持8位指令集及12位地址集。 4004只能称为世界上第一款商用处理器，而不是世界上第一款微处理器。第一款微处理器应该是美国军方研制，用于F-14雄猫战机中由6颗晶片组成的中央空气数据计算机：CADC（CenterAir Data Computer），虽然它的构造比4004还要简单，速度只有9.15KHz。 1972年：80088008频率为200KHz，晶体管的总数已经达到了3500个，能处理8比特的数据，性能是4004的两倍，速度为200KHz。更为重要的是，英特尔还首次获得了处理器的指令技术。 8008芯片原本是为德克萨斯州的Datapoint公司设计的，但是这家公司最终却没有足够的财力支付这笔费用。于是双方达成协议，英特尔拥有这款芯片所有的知识产权，而且还获得了由Datapoint公司开发的指令集。这套指令集奠定了今天英特尔公司X86系列微处理器指令集的基础。 执行8位运算，支持16位地址总线和16位数据总线。 1974年：8080在微处理器发展初期，具有革新意义的芯片非Intel8080莫属了。由于采用了复杂的指令集以及40管脚封装，8080的处理能力大为提高，其功能是8008的10倍，每秒能执行29万条指令，集成晶体管数目6000，运行速度2MHz。 与此同时，微处理器的优势已经被业内人士所认同，于是更多的公司开始接入这一领域，竞争开始变得日益激烈。当时与英特尔同台竞技的有RCA(美国无线电公司)、Honeywell、Fairchild、美国国家半导体公司、AMD、摩托罗拉以及Zilog公司。值得一提的是Zilog，世界上第一块4004芯片的设计者Faggin就加盟了该公司。由该公司推出的Z80微处理器比Intel8080功能更为强大，而且直到今天这款处理器仍然被尊为经典。 8080有幸成为了第一款个人计算机Altair的大脑。 8位元处理器，拥有16位地址总线和8位数据总线，包含7个八位寄存器，支持16位寻址，同时也包含一些输入输出端口，有效解决了外部设备在内存寻址能力不足的问题。 1978年：8086-80881978年，英特尔推出了首枚16位微处理器8086，同时生产出与之配合的数学协处理器8087，这两种芯片使用相同的指令集，以后英特尔生产的处理器，均对其兼容。趁着市场销售正好的时机，以及市场需求的提升，Intel在同一年推出了性能更出色的8088处理器。三款处理器都拥有29000只晶体管，速度可分为5MHz、8MHz、10MHz，内部数据总线(处理器内部传输数据的总线)、外部数据总线(处理器外部传输数据的总线)均为16位，地址总线为20位，可寻址1MB内存。首次在商业市场给消费者提供了更自由选择。 1982年：8028680286(也称286)是处理器进入全新技术的标准产品，具备16位字长，集成了14.3万只晶体管，具有6MHz、8MHz、10MHz、12.5MHz四个主频的产品。286是Intel第一款具有完全兼容性的处理器，即可以运行所有针对其前代处理器编写的软件，这一软件兼容性也成为了Intel处理器家族一个恒久不变的特点。286是英特尔的最后一块16位处理器 最大主频为20MHz，采用16位数据总线和24位地址总线。 80286有两种工作模式：实模式和保护模式。在实模式下，80286直接访问内存的空间被限制在1M字节，更多内存需要通过EMS或XMS内存机制进行映射。而在保护模式下，80286可以直接访问16M字节的内存，并具有异常处理机制。 1985年：80386英特尔第一款32位处理器，集成了27万5千只晶体管，超过了4004芯片的一百倍，每秒可以处理500万条指令。同时也是第一款具有“多任务”功能的处理器，所谓“多任务”就是说它可以同时处理多个程序程序的指令，这对微软的操作系统发展有着重要的影响。 重要特点： 首次在x86处理器中实现了32位系统， 可配合使用80387数字辅助处理器增强浮点运算能力 首次采用高速缓存（外置）解决内存速度瓶颈问题。 由于这些设计，80386的运算速度达到了前代产品80286的数倍。80386DX的内部和外部数据总线（或资料汇流排）是32位，地址总线（或位址汇流排）也是32位，可以定址到4GB内存，并可以管理64TB的虚拟存储空间（虚拟存储空间：通过硬件和软件的综合来扩大用户可存储空间，它在内存储器和外存储器（磁盘、光盘）之间增加一定的硬件和软件支持，使两者形成一个有机整体，支持运行比实际配置的内存容量大的多的大任务程序）。 80386有三种工作模式：实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M字节（也叫做位元组）；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。 Intel RapidCAD 被遗忘的微处理器RapidCAD是英特尔有史以来第一款为旧款个人计算机所提供的升级套件(也就是OverDrive的始祖)。原386的使用者不需要更换主机板，只要把RapidCAD买回来将主机板上旧有的中央处理器芯片(CPU)替换掉，就可以享受接近486的运算能力。RapidCAD其实就是把486 DX芯片去掉内部高速缓存然后装入386的封装里面，RapidCAD也不支持486增加的新指令。不过由于386封装的频宽限制，RapidCAD对整体的效能提升比不上直接升级到486 DX。相同频率下，486 DX可以有比386/387快上两倍的速度，而RapidCAD在整数运算方面最多只能提升35%，在浮点运算方面，则可以提升将近70%。 Intel RapidCAD特殊的地方在于，它是由两颗芯片组成，缺一不可。这归咎于486 DX内建浮点运算器(FPU)，而386则是将浮点运算器分开(就是387)。由于RapidCAD-1本身就含有浮点运算器(因为它就是486 DX阉割版)，根本不需要387，所以RapidCAD-2就是用来替代原来主机板上的387芯片。RapidCAD-1负责所有的运算，而RapidCAD-2则是负责模拟浮点运算器，以防止旧有主机板以为没有安装浮点运算功能(尤其在执行286/287的程序时)。市面上有时候把RapidCAD-1与RapidCAD-2分开卖，这就是不了解RapidCAD运作方式的结果。 1989年：8048680486处理器集成了125万个晶体管，时钟频率由25MHz逐步提升到33MHz、40MHz、50MHz及后来的100MHz。486家族的指令集与386非常相似，只有增加少量的指令。 486处理器的应用意味着用户从此摆脱了命令形式的计算机，进入“选中并点击(point-and-click)”的计算时代。英特尔486处理器首次采用内建的数学协处理器，将负载的数学运算功能从中央处理器中分离出来，从而显著加快了计算速度。 386和486推向市场后，均大获成功，英特尔在芯片领域的霸主地位日益凸现。此后，英特尔开始告别微处理器数字编号时代，进入到了Pentium时代。 1994年3月10日：Intel Pentium中央处理器芯片1993年，英特尔发布了Pentium(俗称586)中央处理器芯片(CPU)。本来按照惯常的命名规律是80586，但是在486发展末期，就已经有公司将486等级的产品标识成586来销售了。因此英特尔决定使用自创的品牌来作为新产品的商标—Pentium。 英特尔奔腾处理器采用了0.60微米工艺技术制造，核心由320万个晶体管组成。支持计算机更轻松的集成“现实世界”数据，如语音、声音、手写体和图片等。 Pentium是x86系列一大革新。其中晶体管数大幅提高、增强了浮点运算功能、并把十年未变的工作电压降至3.3V。Pentium刚推出的时候拥有浮点数除法不正确的错误(FDIV Bug)，导致英特尔大量回收第一代产品(1994年12月之前的产品)，所以有FDIV Bug的微处理器所剩不多。Pentium 50MHz也有这个FDIV错误，不过A80501-50只是业界样本，从来没有在市场上出现过。 1995年3月27日，英特尔发布Pentium 120MHz处理器，采用了0.60微米/0.35两种工艺技术，不过核心依旧由320万个晶体管组成。 1995年6月，英特尔发布Pentium 133MHz处理器，采用0.35工艺技术制造,核心提升到由330万个晶体管组成。 1995年11月1日，英特尔发布Pentium 150MHz、Pentium 166MHz、Pentium 180MHz、Pentium 200MHz四款处理器，并且采用了0.60微米/0.35两种工艺技术,核心提升到由550万个晶体管组成。此时INTEL在以前设计基础上增加了L2 cache为256K和512K两种版本。 1996年1月4日，英特尔又发布Pentium 150MHz、Pentium 166MHz两款处理器，采用了0.35微米工艺技术,不过核心由330万个晶体管组成。 1996年6月10日，英特尔发布Pentium 200MHz处理器，采用了0.35微米工艺技术，不过核心还是由330万个晶体管组成。 1996年：Intel Pentium ProPentimuPro的内部含有高达550万个的晶体管，内部时钟频率为133MHz，处理速度几乎是100MHz的Pentium的2倍。PentimuPro的一级(片内)缓存为8KB指令和8KB数据。值得注意的是在PentimuPro的一个封装中除PentimuPro芯片外还包括有一个256KB的二级缓存芯片，两个芯片之间用高频宽的内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。PentiumPro 200MHz CPU的L2 Cache就是运行在200MHz，也就是工作在与处理器相同的频率上。这样的设计领PentiumPro达到了最高的性能。而PentimuPro最引人注目的地方是它具有一项称为“动态执行”的创新技术，这是继Pentium在超标量体系结构上实现实破之后的又一次飞跃。PentimuPro系列的工作频率是150/166/180/200，一级缓存都是16KB，而前三者都有256KB的二级缓存，至于频率为200的CPU还分为三种版本，不同就在于他们的内置的缓存分别是256KB，512KB，1MB。 1997年1月：Intel Pentium MMXPentium MMX芯片在X86指令集的基础上加入了57条多媒体指令。这些指令专门用来处理视频、音频和图象数据，使CPU在多媒体操作上具有更强大的处理能力，Pentium MMX还使用了许多新技术。单指令多数据流SIMD技术能够用一个指令并行处理多个数据，缩短了CPU在处理视频、音频、图形和动画时用于运算的时间；流水线从5级增加到6级，一级高速缓存扩充为16K，一个用于数据高速缓存，另一个用于指令高速缓存，因而速度大大加快；Pentium MMX还吸收了其他CPU的优秀处理技术，如分支预测技术和返回堆栈技术。 Pentium MMX等于是Pentium的加强版中央处理器芯片(CPU)，除了增加67个MMX(Multi-Media eXtension)指令以及64位数据型态之外之外，也将内建指令及数据暂存(Cache)从之前的8KB增加到16KB，内部工作电压降到2.8V。而英特尔之后的桌上型中央处理器皆包含了MMX指令。 1997年：Intel Pentium OverdriveIntel Pentium OverDrive中央处理器芯片(CPU)，又是一项英特尔造福旧计算机使用者的升级选择。Pentium OverDrive有两种，一种(不含MMX，5V)是给80486升级用的，另一种(含MMX，3.3V)是给Pentium早期产品(Socket6, 50-66MHz)升级的。他们都有含散热器及风扇。 1997-1998年：Pentium II1997年5月7日，英特尔发布Pentium II 233MHz、Pentium II 266MHz、Pentium II 300MHz三款PII处理器，采用了0.35微米工艺技术，核心提升到750万个晶体管组成。采用SLOT1架构，通过单边插接卡(SEC)与主板相连，SEC卡盒将CPU内核和二级高速缓存封装在一起，二级高速缓存的工作速度是处理器内核工作速度的一半；处理器采用了与Pentium PRO相同的动态执行技术，可以加速软件的执行；通过双重独立总线与系统总线相连，可进行多重数据交换，提高系统性能；PentiumII也包含MMX指令集。Intel此举希望用SLOT1构架的专利将AMD等一棍打死，可没想到Socket 7平台在以AMD的K6-2为首的处理器的支持下，走入了另一个春天。而从此开始，Intel也开始走上了一条前途不明的道路，开始频繁的强行制定自己的标准，企图借此达到迅速挤垮竞争对手的目的，但市场与用户的需要使得Intel开始不断的陷入被动和不利的局面。 在这个时期100MHz频率的SDR内存已经出现在市场上，但是Intel却惊人地宣布他们将放弃并行内存而主推一种名为Rambus的内存，而一时间众多大公司如西门子、HP和DELL等都投入了Rambus的门下，不过后来DDR内存的流行也证明了Intel的失败。 1997年6月2日，英特尔发布MMX指令技术的Pentium II 233MHz处理器，采用了0.35微米工艺技术,核心由450万个晶体管组成。 1997年8月18日，英特尔发布L2 cache为1M的Pentium II 200MHz处理器，采用了0.35微米工艺技术,核心由550万个晶体管组成。 1998年1月26日，英特尔发布Pentium II 333MHz处理器，采用了0.35微米工艺技术，核心由750万个晶体管组成。 1998年4月15日，英特尔发布Pentium II 350MHz、Pentium II 400MHz和第一款Celeron 266MHz处理器，此三款CPU都采用了最新0.25微米工艺技术,核心由750万个晶体管组成。 1998年8月24日，英特尔发布Pentium II 450MHz处理器，采用了0.25微米工艺技术,核心由750万个晶体管组成。 CPU发展到这个时期，就不能不说说Intel Pentium II Cerelon处理器。英特尔将Celeron处理器的L2 Cache设定为只有Pentium II的一半(也就是128KB)，这样既有合理的效能，又有相对低廉的售价(有A字尾的)；这样的策略一直延续到今天。不过很快有人发现，使用双Celeron的系统与双Pentium II的系统差距不大，而价格却便宜很多，结果造成了Celeron冲击高阶市场的局面。后来英特尔决定取消Celeron处理器的SMP功能，才解决了这个问题。 Pentium II Celeron处理器Celeron（赛扬）300A，是一个让多少人闻之动容的产品，又陪伴了多少曾经年少的读者度过悠长的学生时代。赛扬300A，从某种意义上已经是Intel的第二代赛扬处理器。第一代的赛扬处理器仅仅拥有266MHz、300MHz两种版本，第一代的Celeron处理器由于不拥有任何的二级缓存，虽然有效的降低了成本，但是性能也无法让人满意。为了弥补性能上的不足，Intel终于首次推出带有二级缓存的赛扬处理器——采用Mendocino核心的Celeron300A、333、366。经典，从此诞生。 1999年：Intel Pentium III1999年2月26日，英特尔发布Pentium III 450MHz、Pentium III 500MHz处理器，同时采用了0.25微米工艺技术,核心由950万个晶体管组成，从此Intel开始踏上了PIII旅程。 Pentium III是给桌上型计算机的中央处理器芯片(CPU)，等于是Pentium II的加强版，新增七十条新指令(SIMD，SSE)。Pentium III与Pentium II一样有Mobile、Xeon以及Cerelon等不同的版本。Celeron系列与Pentium III最大的差距在于二级缓存，100MHz外频的Tualatin Celeron 1GHz可以轻松地跃上133MHz外频。更为重要的是，Tualatin Celeron还有很好的向下兼容性，甚至440BX主板在使用转接卡之后也有望采用该CPU，因此也成为很多升级用户的首选。 特别指出的是，Pentium III光是桌上型就拥有Katmai Slot 1 、Coppermine Slot 1以及Coppermine Socket 370等三种不同的系列。到后期，英特尔放弃插卡式界面而又回归到插槽界面(Socket 370)。socket370封装开始推出的时候，有一部分消费者舍弃了slot1平台而选择了新的处理器。新的PGA封装分为PPGA和FC-PGA两种，前者较为廉价，因而被赛扬处理器所采用，而更为昂贵的后者则被奔腾III处理器所采用。例外的是：采用Mendocino核心的赛扬处理器同时有这两种不同封装的版本。采用PPGA封装的赛扬处理器可以通过转接卡在slot1主板上使用，而采用FC-PGA封装的奔三处理器则无能为力了。 2000年：Intel Pentium IVPentium 4处理器集成了4200万个晶体管，到了改进版的Pentium 4(Northwood)更是集成了5千5百万个晶体管；并且开始采用0.18微米进行制造，初始速度就达到了1.5GHz。 Pentium 4还提供的SSE2指令集，这套指令集增加144个全新的指令，在128bit压缩的数据，在SSE时，仅能以4个单精度浮点值的形式来处理，而在SSE2指令集，该资料能采用多种数据结构来处理： 4个单精度浮点数(SSE)对应2个双精度浮点数(SSE2)，对应16字节数(SSE2)，对应8个字数(word)，对应4个双字数(SSE2)，对应2个四字数(SSE2)，对应1个128位长的整数(SSE2) 。 2002-2004年：超线程P4处理器2002年11月14日，英特尔在全新英特尔奔腾4处理器3.06GHz上推出其创新超线程(Hyper-Threading，HT)技术。超线程(HT)技术支持全新级别的高性能台式机，同时快速运行多个计算应用，或为采用多线程的单独软件程序提供更多性能。超线程(HT)技术可将电脑性能提升达25%。除了为台式机用户引入超线程(HT)技术外，英特尔在推出英特尔奔腾4处理器3.06GHZ时达到了一个电脑里程碑。这是第一款商用微处理器，运行速率为每秒30亿周期，并且采用当时业界最先进的0.13微米制程制作。 P4处理器3.06GHz2003年，英特尔发布前端总线为533MHz的Pentium 4 3.06GHz处理器，采用了0.13微米工艺技术,提供512K的二级缓存，核心由5500万个晶体管组成。 P4处理器至尊版3.20GHz2004年初发布，该处理器可兼容现有的英特尔865和英特尔875芯片组家族产品以及标准系统内存。2MB三级高速缓存可以预先加载图形帧缓冲区或视频帧，以满足处理器随后的要求，使在访问内存和I/O设备时实现更高的吞吐率和更快的帧带率。最终，这可带来更逼真的游戏效果和改进的视频编辑性能。增强的CPU性能还可支持软件厂商创建完善的软件物理引擎，从而带来栩栩如生的人物动作和人工智能，使电脑控制的人物更加形象、逼真。 半年之后，2004年6月，英特尔发布了P4 3.4GHz处理器，该处理器支持超线程(HT)技术，采用0.13微米制程，具备512KB二级高速缓存、2MB三级高速缓存和800MHz系统前端总线速度。 Northwood是第二代产品，采用0.13微米制程，具有电压低、体积小、温度低的优点。接着就是Prescott(0.09微米)，虽然这技术很新，不过由于效能提升并不明显，而且有过热的问题。后来英特尔又推出Hyper Threading技术，大大增加工作效率，让P4又成为市场宠儿。英特尔之后又推出Extreme Edition、含有Prestonia(原本给服务器用的Xeon核心)以及Gallatin(0.13微米Northwood外频提升改良版)核心的CPU。现在市场上的高阶Pentium 4则是Socket LGA 775的Prescott为主。 2005-2006年：双核处理器2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了。双核和多核处理器设计用于在一枚处理器中集成两个或多个完整执行内核，以支持同时管理多项活动。英特尔超线程(HT)技术能够使一个执行内核发挥两枚逻辑处理器的作用，因此与该技术结合使用时，英特尔奔腾处理器至尊版840能够充分利用以前可能被闲置的资源，同时处理四个软件线程。 英特尔奔腾D处理器5月，带有两个处理内核的英特尔奔腾D处理器随英特尔945高速芯片组家族一同推出，可带来某些消费电子产品的特性，例如：环绕立体声音频、高清晰度视频和增强图形功能。2006年1月，英特尔发布了Pentium D 9xx系列处理器，包括了支持VT虚拟化技术的Pentium D 960(3.60GHz)、950(3.40GHz)和不支持VT的Pentium D 945(3.4 GHz)、925(3GHz)(注：925不支持VT虚拟化技术)和915(2.80GHz)。 英特尔酷睿2双核处理器2006年7月，英特尔公司面向家用和商用个人电脑与笔记本电脑，发布了十款全新英特尔酷睿2双核处理器和英特尔酷睿至尊处理器。英特尔酷睿2双核处理器家族包括五款专门针对企业、家庭、工作站和玩家(如高端游戏玩家)而定制的台式机处理器，以及五款专门针对移动生活而定制的处理器。英特尔酷睿2双核处理器设计用于提供出色的能效表现，并更快速地运行多种复杂应用，支持用户改进各种任务的处理，例如：更流畅地观看和播放高清晰度视频；在电子商务交易过程中更好地保护电脑及其资产；以及提供更耐久的电池使用时间和更加纤巧时尚的笔记本电脑外形。 全新处理器可实现高达40%的性能提升，其能效比最出色的英特尔奔腾处理器高出40%。英特尔酷睿2双核处理器包含2.91亿个晶体管。不过，Pentium D谈不上是一套完美的双核架构，Intel只是将两个完全独立的CPU核心做在同一枚芯片上，通过同一条前端总线与芯片组相连。两个核心缺乏必要的协同和资源共享能力，而且还必须频繁地对二级缓存作同步化刷新动作，以避免两个核心的工作步调出问题。从这个意义上说，Pentium D带来的进步并没有人们预想得那么大！ 2011年：重新确定处理器产品架构2011年3月，使用32nm工艺全新桌面级和移动端处理器采用了i3、i5和i7的产品分级架构。其中i3主攻低端市场，采用双核处理器架构，约2MB二级缓存；i5处理器主攻主流市场，采用四核处理器架构，4MB二级缓存；i7主攻高端市场，采用四核八线程或六核十二线程架构，二级缓存不少于8MB。 2012年：发布22纳米工艺和第三代处理器使用22nm工艺的处理器热功耗普遍小于77W，使得处理器的散热需求大幅下降，提升了大规模数据运算的可靠性，并降低了散热功耗。 2014年：首发桌面级8核心16线程处理器2014年9月上市的i7-5960X处理器是第一款基于22nm工艺的八核心桌面级处理器，拥有高达20MB的三级缓存，主频达到3.5GHz，热功耗140W。此处理器的处理能力可谓超群，浮点数计算能力是普通办公电脑的10倍以上。随着这一“怪兽”处理器的问世，Intel公司在处理器领域与AMD的差距越拉越大，已经完全形成了一家独大的局面。 寻址空间发展表摘自 寻访x86处理器“实模式”和“保护模式”的前世今生 参考资料：Intel CPU发展简史 百度百科资料]]></content>
      <categories>
        <category>CPU发展史</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>处理器</tag>
      </tags>
  </entry>
</search>
