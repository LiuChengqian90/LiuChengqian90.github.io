{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/light.jpg","path":"images/light.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1504883354968},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1504883354968},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1504883354970},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1504883354970},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1504883354970},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1504883354970},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1504883354970},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1504883354970},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1504883354970},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1504883354970},{"_id":"themes/next/README.cn.md","hash":"6d9177e7dad87e6129760e4b559bd3f7a15429d7","modified":1504883354970},{"_id":"themes/next/README.md","hash":"950ca6e9c0fa607d290a5b1fd883df44725b36b2","modified":1504883354970},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1504883354970},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1504883354970},{"_id":"themes/next/_config.yml","hash":"435a0d1a6bb80bd922e0debe7114728cff6f43f7","modified":1505203924598},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1504883354974},{"_id":"source/_posts/CPU-寄存器.md","hash":"60f61d26ccd8b9f07d4baa697c050fd799c475cd","modified":1505645703860},{"_id":"source/_posts/Intel-CPU-发展简史.md","hash":"b7dc95200deb3794dcd0ec88aeb594cb68d93884","modified":1504890002425},{"_id":"source/_posts/Linux-内存寻址.md","hash":"4e4951fe909ec5bb383a61e67de62be12628974c","modified":1505273008923},{"_id":"source/_posts/hello-world.md","hash":"554ca6f4b51e637f37787ddd5d83dacc626845c9","modified":1505411869848},{"_id":"source/_posts/处理器发展的两种处理模式：实模式和保护模式.md","hash":"882a8db5002ffc5c6f40c4373c0cc3ddd8e5fce8","modified":1505113552889},{"_id":"source/about/index.md","hash":"5ac5eff5ab11e6754a03eb9057ba86ae2e05bb2b","modified":1504888178257},{"_id":"source/categories/index.md","hash":"202848660a70b8e35ce911f3ac5fc802d07341cd","modified":1504882510862},{"_id":"source/tags/index.md","hash":"7b12a68c49ca3d9753e853812412d9ca11640e5e","modified":1504882516919},{"_id":"themes/next/.git.bak/COMMIT_EDITMSG","hash":"c48838f57062f7ebb90d55dcac11a34fa151c22e","modified":1504891664863},{"_id":"themes/next/.git.bak/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1504883354964},{"_id":"themes/next/.git.bak/config","hash":"4cc09e327e294413168ad70b0980f576fde15eb8","modified":1505409414487},{"_id":"themes/next/.git.bak/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1504883120759},{"_id":"themes/next/.git.bak/index","hash":"784426c2884a2a55c1d43d588c4214f3bcd11b07","modified":1505409420684},{"_id":"themes/next/.git.bak/packed-refs","hash":"3c9ff1ffa4ad25866b65e4ca81d20858785b72de","modified":1504883354963},{"_id":"themes/next/.git.bak/tortoisegit.index","hash":"e3ddda8e504eff7011a4d302b0b09f4523c7e05c","modified":1505409388984},{"_id":"themes/next/.git.bak/tortoisegit.data","hash":"ff4233f416fa5aac2b153170ba18fc5eb7796c50","modified":1505409388982},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1504883354970},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"213d0f6c9c7ed9b035d84486b540a57e24869909","modified":1504883354970},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"5d34ae00d5478526664969d0f1fd2cd5d5556e64","modified":1504883354970},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1504883354970},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1504883354970},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1504883354970},{"_id":"themes/next/languages/en.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1504883354970},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1504883354970},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1504883354970},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1504883354970},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1504883354970},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1504883354970},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1504883354970},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1504883354970},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b342544b715da19d982349017bd56c5aaca11f71","modified":1504883635932},{"_id":"themes/next/languages/zh-hk.yml","hash":"2ef272bcb1f325480f59f1e2ab95584de3c6b8da","modified":1504883354970},{"_id":"themes/next/languages/zh-tw.yml","hash":"c53941a2eaac8e3a2f8dacc73ed555d3c6c5bd59","modified":1504883354970},{"_id":"themes/next/layout/_layout.swig","hash":"ada7ffc71cf05e7236a19e0648bce6d6d6cbc7dc","modified":1504883354970},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1504883354974},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1504883354974},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1504883354974},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1504883354974},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1504883354974},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1504883354974},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1504883354974},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1504883354974},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1504883354974},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1504883354994},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1504883354994},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1504883355006},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"source/images/light.jpg","hash":"f45aff349f783e941285f17137b20d0dc2f31610","modified":1504861112253},{"_id":"themes/next/.git.bak/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/pre-commit.sample","hash":"e6c9fe47f7506171be08ed90baaf91d49bc7fe0c","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/pre-push.sample","hash":"503c3d2cd9066c2329ae84309c03a4c274f6d90e","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1504883120760},{"_id":"themes/next/.git.bak/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1504883120760},{"_id":"themes/next/.git.bak/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1504883120760},{"_id":"themes/next/.git.bak/logs/HEAD","hash":"09f5b6ab8664b998d479a3e9e903ed54d6c08109","modified":1504891665006},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1504883354970},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1504883354970},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1504883354970},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1504883354970},{"_id":"themes/next/layout/_macro/post.swig","hash":"767e1d5503ecce85f577c8fb673a3503b65484ce","modified":1504883354970},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1504883354970},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"3e01900762d889a04379abba37b419972e366698","modified":1504883354970},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1504883354970},{"_id":"themes/next/layout/_partials/comments.swig","hash":"010ef8c42d2e1a95abc60caf757293ca8eb4a68b","modified":1504883354970},{"_id":"themes/next/layout/_partials/footer.swig","hash":"fb02c81273d5897ebb98b50f4c10f7edc34f9240","modified":1505196176243},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1504883354970},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1504883354970},{"_id":"themes/next/layout/_partials/head.swig","hash":"365b81a7059355bfb17a4c67872c73a6eb54101c","modified":1505198323800},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1504883354970},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1504883354970},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1504883354970},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1504883354970},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1504883354974},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1504883354974},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1504883354974},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1504883354974},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1504883354974},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1504883354974},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1504883354974},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1504883354974},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1504883354974},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1504883354974},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1504883354974},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1504883354974},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1504883354974},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1504883354974},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1504883354974},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1504883354974},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1504883354974},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1504883354974},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1504883354974},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1504883354974},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1504883354974},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1504883354974},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1504883354974},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1504883354974},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1504883354974},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1504883354974},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1504883354974},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1504883354974},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1504883354974},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1504883354974},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1504883354974},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354970},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354970},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504883354974},{"_id":"themes/next/.git.bak/objects/5d/801916b1bdef83de0bf8d7f9f40444c73fcf57","hash":"b551c9e76b3d4af57a6be06420ef94c1cd1a5e86","modified":1504891663993},{"_id":"themes/next/.git.bak/objects/e2/f1a66d3fa68494bc71278b98990ddf85522061","hash":"6ec255a4d1c7207a00ad88b751c5e11d7a40048e","modified":1504891664779},{"_id":"themes/next/.git.bak/objects/ed/6890406f4daa3475ce6bb04f00bdf1719d7d76","hash":"8fce1e027fe619e95d3771188c2098b39889de7d","modified":1504891664918},{"_id":"themes/next/.git.bak/refs/heads/master","hash":"f40ca1f51b6a80ecfb0b1d4a410b57e3a191aa94","modified":1504891664990},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1504883354970},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1504883354970},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1504883354970},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1504883354970},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1504883354970},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1504883354970},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1504883354970},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1504883354970},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1504883354970},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1504883354970},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1504883354970},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1504883354970},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1504883354974},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"576e716893153a855eaf6d136fad7cb6d4065e09","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"9f4ed36c73e890909b8ebbe601fb60e13d048288","modified":1504883354974},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1504883354974},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1504883354974},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1504883354974},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1504883354974},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1505202156532},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1504883354974},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1504883354974},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1504883354974},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1504883354974},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"6359c84aaa02c90be60b22abe638b737ddd69c9c","modified":1504883354974},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1504883354974},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1504883354974},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1504883354974},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1504883354974},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1504883354974},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1504883354974},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1504883354974},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1504883354974},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1504883354974},{"_id":"themes/next/source/js/src/motion.js","hash":"da146caf488078a634d961debf2a71ce4106018c","modified":1504883354974},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1504883354974},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1504883354974},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1504883354974},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1504883354974},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1504883354974},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1504883354986},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1504883354986},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1504883354989},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1504883354989},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1504883354989},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1504883354989},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1504883354994},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1504883354994},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1504883354994},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1504883354994},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1504883354994},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1504883354994},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1504883354994},{"_id":"themes/next/.git.bak/logs/refs/heads/master","hash":"09f5b6ab8664b998d479a3e9e903ed54d6c08109","modified":1504891665027},{"_id":"themes/next/.git.bak/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1504883354964},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1504883354974},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1504883354974},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"f2030fa436c47791d1a42358cc0ef6f9809f212c","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1504883354974},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"0af5a9322156c4c21d3c7d38f5ee48de5286f523","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"264a52c0a7877381f9a6a87d495757a0ba7e29d6","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1504883354974},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1504883354974},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1504883354989},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1504883354989},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1504883354989},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1504883354989},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1504883354994},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1504883354994},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1504883354974},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1504883354994},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1504883354994},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1504883354994},{"_id":"themes/next/.git.bak/logs/refs/remotes/origin/HEAD","hash":"6cf909cdb606e248933953565de4b60c381692c2","modified":1504883354964},{"_id":"themes/next/.git.bak/objects/pack/pack-b8e2c171f3d851a0a81290f6f99096530d57966c.idx","hash":"7455e4bd12e6c39dfa6261f9d7120aaf24cb5767","modified":1504883354922},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"67c357ddc16b31e7dfd8f956a77f984662c06fc2","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1504883354974},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1504883354974},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1504883354974},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1504883354974},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1504883354986},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1504883354986},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1504883354989},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1504883354994},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1504883354994},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1504883354986},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1504883354994},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1504883354994},{"_id":"themes/next/.git.bak/objects/pack/pack-b8e2c171f3d851a0a81290f6f99096530d57966c.pack","hash":"d2b3a60454a24ac33ca48f6e9151341f3775825c","modified":1504891696000},{"_id":"public/baidusitemap.xml","hash":"525915a558bd0a8e1d04213f836c1fadb69889ab","modified":1505645758107},{"_id":"public/content.json","hash":"5d0c4d46e13467de88dc29c77fc01d2ae31b3ac4","modified":1505645758153},{"_id":"public/search.xml","hash":"0689bf19568ed054e663fd04a3b92955972aad34","modified":1505645758154},{"_id":"public/sitemap.xml","hash":"1dc60e6d75af55c4164082fa046a6fa0db9ca59c","modified":1505645758154},{"_id":"public/about/index.html","hash":"25132655fb327639d371dc2c945ab18854e02778","modified":1505645758221},{"_id":"public/categories/index.html","hash":"1c054fda841977deed8ed0377bc4d45e4cca2b14","modified":1505645758221},{"_id":"public/tags/index.html","hash":"d2efde7add080a46ed417ab014b1c2a7c9a06459","modified":1505645758222},{"_id":"public/2017/09/15/hello-world/index.html","hash":"218098bff599599b37ad58c2dc95c00c2779f35d","modified":1505645758223},{"_id":"public/2017/09/09/Linux-内存寻址/index.html","hash":"4958a9deb77fb7170d3f8a0ff3aa7f7418fe3283","modified":1505645758223},{"_id":"public/2017/09/09/处理器发展的两种处理模式：实模式和保护模式/index.html","hash":"a52e198c5754c24a4d7c2ecee05d85cbbf8ec3d6","modified":1505645758223},{"_id":"public/2017/09/09/CPU-寄存器/index.html","hash":"d05755a2d2ab9356da5fa6e61aeb22da60995aef","modified":1505645758223},{"_id":"public/2017/09/09/Intel-CPU-发展简史/index.html","hash":"fdbe1db59a6cd73deee29f920905176c2aaf9143","modified":1505645758223},{"_id":"public/archives/index.html","hash":"bd313c8040462448d8864754bc2d729b2e32dca5","modified":1505645758223},{"_id":"public/archives/2017/index.html","hash":"94507ad90373b0d5802e4bf116e76bd8d91b8988","modified":1505645758224},{"_id":"public/archives/2017/09/index.html","hash":"a965e6e23e0a1f58a20b46b2f6928d7e0bde1531","modified":1505645758224},{"_id":"public/categories/寄存器/index.html","hash":"fea498620af7c4ed244fa62ebda91008a422146b","modified":1505645758224},{"_id":"public/categories/CPU发展史/index.html","hash":"13dcf20786db7ea81c06603a80be5abe46c2717a","modified":1505645758224},{"_id":"public/categories/Linux内核/index.html","hash":"dc0daca3e2642701f7b6929703e2cfaaace2a719","modified":1505645758224},{"_id":"public/categories/Diary/index.html","hash":"d16963c1a05147abe0f6efb154fc05fa13d07975","modified":1505645758225},{"_id":"public/categories/处理器工作方式/index.html","hash":"29f7b683a54aec19ecfcde2ae89e7335cafa4a0a","modified":1505645758225},{"_id":"public/index.html","hash":"9ebbf92cd371705fd52de7e5abd13835d86e8733","modified":1505645758225},{"_id":"public/tags/寄存器/index.html","hash":"bdedecba12ef0305ce8cb0b7d0b3d20fd905e858","modified":1505645758225},{"_id":"public/tags/CPU/index.html","hash":"538a6073b40836b23922ec189ea5ee138286d65a","modified":1505645758225},{"_id":"public/tags/处理器/index.html","hash":"ec48e5e1ed27d6da3e80881a9595746d773160ad","modified":1505645758225},{"_id":"public/tags/内存寻址/index.html","hash":"34b700bd5a0752b299dd561b6386fca76d134887","modified":1505645758225},{"_id":"public/tags/分段/index.html","hash":"2309e65aa2fcbeaa96a20ca97484a2c25d0ee340","modified":1505645758226},{"_id":"public/tags/分页/index.html","hash":"ada9b80d10bbd79c3b1a0bd5a11d2133298bccb0","modified":1505645758226},{"_id":"public/tags/GDT/index.html","hash":"9181ee9ff21ec54b2a4a035d376fd300750fc514","modified":1505645758226},{"_id":"public/tags/LDT/index.html","hash":"64f68e5432f462b6328a88d093fa8090e2d3cc89","modified":1505645758226},{"_id":"public/tags/Testing/index.html","hash":"5ebd86b82e9c4a7ee92a7debc704d86acc8d47a3","modified":1505645758226},{"_id":"public/tags/实模式/index.html","hash":"ffe617cf7479559cc8bc20e7b2f5c0456e347216","modified":1505645758226},{"_id":"public/tags/保护模式/index.html","hash":"92fd798bb35e98e7d3d4d6094b25d3f900d19a06","modified":1505645758226},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1505645758243},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1505645758243},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1505645758243},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1505645758243},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1505645758243},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1505645758244},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1505645758244},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1505645758244},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1505645758244},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505645758244},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505645758244},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1505645758244},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1505645758244},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1505645758244},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1505645758244},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1505645758244},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1505645758244},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1505645758245},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1505645758245},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1505645758245},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1505645758245},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1505645758245},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1505645758245},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1505645758245},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1505645758245},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1505645758245},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1505645758245},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1505645758245},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1505645758246},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1505645759375},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1505645759403},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1505645759429},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1505645759429},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1505645759429},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1505645759430},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1505645759430},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1505645759430},{"_id":"public/js/src/motion.js","hash":"da146caf488078a634d961debf2a71ce4106018c","modified":1505645759430},{"_id":"public/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1505645759430},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1505645759430},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1505645759430},{"_id":"public/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1505645759430},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1505645759431},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1505645759431},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1505645759431},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1505645759431},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1505645759431},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1505645759431},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1505645759431},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1505645759431},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1505645759431},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1505645759431},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1505645759432},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1505645759433},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1505645759433},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1505645759433},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1505645759434},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1505645759434},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1505645759434},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1505645759434},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1505645759434},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1505645759434},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1505645759434},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1505645759435},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1505645759435},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1505645759435},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1505645759435},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1505645759435},{"_id":"public/css/main.css","hash":"48cdf37e8a08143dc4c9fefd76e3e1bebce6089f","modified":1505645759435},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1505645759436},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1505645759436},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1505645759436},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1505645759436},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1505645759436},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1505645759436},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1505645759436},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1505645759436},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1505645759436},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1505645759436},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1505645759436},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1505645759437},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1505645759437},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1505645759437},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1505645759437},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1505645759437},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1505645759437},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1505645759437},{"_id":"public/images/light.jpg","hash":"f45aff349f783e941285f17137b20d0dc2f31610","modified":1505645759437},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1505645759438},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1505645759438},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1505645759439},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1505645759493}],"Category":[{"name":"寄存器","_id":"cj7omlvhz0004ckfyfibshc9u"},{"name":"CPU发展史","_id":"cj7omlvin000ackfy0ajz3qk3"},{"name":"Linux内核","_id":"cj7omlvir000dckfygdiga65d"},{"name":"Diary","_id":"cj7omlviw000jckfy3sr6menp"},{"name":"处理器工作方式","_id":"cj7omlvj0000mckfy5ggr60rn"}],"Data":[],"Page":[{"title":"about","date":"2017-09-08T15:27:39.000Z","_content":"\n**个人简介：**\n\n- Chengqian\n- Linux内核开发人员\n- 北漂一族\n- Email: xieling1990.happy@163.com","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-09-08 23:27:39\n---\n\n**个人简介：**\n\n- Chengqian\n- Linux内核开发人员\n- 北漂一族\n- Email: xieling1990.happy@163.com","updated":"2017-09-08T16:29:38.257Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj7omlvho0001ckfymllbzsyp","content":"<p><strong>个人简介：</strong></p>\n<ul>\n<li>Chengqian</li>\n<li>Linux内核开发人员</li>\n<li>北漂一族</li>\n<li>Email: xieling1990.happy@163.com</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>个人简介：</strong></p>\n<ul>\n<li>Chengqian</li>\n<li>Linux内核开发人员</li>\n<li>北漂一族</li>\n<li>Email: xieling1990.happy@163.com</li>\n</ul>\n"},{"title":"categories","date":"2017-09-08T14:16:48.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-09-08 22:16:48\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-09-08T14:55:10.862Z","path":"categories/index.html","layout":"page","_id":"cj7omlvhv0003ckfysljrbamt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-09-08T10:34:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-09-08 18:34:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-09-08T14:55:16.919Z","path":"tags/index.html","layout":"page","_id":"cj7omlvia0007ckfyaji9p323","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CPU 寄存器","date":"2017-09-08T16:46:05.000Z","_content":"\n　　寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。\n\n　　寄存器是集成电路中非常重要的一种存储单元，通常由[D触发器](https://baike.baidu.com/item/D%E8%A7%A6%E5%8F%91%E5%99%A8)组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。\n\n　　寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。\n\n## 16位寄存器\n\n以8086（16位处理器，14个寄存器）为例。按其用途可分为：\n\n- 通用寄存器（8个）：\n\n  - 数据寄存器\n\n    AH&AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的[I/O指令](https://baike.baidu.com/item/I%252FO%E6%8C%87%E4%BB%A4)都使用这一寄存器与外界设备传送数据。\n\n    BH&BL=BX(base)：基址寄存器，常用于地址索引。\n\n    CH&CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在[移位指令](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4),循环(loop)和串处理指令中用作隐含的计数器。\n\n    DH&DL=DX(data)：数据寄存器，常用于数据传递。\n\n    这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低八位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n  - 指针寄存器和变址寄存器：\n\n    SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。\n\n    这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。\n\n- 指令指针（1个）：\n\n  指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。\n\n  BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。\n\n- 标志寄存器（1个）：\n\n  标志寄存器（Flags Register,FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。\n\n  在FR中有意义的有9位，其中6位是状态位，3位是控制位。\n\n- - ![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904201107116-1774590873.jpg)\n\n| 标志                        | 描述                                       |\n| ------------------------- | ---------------------------------------- |\n| CF(carry flag)            | 进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 |\n| PF(parity flag)           | 奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 |\n| AF(adjust flag)           | 辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。 |\n| ZF(zero flag)             | 零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 |\n| SF(sign flag)             | 符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。 |\n| TF(trap flag)             | 跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。 |\n| IF(interrupt enable flag) | 中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 |\n| DF(direction flag)        | 方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。        |\n| OF(overflow flag)         | 溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 |\n\n- 段寄存器（4个）：\n  - CS（Code Segment）：代码段寄存器\n  - DS（Data Segment）：数据段寄存器 \n  - SS（Stack Segment）：堆栈段寄存器\n  - ES（Extra Segment）：附加段寄存器\n\n当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻　址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。\n\n备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。\n\n## 32位寄存器\n\n32位CPU 寄存器及数据结构图：\n\n![img](http://blog.chinaunix.net/attachment/201310/12/27717694_1381559379uuay.png)\n\n- 通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI\n\n  - 尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。\n  - EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。\n  - EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。\n  - EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。\n\n- 标志寄存器（1个）：EFLAGS\n\n  控制任务状态和模式切换、中断处理、指令追踪和访问权限控制.寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)\n\n  在16位标志寄存器的基础上增加了几个标志：\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202623585-1839788830.jpg)\n\n \n\n| 标志                                  | 描述                                       |\n| ----------------------------------- | ---------------------------------------- |\n| IOPL(I/O privilege level field)     | 指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 |\n| NT(Nested task flag)                | 控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。    |\n| RF(Resume flag)                     | 控制处理器对调试异常的响应。                           |\n| VM(Virtual-8086 mode flag)          | 置1以允许虚拟8086模式，清除则返回保护模式。                 |\n| AC(Alignment check flag)            | 该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 |\n| VIF(Virtual interrupt flag)         | 该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions) |\n| VIP(Virtual interrupt pending flag) | 该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。 |\n| ID(Identification flag)             | 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。          |\n\n \n\n- 控制寄存器（5个）：CR0-CR4\n\n控制寄存器决定处理器的操作模式和当前执行任务的一些特征。\n\n- - CR0：控制系统的工作模式和处理器的状态；x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。\n\n\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202830101-1841642504.jpg)\n\n| 标志                        | 描述                                      |\n| ------------------------- | --------------------------------------- |\n| PE(Protected-Mode Enable) | PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。 |\n| MP                        | 协处理器监视标志位                               |\n| EM                        | 该位表明是否需要仿真协处理器的功能                       |\n| TS                        | 每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位          |\n| ET                        | 扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令     |\n| NE                        | 数字错误标志位(与浮点协处理器共同使用)                    |\n| WP                        | 写保护                                     |\n| AM                        | 对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)           |\n| NW                        | 直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 )  |\n| CD                        | cache 缺失设置位                             |\n| PG(Paging Enable)         | 控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。        |\n\n- - CR1：保留\n  - CR2：存放发生页错误时的虚拟地址\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202839085-1411938709.jpg)\n\n \n\n- - CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202910897-491400201.jpg)\n\n \n\n| 标志                            | 描述                                       |\n| ----------------------------- | ---------------------------------------- |\n| PWT(Page-Level Writethrough)  | 控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效 |\n| PCD(Page-Level Cache Disable) | PCD=1，表示最高目录表不可缓存，PCD=0，相反               |\n\n- Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。\n- Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以  page_directory_table base address为27位，指向32B对齐的页目录指针表。\n\n\n- - CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202916929-782474184.jpg)\n\n \n\n| 标志                                       | 描述                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| VME(virtual 8086 mode extension)         | 虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。 |\n| PVI(protected mode virtual interrupts)   | 保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。 |\n| TSD(time stamp disable)                  | 禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。 |\n| DE(debugging extensions)                 | 调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。    |\n| PSE(page size extensions)                | 允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。 |\n| PAE(physical address extension)          | 允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。 |\n| MCE(machine check exception)             | 允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。 |\n| PGE(Page-Global Enable)                  | 将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。 |\n| PCE(Performance-Monitoring Counter Enable) | 将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。 |\n| OSFXSR(FXSAVE/FXRSTOR Support)           | 设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。 |\n| OSXMMEXCPT(Unmasked Exception Support)   | 当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常 |\n| OSXSAVE(XSAVE and Extended States)       | 设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。 |\n\n- 调试寄存器（8个）：DR0-DR7\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904203616226-760453523.jpg)\n\n \n\n调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。\n\nDR0-DR3：保留32位断点的线性地址。\n\nDR4-DR5：保留。\n\nDR6：\n\n| 标志    | 描述                                      |\n| ----- | --------------------------------------- |\n| B0-B3 | 断点状态的监测                                 |\n| BD    | 调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器 |\n| BS    | 单步执行标志位                                 |\n| BT    | 任务转换标志位                                 |\n\nDR7：\n\n| 标志          | 描述                           |\n| ----------- | ---------------------------- |\n| L0-L3       | 局部断点使能标志位                    |\n| G0-G3       | 全局断点使能标志位                    |\n| LE GE       | 置位，表明处理器可以监测导致数据断点的指令。推荐置位为1 |\n| GD          | 通用监测使能标志位。表明是否开启调试寄存器保护      |\n| LEN0 - LEN3 | 用来表明相应断点地址寄存器内存位置的大小         |\n| R/W0 - R/W3 | 相应断点的状态                      |\n\n- 系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR\n\n  GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。\n\n  IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。\n\n  LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。\n\n  TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。\n\n- 16位段寄存器（6个）：CS、DS、ES、FS、GS、SS\n\n  段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。\n\n  在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。\n\n- 其他寄存器：EIP、TSC等\n\n  - 指令指针指示器--EIP\n\n    32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。\n\n  - 时间戳寄存器--TSC\n\n    每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。\n\n  - 浮点寄存器\n\n    由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。\n\n## 主要技术\n\n重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。\n\n乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。\n\n## 特点\n\n寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：\n\n1. 寄存器位于CPU内部，数量很少，仅十四个\n2. 寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit）\n3. 每个内部寄存器都有一个名字，而没有类似存储器的地址编号\n\n## 参考资料\n\n[80X86寄存器详解](http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html)\n\n[寄存器（百度百科）](https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin)\n\n[Intel X86 CPU系列的寄存器](http://blog.chinaunix.net/uid-27717694-id-3943419.html)\n\n[CR0-4寄存器介绍](http://blog.sina.com.cn/s/blog_85998e38010122wq.html)","source":"_posts/CPU-寄存器.md","raw":"---\ntitle: CPU 寄存器\ndate: 2017-09-09 00:46:05\ncategories: 寄存器\ntags:\n  - 寄存器\n  - CPU\n---\n\n　　寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。\n\n　　寄存器是集成电路中非常重要的一种存储单元，通常由[D触发器](https://baike.baidu.com/item/D%E8%A7%A6%E5%8F%91%E5%99%A8)组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。\n\n　　寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。\n\n## 16位寄存器\n\n以8086（16位处理器，14个寄存器）为例。按其用途可分为：\n\n- 通用寄存器（8个）：\n\n  - 数据寄存器\n\n    AH&AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的[I/O指令](https://baike.baidu.com/item/I%252FO%E6%8C%87%E4%BB%A4)都使用这一寄存器与外界设备传送数据。\n\n    BH&BL=BX(base)：基址寄存器，常用于地址索引。\n\n    CH&CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在[移位指令](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4),循环(loop)和串处理指令中用作隐含的计数器。\n\n    DH&DL=DX(data)：数据寄存器，常用于数据传递。\n\n    这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低八位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。\n\n  - 指针寄存器和变址寄存器：\n\n    SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。\n\n    这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。\n\n- 指令指针（1个）：\n\n  指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。\n\n  BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。\n\n- 标志寄存器（1个）：\n\n  标志寄存器（Flags Register,FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。\n\n  在FR中有意义的有9位，其中6位是状态位，3位是控制位。\n\n- - ![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904201107116-1774590873.jpg)\n\n| 标志                        | 描述                                       |\n| ------------------------- | ---------------------------------------- |\n| CF(carry flag)            | 进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 |\n| PF(parity flag)           | 奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 |\n| AF(adjust flag)           | 辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。 |\n| ZF(zero flag)             | 零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 |\n| SF(sign flag)             | 符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。 |\n| TF(trap flag)             | 跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。 |\n| IF(interrupt enable flag) | 中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 |\n| DF(direction flag)        | 方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。        |\n| OF(overflow flag)         | 溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 |\n\n- 段寄存器（4个）：\n  - CS（Code Segment）：代码段寄存器\n  - DS（Data Segment）：数据段寄存器 \n  - SS（Stack Segment）：堆栈段寄存器\n  - ES（Extra Segment）：附加段寄存器\n\n当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻　址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。\n\n备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。\n\n## 32位寄存器\n\n32位CPU 寄存器及数据结构图：\n\n![img](http://blog.chinaunix.net/attachment/201310/12/27717694_1381559379uuay.png)\n\n- 通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI\n\n  - 尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。\n  - EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。\n  - EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。\n  - EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。\n\n- 标志寄存器（1个）：EFLAGS\n\n  控制任务状态和模式切换、中断处理、指令追踪和访问权限控制.寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)\n\n  在16位标志寄存器的基础上增加了几个标志：\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202623585-1839788830.jpg)\n\n \n\n| 标志                                  | 描述                                       |\n| ----------------------------------- | ---------------------------------------- |\n| IOPL(I/O privilege level field)     | 指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 |\n| NT(Nested task flag)                | 控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。    |\n| RF(Resume flag)                     | 控制处理器对调试异常的响应。                           |\n| VM(Virtual-8086 mode flag)          | 置1以允许虚拟8086模式，清除则返回保护模式。                 |\n| AC(Alignment check flag)            | 该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 |\n| VIF(Virtual interrupt flag)         | 该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions) |\n| VIP(Virtual interrupt pending flag) | 该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。 |\n| ID(Identification flag)             | 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。          |\n\n \n\n- 控制寄存器（5个）：CR0-CR4\n\n控制寄存器决定处理器的操作模式和当前执行任务的一些特征。\n\n- - CR0：控制系统的工作模式和处理器的状态；x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。\n\n\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202830101-1841642504.jpg)\n\n| 标志                        | 描述                                      |\n| ------------------------- | --------------------------------------- |\n| PE(Protected-Mode Enable) | PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。 |\n| MP                        | 协处理器监视标志位                               |\n| EM                        | 该位表明是否需要仿真协处理器的功能                       |\n| TS                        | 每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位          |\n| ET                        | 扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令     |\n| NE                        | 数字错误标志位(与浮点协处理器共同使用)                    |\n| WP                        | 写保护                                     |\n| AM                        | 对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)           |\n| NW                        | 直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 )  |\n| CD                        | cache 缺失设置位                             |\n| PG(Paging Enable)         | 控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。        |\n\n- - CR1：保留\n  - CR2：存放发生页错误时的虚拟地址\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202839085-1411938709.jpg)\n\n \n\n- - CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202910897-491400201.jpg)\n\n \n\n| 标志                            | 描述                                       |\n| ----------------------------- | ---------------------------------------- |\n| PWT(Page-Level Writethrough)  | 控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效 |\n| PCD(Page-Level Cache Disable) | PCD=1，表示最高目录表不可缓存，PCD=0，相反               |\n\n- Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。\n- Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以  page_directory_table base address为27位，指向32B对齐的页目录指针表。\n\n\n- - CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202916929-782474184.jpg)\n\n \n\n| 标志                                       | 描述                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| VME(virtual 8086 mode extension)         | 虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。 |\n| PVI(protected mode virtual interrupts)   | 保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。 |\n| TSD(time stamp disable)                  | 禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。 |\n| DE(debugging extensions)                 | 调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。    |\n| PSE(page size extensions)                | 允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。 |\n| PAE(physical address extension)          | 允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。 |\n| MCE(machine check exception)             | 允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。 |\n| PGE(Page-Global Enable)                  | 将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。 |\n| PCE(Performance-Monitoring Counter Enable) | 将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。 |\n| OSFXSR(FXSAVE/FXRSTOR Support)           | 设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。 |\n| OSXMMEXCPT(Unmasked Exception Support)   | 当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常 |\n| OSXSAVE(XSAVE and Extended States)       | 设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。 |\n\n- 调试寄存器（8个）：DR0-DR7\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904203616226-760453523.jpg)\n\n \n\n调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。\n\nDR0-DR3：保留32位断点的线性地址。\n\nDR4-DR5：保留。\n\nDR6：\n\n| 标志    | 描述                                      |\n| ----- | --------------------------------------- |\n| B0-B3 | 断点状态的监测                                 |\n| BD    | 调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器 |\n| BS    | 单步执行标志位                                 |\n| BT    | 任务转换标志位                                 |\n\nDR7：\n\n| 标志          | 描述                           |\n| ----------- | ---------------------------- |\n| L0-L3       | 局部断点使能标志位                    |\n| G0-G3       | 全局断点使能标志位                    |\n| LE GE       | 置位，表明处理器可以监测导致数据断点的指令。推荐置位为1 |\n| GD          | 通用监测使能标志位。表明是否开启调试寄存器保护      |\n| LEN0 - LEN3 | 用来表明相应断点地址寄存器内存位置的大小         |\n| R/W0 - R/W3 | 相应断点的状态                      |\n\n- 系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR\n\n  GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。\n\n  IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。\n\n  LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。\n\n  TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。\n\n- 16位段寄存器（6个）：CS、DS、ES、FS、GS、SS\n\n  段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。\n\n  在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。\n\n- 其他寄存器：EIP、TSC等\n\n  - 指令指针指示器--EIP\n\n    32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。\n\n  - 时间戳寄存器--TSC\n\n    每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。\n\n  - 浮点寄存器\n\n    由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。\n\n## 主要技术\n\n重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。\n\n乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。\n\n## 特点\n\n寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：\n\n1. 寄存器位于CPU内部，数量很少，仅十四个\n2. 寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit）\n3. 每个内部寄存器都有一个名字，而没有类似存储器的地址编号\n\n## 参考资料\n\n[80X86寄存器详解](http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html)\n\n[寄存器（百度百科）](https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin)\n\n[Intel X86 CPU系列的寄存器](http://blog.chinaunix.net/uid-27717694-id-3943419.html)\n\n[CR0-4寄存器介绍](http://blog.sina.com.cn/s/blog_85998e38010122wq.html)","slug":"CPU-寄存器","published":1,"updated":"2017-09-17T10:55:03.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7omlvhf0000ckfyq6bruvby","content":"<p>　　寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。</p>\n<p>　　寄存器是集成电路中非常重要的一种存储单元，通常由<a href=\"https://baike.baidu.com/item/D%E8%A7%A6%E5%8F%91%E5%99%A8\" target=\"_blank\" rel=\"external\">D触发器</a>组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。</p>\n<p>　　寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。</p>\n<h2 id=\"16位寄存器\"><a href=\"#16位寄存器\" class=\"headerlink\" title=\"16位寄存器\"></a>16位寄存器</h2><p>以8086（16位处理器，14个寄存器）为例。按其用途可分为：</p>\n<ul>\n<li><p>通用寄存器（8个）：</p>\n<ul>\n<li><p>数据寄存器</p>\n<p>AH&amp;AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的<a href=\"https://baike.baidu.com/item/I%252FO%E6%8C%87%E4%BB%A4\" target=\"_blank\" rel=\"external\">I/O指令</a>都使用这一寄存器与外界设备传送数据。</p>\n<p>BH&amp;BL=BX(base)：基址寄存器，常用于地址索引。</p>\n<p>CH&amp;CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在<a href=\"https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4\" target=\"_blank\" rel=\"external\">移位指令</a>,循环(loop)和串处理指令中用作隐含的计数器。</p>\n<p>DH&amp;DL=DX(data)：数据寄存器，常用于数据传递。</p>\n<p>这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低八位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。</p>\n</li>\n<li><p>指针寄存器和变址寄存器：</p>\n<p>SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。</p>\n<p>这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p>\n</li>\n</ul>\n</li>\n<li><p>指令指针（1个）：</p>\n<p>指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。</p>\n<p>BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。</p>\n</li>\n<li><p>标志寄存器（1个）：</p>\n<p>标志寄存器（Flags Register,FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。</p>\n<p>在FR中有意义的有9位，其中6位是状态位，3位是控制位。</p>\n</li>\n<li><ul>\n<li><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904201107116-1774590873.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CF(carry flag)</td>\n<td>进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</td>\n</tr>\n<tr>\n<td>PF(parity flag)</td>\n<td>奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。</td>\n</tr>\n<tr>\n<td>AF(adjust flag)</td>\n<td>辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。</td>\n</tr>\n<tr>\n<td>ZF(zero flag)</td>\n<td>零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</td>\n</tr>\n<tr>\n<td>SF(sign flag)</td>\n<td>符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。</td>\n</tr>\n<tr>\n<td>TF(trap flag)</td>\n<td>跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。</td>\n</tr>\n<tr>\n<td>IF(interrupt enable flag)</td>\n<td>中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。</td>\n</tr>\n<tr>\n<td>DF(direction flag)</td>\n<td>方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。</td>\n</tr>\n<tr>\n<td>OF(overflow flag)</td>\n<td>溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>段寄存器（4个）：<ul>\n<li>CS（Code Segment）：代码段寄存器</li>\n<li>DS（Data Segment）：数据段寄存器 </li>\n<li>SS（Stack Segment）：堆栈段寄存器</li>\n<li>ES（Extra Segment）：附加段寄存器</li>\n</ul>\n</li>\n</ul>\n<p>当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻　址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。</p>\n<p>备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。</p>\n<h2 id=\"32位寄存器\"><a href=\"#32位寄存器\" class=\"headerlink\" title=\"32位寄存器\"></a>32位寄存器</h2><p>32位CPU 寄存器及数据结构图：</p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201310/12/27717694_1381559379uuay.png\" alt=\"img\"></p>\n<ul>\n<li><p>通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</p>\n<ul>\n<li>尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。</li>\n<li>EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。</li>\n<li>EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。</li>\n<li>EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。</li>\n</ul>\n</li>\n<li><p>标志寄存器（1个）：EFLAGS</p>\n<p>控制任务状态和模式切换、中断处理、指令追踪和访问权限控制.寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)</p>\n<p>在16位标志寄存器的基础上增加了几个标志：</p>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202623585-1839788830.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IOPL(I/O privilege level field)</td>\n<td>指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</td>\n</tr>\n<tr>\n<td>NT(Nested task flag)</td>\n<td>控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。</td>\n</tr>\n<tr>\n<td>RF(Resume flag)</td>\n<td>控制处理器对调试异常的响应。</td>\n</tr>\n<tr>\n<td>VM(Virtual-8086 mode flag)</td>\n<td>置1以允许虚拟8086模式，清除则返回保护模式。</td>\n</tr>\n<tr>\n<td>AC(Alignment check flag)</td>\n<td>该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。</td>\n</tr>\n<tr>\n<td>VIF(Virtual interrupt flag)</td>\n<td>该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)</td>\n</tr>\n<tr>\n<td>VIP(Virtual interrupt pending flag)</td>\n<td>该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。</td>\n</tr>\n<tr>\n<td>ID(Identification flag)</td>\n<td>程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>控制寄存器（5个）：CR0-CR4</li>\n</ul>\n<p>控制寄存器决定处理器的操作模式和当前执行任务的一些特征。</p>\n<ul>\n<li><ul>\n<li>CR0：控制系统的工作模式和处理器的状态；x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202830101-1841642504.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PE(Protected-Mode Enable)</td>\n<td>PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。</td>\n</tr>\n<tr>\n<td>MP</td>\n<td>协处理器监视标志位</td>\n</tr>\n<tr>\n<td>EM</td>\n<td>该位表明是否需要仿真协处理器的功能</td>\n</tr>\n<tr>\n<td>TS</td>\n<td>每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位</td>\n</tr>\n<tr>\n<td>ET</td>\n<td>扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令</td>\n</tr>\n<tr>\n<td>NE</td>\n<td>数字错误标志位(与浮点协处理器共同使用)</td>\n</tr>\n<tr>\n<td>WP</td>\n<td>写保护</td>\n</tr>\n<tr>\n<td>AM</td>\n<td>对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)</td>\n</tr>\n<tr>\n<td>NW</td>\n<td>直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 )</td>\n</tr>\n<tr>\n<td>CD</td>\n<td>cache 缺失设置位</td>\n</tr>\n<tr>\n<td>PG(Paging Enable)</td>\n<td>控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><ul>\n<li>CR1：保留</li>\n<li>CR2：存放发生页错误时的虚拟地址</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202839085-1411938709.jpg\" alt=\"img\"></p>\n<ul>\n<li><ul>\n<li>CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202910897-491400201.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PWT(Page-Level Writethrough)</td>\n<td>控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效</td>\n</tr>\n<tr>\n<td>PCD(Page-Level Cache Disable)</td>\n<td>PCD=1，表示最高目录表不可缓存，PCD=0，相反</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。</li>\n<li>Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以  page_directory_table base address为27位，指向32B对齐的页目录指针表。</li>\n</ul>\n<ul>\n<li><ul>\n<li>CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202916929-782474184.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VME(virtual 8086 mode extension)</td>\n<td>虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。</td>\n</tr>\n<tr>\n<td>PVI(protected mode virtual interrupts)</td>\n<td>保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。</td>\n</tr>\n<tr>\n<td>TSD(time stamp disable)</td>\n<td>禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。</td>\n</tr>\n<tr>\n<td>DE(debugging extensions)</td>\n<td>调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。</td>\n</tr>\n<tr>\n<td>PSE(page size extensions)</td>\n<td>允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。</td>\n</tr>\n<tr>\n<td>PAE(physical address extension)</td>\n<td>允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。</td>\n</tr>\n<tr>\n<td>MCE(machine check exception)</td>\n<td>允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。</td>\n</tr>\n<tr>\n<td>PGE(Page-Global Enable)</td>\n<td>将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。</td>\n</tr>\n<tr>\n<td>PCE(Performance-Monitoring Counter Enable)</td>\n<td>将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。</td>\n</tr>\n<tr>\n<td>OSFXSR(FXSAVE/FXRSTOR Support)</td>\n<td>设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。</td>\n</tr>\n<tr>\n<td>OSXMMEXCPT(Unmasked Exception Support)</td>\n<td>当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常</td>\n</tr>\n<tr>\n<td>OSXSAVE(XSAVE and Extended States)</td>\n<td>设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>调试寄存器（8个）：DR0-DR7</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904203616226-760453523.jpg\" alt=\"img\"></p>\n<p>调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。</p>\n<p>DR0-DR3：保留32位断点的线性地址。</p>\n<p>DR4-DR5：保留。</p>\n<p>DR6：</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>B0-B3</td>\n<td>断点状态的监测</td>\n</tr>\n<tr>\n<td>BD</td>\n<td>调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器</td>\n</tr>\n<tr>\n<td>BS</td>\n<td>单步执行标志位</td>\n</tr>\n<tr>\n<td>BT</td>\n<td>任务转换标志位</td>\n</tr>\n</tbody>\n</table>\n<p>DR7：</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>L0-L3</td>\n<td>局部断点使能标志位</td>\n</tr>\n<tr>\n<td>G0-G3</td>\n<td>全局断点使能标志位</td>\n</tr>\n<tr>\n<td>LE GE</td>\n<td>置位，表明处理器可以监测导致数据断点的指令。推荐置位为1</td>\n</tr>\n<tr>\n<td>GD</td>\n<td>通用监测使能标志位。表明是否开启调试寄存器保护</td>\n</tr>\n<tr>\n<td>LEN0 - LEN3</td>\n<td>用来表明相应断点地址寄存器内存位置的大小</td>\n</tr>\n<tr>\n<td>R/W0 - R/W3</td>\n<td>相应断点的状态</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR</p>\n<p>GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。</p>\n<p>IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。</p>\n<p>LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。</p>\n<p>TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。</p>\n</li>\n<li><p>16位段寄存器（6个）：CS、DS、ES、FS、GS、SS</p>\n<p>段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。</p>\n<p>在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。</p>\n</li>\n<li><p>其他寄存器：EIP、TSC等</p>\n<ul>\n<li><p>指令指针指示器–EIP</p>\n<p>32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。</p>\n</li>\n<li><p>时间戳寄存器–TSC</p>\n<p>每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。</p>\n</li>\n<li><p>浮点寄存器</p>\n<p>由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要技术\"><a href=\"#主要技术\" class=\"headerlink\" title=\"主要技术\"></a>主要技术</h2><p>重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。</p>\n<p>乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：</p>\n<ol>\n<li>寄存器位于CPU内部，数量很少，仅十四个</li>\n<li>寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit）</li>\n<li>每个内部寄存器都有一个名字，而没有类似存储器的地址编号</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html\" target=\"_blank\" rel=\"external\">80X86寄存器详解</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin\" target=\"_blank\" rel=\"external\">寄存器（百度百科）</a></p>\n<p><a href=\"http://blog.chinaunix.net/uid-27717694-id-3943419.html\" target=\"_blank\" rel=\"external\">Intel X86 CPU系列的寄存器</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_85998e38010122wq.html\" target=\"_blank\" rel=\"external\">CR0-4寄存器介绍</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。</p>\n<p>　　寄存器是集成电路中非常重要的一种存储单元，通常由<a href=\"https://baike.baidu.com/item/D%E8%A7%A6%E5%8F%91%E5%99%A8\" target=\"_blank\" rel=\"external\">D触发器</a>组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。</p>\n<p>　　寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。</p>\n<h2 id=\"16位寄存器\"><a href=\"#16位寄存器\" class=\"headerlink\" title=\"16位寄存器\"></a>16位寄存器</h2><p>以8086（16位处理器，14个寄存器）为例。按其用途可分为：</p>\n<ul>\n<li><p>通用寄存器（8个）：</p>\n<ul>\n<li><p>数据寄存器</p>\n<p>AH&amp;AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的<a href=\"https://baike.baidu.com/item/I%252FO%E6%8C%87%E4%BB%A4\" target=\"_blank\" rel=\"external\">I/O指令</a>都使用这一寄存器与外界设备传送数据。</p>\n<p>BH&amp;BL=BX(base)：基址寄存器，常用于地址索引。</p>\n<p>CH&amp;CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在<a href=\"https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4\" target=\"_blank\" rel=\"external\">移位指令</a>,循环(loop)和串处理指令中用作隐含的计数器。</p>\n<p>DH&amp;DL=DX(data)：数据寄存器，常用于数据传递。</p>\n<p>这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低八位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。</p>\n</li>\n<li><p>指针寄存器和变址寄存器：</p>\n<p>SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。</p>\n<p>这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p>\n</li>\n</ul>\n</li>\n<li><p>指令指针（1个）：</p>\n<p>指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。</p>\n<p>BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。</p>\n</li>\n<li><p>标志寄存器（1个）：</p>\n<p>标志寄存器（Flags Register,FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。</p>\n<p>在FR中有意义的有9位，其中6位是状态位，3位是控制位。</p>\n</li>\n<li><ul>\n<li><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904201107116-1774590873.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CF(carry flag)</td>\n<td>进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</td>\n</tr>\n<tr>\n<td>PF(parity flag)</td>\n<td>奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。</td>\n</tr>\n<tr>\n<td>AF(adjust flag)</td>\n<td>辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。</td>\n</tr>\n<tr>\n<td>ZF(zero flag)</td>\n<td>零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</td>\n</tr>\n<tr>\n<td>SF(sign flag)</td>\n<td>符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。</td>\n</tr>\n<tr>\n<td>TF(trap flag)</td>\n<td>跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。</td>\n</tr>\n<tr>\n<td>IF(interrupt enable flag)</td>\n<td>中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。</td>\n</tr>\n<tr>\n<td>DF(direction flag)</td>\n<td>方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。</td>\n</tr>\n<tr>\n<td>OF(overflow flag)</td>\n<td>溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>段寄存器（4个）：<ul>\n<li>CS（Code Segment）：代码段寄存器</li>\n<li>DS（Data Segment）：数据段寄存器 </li>\n<li>SS（Stack Segment）：堆栈段寄存器</li>\n<li>ES（Extra Segment）：附加段寄存器</li>\n</ul>\n</li>\n</ul>\n<p>当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻　址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。</p>\n<p>备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。</p>\n<h2 id=\"32位寄存器\"><a href=\"#32位寄存器\" class=\"headerlink\" title=\"32位寄存器\"></a>32位寄存器</h2><p>32位CPU 寄存器及数据结构图：</p>\n<p><img src=\"http://blog.chinaunix.net/attachment/201310/12/27717694_1381559379uuay.png\" alt=\"img\"></p>\n<ul>\n<li><p>通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</p>\n<ul>\n<li>尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。</li>\n<li>EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。</li>\n<li>EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。</li>\n<li>EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。</li>\n</ul>\n</li>\n<li><p>标志寄存器（1个）：EFLAGS</p>\n<p>控制任务状态和模式切换、中断处理、指令追踪和访问权限控制.寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)</p>\n<p>在16位标志寄存器的基础上增加了几个标志：</p>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202623585-1839788830.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IOPL(I/O privilege level field)</td>\n<td>指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</td>\n</tr>\n<tr>\n<td>NT(Nested task flag)</td>\n<td>控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。</td>\n</tr>\n<tr>\n<td>RF(Resume flag)</td>\n<td>控制处理器对调试异常的响应。</td>\n</tr>\n<tr>\n<td>VM(Virtual-8086 mode flag)</td>\n<td>置1以允许虚拟8086模式，清除则返回保护模式。</td>\n</tr>\n<tr>\n<td>AC(Alignment check flag)</td>\n<td>该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。</td>\n</tr>\n<tr>\n<td>VIF(Virtual interrupt flag)</td>\n<td>该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)</td>\n</tr>\n<tr>\n<td>VIP(Virtual interrupt pending flag)</td>\n<td>该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。</td>\n</tr>\n<tr>\n<td>ID(Identification flag)</td>\n<td>程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>控制寄存器（5个）：CR0-CR4</li>\n</ul>\n<p>控制寄存器决定处理器的操作模式和当前执行任务的一些特征。</p>\n<ul>\n<li><ul>\n<li>CR0：控制系统的工作模式和处理器的状态；x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202830101-1841642504.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PE(Protected-Mode Enable)</td>\n<td>PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。</td>\n</tr>\n<tr>\n<td>MP</td>\n<td>协处理器监视标志位</td>\n</tr>\n<tr>\n<td>EM</td>\n<td>该位表明是否需要仿真协处理器的功能</td>\n</tr>\n<tr>\n<td>TS</td>\n<td>每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位</td>\n</tr>\n<tr>\n<td>ET</td>\n<td>扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令</td>\n</tr>\n<tr>\n<td>NE</td>\n<td>数字错误标志位(与浮点协处理器共同使用)</td>\n</tr>\n<tr>\n<td>WP</td>\n<td>写保护</td>\n</tr>\n<tr>\n<td>AM</td>\n<td>对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)</td>\n</tr>\n<tr>\n<td>NW</td>\n<td>直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 )</td>\n</tr>\n<tr>\n<td>CD</td>\n<td>cache 缺失设置位</td>\n</tr>\n<tr>\n<td>PG(Paging Enable)</td>\n<td>控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><ul>\n<li>CR1：保留</li>\n<li>CR2：存放发生页错误时的虚拟地址</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202839085-1411938709.jpg\" alt=\"img\"></p>\n<ul>\n<li><ul>\n<li>CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202910897-491400201.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PWT(Page-Level Writethrough)</td>\n<td>控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效</td>\n</tr>\n<tr>\n<td>PCD(Page-Level Cache Disable)</td>\n<td>PCD=1，表示最高目录表不可缓存，PCD=0，相反</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。</li>\n<li>Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以  page_directory_table base address为27位，指向32B对齐的页目录指针表。</li>\n</ul>\n<ul>\n<li><ul>\n<li>CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904202916929-782474184.jpg\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VME(virtual 8086 mode extension)</td>\n<td>虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。</td>\n</tr>\n<tr>\n<td>PVI(protected mode virtual interrupts)</td>\n<td>保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。</td>\n</tr>\n<tr>\n<td>TSD(time stamp disable)</td>\n<td>禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。</td>\n</tr>\n<tr>\n<td>DE(debugging extensions)</td>\n<td>调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。</td>\n</tr>\n<tr>\n<td>PSE(page size extensions)</td>\n<td>允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。</td>\n</tr>\n<tr>\n<td>PAE(physical address extension)</td>\n<td>允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。</td>\n</tr>\n<tr>\n<td>MCE(machine check exception)</td>\n<td>允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。</td>\n</tr>\n<tr>\n<td>PGE(Page-Global Enable)</td>\n<td>将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。</td>\n</tr>\n<tr>\n<td>PCE(Performance-Monitoring Counter Enable)</td>\n<td>将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。</td>\n</tr>\n<tr>\n<td>OSFXSR(FXSAVE/FXRSTOR Support)</td>\n<td>设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。</td>\n</tr>\n<tr>\n<td>OSXMMEXCPT(Unmasked Exception Support)</td>\n<td>当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常</td>\n</tr>\n<tr>\n<td>OSXSAVE(XSAVE and Extended States)</td>\n<td>设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>调试寄存器（8个）：DR0-DR7</li>\n</ul>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904203616226-760453523.jpg\" alt=\"img\"></p>\n<p>调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。</p>\n<p>DR0-DR3：保留32位断点的线性地址。</p>\n<p>DR4-DR5：保留。</p>\n<p>DR6：</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>B0-B3</td>\n<td>断点状态的监测</td>\n</tr>\n<tr>\n<td>BD</td>\n<td>调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器</td>\n</tr>\n<tr>\n<td>BS</td>\n<td>单步执行标志位</td>\n</tr>\n<tr>\n<td>BT</td>\n<td>任务转换标志位</td>\n</tr>\n</tbody>\n</table>\n<p>DR7：</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>L0-L3</td>\n<td>局部断点使能标志位</td>\n</tr>\n<tr>\n<td>G0-G3</td>\n<td>全局断点使能标志位</td>\n</tr>\n<tr>\n<td>LE GE</td>\n<td>置位，表明处理器可以监测导致数据断点的指令。推荐置位为1</td>\n</tr>\n<tr>\n<td>GD</td>\n<td>通用监测使能标志位。表明是否开启调试寄存器保护</td>\n</tr>\n<tr>\n<td>LEN0 - LEN3</td>\n<td>用来表明相应断点地址寄存器内存位置的大小</td>\n</tr>\n<tr>\n<td>R/W0 - R/W3</td>\n<td>相应断点的状态</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR</p>\n<p>GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。</p>\n<p>IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。</p>\n<p>LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。</p>\n<p>TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。</p>\n</li>\n<li><p>16位段寄存器（6个）：CS、DS、ES、FS、GS、SS</p>\n<p>段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。</p>\n<p>在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。</p>\n</li>\n<li><p>其他寄存器：EIP、TSC等</p>\n<ul>\n<li><p>指令指针指示器–EIP</p>\n<p>32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。</p>\n</li>\n<li><p>时间戳寄存器–TSC</p>\n<p>每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。</p>\n</li>\n<li><p>浮点寄存器</p>\n<p>由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要技术\"><a href=\"#主要技术\" class=\"headerlink\" title=\"主要技术\"></a>主要技术</h2><p>重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。</p>\n<p>乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：</p>\n<ol>\n<li>寄存器位于CPU内部，数量很少，仅十四个</li>\n<li>寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit）</li>\n<li>每个内部寄存器都有一个名字，而没有类似存储器的地址编号</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html\" target=\"_blank\" rel=\"external\">80X86寄存器详解</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin\" target=\"_blank\" rel=\"external\">寄存器（百度百科）</a></p>\n<p><a href=\"http://blog.chinaunix.net/uid-27717694-id-3943419.html\" target=\"_blank\" rel=\"external\">Intel X86 CPU系列的寄存器</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_85998e38010122wq.html\" target=\"_blank\" rel=\"external\">CR0-4寄存器介绍</a></p>\n"},{"title":"Intel CPU 发展简史","date":"2017-09-08T16:39:05.000Z","_content":"\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904124918632-83277658.png)\n\n \n\n## 1971年11月15日：4004\n\n1971年11月15日，Intel公司的工程师霍夫发明了世界上第一个商用微处理器—4004。这款4位微处理器集成了2250个晶体管，晶体管之间的距离是10微米，能够处理4bit的数据，每秒运算6万次，频率为108KHz，前端总线为0.74MHz （4bit）。原为日本Busicom公司的计数器开发。\n\n编号为4004，第一个“4”代表此芯片是客户订购的产品编号，后一个“4”代表此芯片是英特尔公司制作的第四个订制芯片，之前还有4001（动态内存DRAM）、4002（[只读存储器](https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8)ROM）、4003（[Register](https://baike.baidu.com/item/Register/3414681)），这种数字代号却延用至今。采用4004芯片后，再配用一块程序存储器，数据存储器，移位寄存器，再加上键盘和数码管，就构成了一台完整的微型计算机。\n\n4004的最高频率有740kHz，能执行4位运算，支持8位指令集及12位地址集。\n\n4004只能称为世界上第一款商用处理器，而不是世界上第一款微处理器。第一款微处理器应该是美国军方研制，用于F-14雄猫战机中由6颗晶片组成的中央空气数据计算机：CADC（CenterAir Data Computer），虽然它的构造比4004还要简单，速度只有9.15KHz。\n\n## 1972年：8008\n\n8008频率为200KHz，晶体管的总数已经达到了3500个，能处理8比特的数据，性能是4004的两倍，速度为200KHz。更为重要的是，英特尔还首次获得了处理器的指令技术。\n\n8008芯片原本是为德克萨斯州的Datapoint公司设计的，但是这家公司最终却没有足够的财力支付这笔费用。于是双方达成协议，英特尔拥有这款芯片所有的知识产权，而且还获得了由Datapoint公司开发的指令集。这套指令集奠定了今天英特尔公司X86系列微处理器指令集的基础。\n\n执行8位运算，支持16位地址总线和16位数据总线。\n\n## 1974年：8080\n\n在微处理器发展初期，具有革新意义的芯片非Intel8080莫属了。由于采用了复杂的指令集以及40管脚封装，8080的处理能力大为提高，其功能是8008的10倍，每秒能执行29万条指令，集成晶体管数目6000，运行速度2MHz。\n\n与此同时，微处理器的优势已经被业内人士所认同，于是更多的公司开始接入这一领域，竞争开始变得日益激烈。当时与英特尔同台竞技的有RCA(美国无线电公司)、Honeywell、Fairchild、美国国家半导体公司、AMD、摩托罗拉以及Zilog公司。值得一提的是Zilog，世界上第一块4004芯片的设计者Faggin就加盟了该公司。由该公司推出的Z80微处理器比Intel8080功能更为强大，而且直到今天这款处理器仍然被尊为经典。\n\n8080有幸成为了第一款个人计算机Altair的大脑。\n\n8位元处理器，拥有16位地址总线和8位数据总线，包含7个八位寄存器，支持16位寻址，同时也包含一些输入输出端口，有效解决了外部设备在内存寻址能力不足的问题。\n\n## 1978年：8086-8088\n\n1978年，英特尔推出了首枚16位微处理器8086，同时生产出与之配合的数学协处理器8087，这两种芯片使用相同的指令集，以后英特尔生产的处理器，均对其兼容。趁着市场销售正好的时机，以及市场需求的提升，Intel在同一年推出了性能更出色的8088处理器。三款处理器都拥有29000只晶体管，速度可分为5MHz、8MHz、10MHz，内部数据总线(处理器内部传输数据的总线)、外部数据总线(处理器外部传输数据的总线)均为16位，地址总线为20位，可寻址1MB内存。首次在商业市场给消费者提供了更自由选择。\n\n## 1982年：80286\n\n80286(也称286)是处理器进入全新技术的标准产品，具备16位字长，集成了14.3万只晶体管，具有6MHz、8MHz、10MHz、12.5MHz四个主频的产品。286是Intel第一款具有完全兼容性的处理器，即可以运行所有针对其前代处理器编写的软件，这一软件兼容性也成为了Intel处理器家族一个恒久不变的特点。286是英特尔的最后一块16位处理器\n\n最大主频为20MHz，采用16位数据总线和24位地址总线。\n\n80286有两种工作模式：实模式和保护模式。在实模式下，80286直接访问内存的空间被限制在1M字节，更多内存需要通过EMS或XMS内存机制进行映射。而在保护模式下，80286可以直接访问16M字节的内存，并具有异常处理机制。\n\n## 1985年：80386\n\n英特尔第一款32位处理器，集成了27万5千只晶体管，超过了4004芯片的一百倍，每秒可以处理500万条指令。同时也是第一款具有“多任务”功能的处理器，所谓“多任务”就是说它可以同时处理多个程序程序的指令，这对微软的操作系统发展有着重要的影响。\n\n重要特点：\n\n1. 首次在x86处理器中实现了32位系统，\n2. 可配合使用80387数字辅助处理器增强浮点运算能力\n3. 首次采用高速缓存（外置）解决内存速度瓶颈问题。\n\n由于这些设计，80386的[运算速度](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6)达到了前代产品80286的数倍。80386DX的内部和外部数据总线（或资料汇流排）是32位，地址总线（或位址汇流排）也是32位，可以定址到4GB内存，并可以管理64TB的虚拟存储空间（虚拟存储空间：通过硬件和软件的综合来扩大用户可存储空间，它在内存储器和外存储器（磁盘、光盘）之间增加一定的硬件和软件支持，使两者形成一个有机整体，支持运行比实际配置的内存容量大的多的大任务程序）。\n\n80386有三种工作模式：实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M字节（也叫做位元组）；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。\n\n## Intel RapidCAD 被遗忘的微处理器\n\nRapidCAD是英特尔有史以来第一款为旧款个人计算机所提供的升级套件(也就是OverDrive的始祖)。原386的使用者不需要更换主机板，只要把RapidCAD买回来将主机板上旧有的中央处理器芯片(CPU)替换掉，就可以享受接近486的运算能力。RapidCAD其实就是把486 DX芯片去掉内部高速缓存然后装入386的封装里面，RapidCAD也不支持486增加的新指令。不过由于386封装的频宽限制，RapidCAD对整体的效能提升比不上直接升级到486 DX。相同频率下，486 DX可以有比386/387快上两倍的速度，而RapidCAD在整数运算方面最多只能提升35%，在浮点运算方面，则可以提升将近70%。\n\nIntel RapidCAD特殊的地方在于，它是由两颗芯片组成，缺一不可。这归咎于486 DX内建浮点运算器(FPU)，而386则是将浮点运算器分开(就是387)。由于RapidCAD-1本身就含有浮点运算器(因为它就是486 DX阉割版)，根本不需要387，所以RapidCAD-2就是用来替代原来主机板上的387芯片。RapidCAD-1负责所有的运算，而RapidCAD-2则是负责模拟浮点运算器，以防止旧有主机板以为没有安装浮点运算功能(尤其在执行286/287的程序时)。市面上有时候把RapidCAD-1与RapidCAD-2分开卖，这就是不了解RapidCAD运作方式的结果。\n\n## 1989年：80486\n\n80486处理器集成了125万个晶体管，时钟频率由25MHz逐步提升到33MHz、40MHz、50MHz及后来的100MHz。486家族的指令集与386非常相似，只有增加少量的指令。\n\n486处理器的应用意味着用户从此摆脱了命令形式的计算机，进入“选中并点击(point-and-click)”的计算时代。英特尔486处理器首次采用内建的数学协处理器，将负载的数学运算功能从中央处理器中分离出来，从而显著加快了计算速度。\n\n386和486推向市场后，均大获成功，英特尔在芯片领域的霸主地位日益凸现。此后，英特尔开始告别微处理器数字编号时代，进入到了Pentium时代。\n\n## 1994年3月10日：Intel Pentium中央处理器芯片\n\n1993年，英特尔发布了Pentium(俗称586)中央处理器芯片(CPU)。本来按照惯常的命名规律是80586，但是在486发展末期，就已经有公司将486等级的产品标识成586来销售了。因此英特尔决定使用自创的品牌来作为新产品的商标—Pentium。\n\n英特尔奔腾处理器采用了0.60微米工艺技术制造，核心由320万个晶体管组成。支持计算机更轻松的集成“现实世界”数据，如语音、声音、手写体和图片等。\n\nPentium是x86系列一大革新。其中晶体管数大幅提高、增强了浮点运算功能、并把十年未变的工作电压降至3.3V。Pentium刚推出的时候拥有浮点数除法不正确的错误(FDIV Bug)，导致英特尔大量回收第一代产品(1994年12月之前的产品)，所以有FDIV Bug的微处理器所剩不多。Pentium 50MHz也有这个FDIV错误，不过A80501-50只是业界样本，从来没有在市场上出现过。\n\n1995年3月27日，英特尔发布Pentium 120MHz处理器，采用了0.60微米/0.35两种工艺技术，不过核心依旧由320万个晶体管组成。\n\n1995年6月，英特尔发布Pentium 133MHz处理器，采用0.35工艺技术制造,核心提升到由330万个晶体管组成。\n\n1995年11月1日，英特尔发布Pentium 150MHz、Pentium 166MHz、Pentium 180MHz、Pentium 200MHz四款处理器，并且采用了0.60微米/0.35两种工艺技术,核心提升到由550万个晶体管组成。此时INTEL在以前设计基础上增加了L2 cache为256K和512K两种版本。\n\n1996年1月4日，英特尔又发布Pentium 150MHz、Pentium 166MHz两款处理器，采用了0.35微米工艺技术,不过核心由330万个晶体管组成。\n\n1996年6月10日，英特尔发布Pentium 200MHz处理器，采用了0.35微米工艺技术，不过核心还是由330万个晶体管组成。\n\n## 1996年：Intel Pentium Pro\n\nPentimuPro的内部含有高达550万个的晶体管，内部时钟频率为133MHz，处理速度几乎是100MHz的Pentium的2倍。PentimuPro的一级(片内)缓存为8KB指令和8KB数据。值得注意的是在PentimuPro的一个封装中除PentimuPro芯片外还包括有一个256KB的二级缓存芯片，两个芯片之间用高频宽的内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。PentiumPro 200MHz CPU的L2 Cache就是运行在200MHz，也就是工作在与处理器相同的频率上。这样的设计领PentiumPro达到了最高的性能。而PentimuPro最引人注目的地方是它具有一项称为“动态执行”的创新技术，这是继Pentium在[超标量体系结构](https://baike.baidu.com/item/%E8%B6%85%E6%A0%87%E9%87%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)上实现实破之后的又一次飞跃。PentimuPro系列的工作频率是150/166/180/200，一级缓存都是16KB，而前三者都有256KB的二级缓存，至于频率为200的CPU还分为三种版本，不同就在于他们的内置的缓存分别是256KB，512KB，1MB。\n\n## 1997年1月：Intel Pentium MMX\n\nPentium MMX芯片在X86指令集的基础上加入了57条多媒体指令。这些指令专门用来处理视频、音频和图象数据，使CPU在多媒体操作上具有更强大的处理能力，Pentium MMX还使用了许多新技术。单指令多数据流SIMD技术能够用一个指令并行处理多个数据，缩短了CPU在处理视频、音频、图形和动画时用于运算的时间；流水线从5级增加到6级，一级高速缓存扩充为16K，一个用于数据高速缓存，另一个用于指令高速缓存，因而速度大大加快；Pentium MMX还吸收了其他CPU的优秀处理技术，如分支预测技术和返回堆栈技术。\n\nPentium MMX等于是Pentium的加强版中央处理器芯片(CPU)，除了增加67个MMX(Multi-Media eXtension)指令以及64位数据型态之外之外，也将内建指令及数据暂存(Cache)从之前的8KB增加到16KB，内部工作电压降到2.8V。而英特尔之后的桌上型中央处理器皆包含了MMX指令。\n\n## 1997年：Intel Pentium Overdrive\n\nIntel Pentium OverDrive中央处理器芯片(CPU)，又是一项英特尔造福旧计算机使用者的升级选择。Pentium OverDrive有两种，一种(不含MMX，5V)是给80486升级用的，另一种(含MMX，3.3V)是给Pentium早期产品(Socket6, 50-66MHz)升级的。他们都有含散热器及风扇。\n\n## 1997-1998年：Pentium II\n\n1997年5月7日，英特尔发布Pentium II 233MHz、Pentium II 266MHz、Pentium II 300MHz三款PII处理器，采用了0.35微米工艺技术，核心提升到750万个晶体管组成。采用SLOT1架构，通过单边插接卡(SEC)与主板相连，SEC卡盒将CPU内核和二级高速缓存封装在一起，二级高速缓存的工作速度是处理器内核工作速度的一半；处理器采用了与Pentium PRO相同的动态执行技术，可以加速软件的执行；通过双重独立总线与系统总线相连，可进行多重数据交换，提高系统性能；PentiumII也包含MMX指令集。Intel此举希望用SLOT1构架的专利将AMD等一棍打死，可没想到Socket 7平台在以AMD的K6-2为首的处理器的支持下，走入了另一个春天。而从此开始，Intel也开始走上了一条前途不明的道路，开始频繁的强行制定自己的标准，企图借此达到迅速挤垮竞争对手的目的，但市场与用户的需要使得Intel开始不断的陷入被动和不利的局面。\n\n在这个时期100MHz频率的SDR内存已经出现在市场上，但是Intel却惊人地宣布他们将放弃并行内存而主推一种名为Rambus的内存，而一时间众多大公司如西门子、HP和DELL等都投入了Rambus的门下，不过后来DDR内存的流行也证明了Intel的失败。\n\n1997年6月2日，英特尔发布MMX指令技术的Pentium II 233MHz处理器，采用了0.35微米工艺技术,核心由450万个晶体管组成。\n\n1997年8月18日，英特尔发布L2 cache为1M的Pentium II 200MHz处理器，采用了0.35微米工艺技术,核心由550万个晶体管组成。\n\n1998年1月26日，英特尔发布Pentium II 333MHz处理器，采用了0.35微米工艺技术，核心由750万个晶体管组成。\n\n1998年4月15日，英特尔发布Pentium II 350MHz、Pentium II 400MHz和第一款Celeron 266MHz处理器，此三款CPU都采用了最新0.25微米工艺技术,核心由750万个晶体管组成。\n\n1998年8月24日，英特尔发布Pentium II 450MHz处理器，采用了0.25微米工艺技术,核心由750万个晶体管组成。\n\nCPU发展到这个时期，就不能不说说Intel Pentium II Cerelon处理器。英特尔将Celeron处理器的L2 Cache设定为只有Pentium II的一半(也就是128KB)，这样既有合理的效能，又有相对低廉的售价(有A字尾的)；这样的策略一直延续到今天。不过很快有人发现，使用双Celeron的系统与双Pentium II的系统差距不大，而价格却便宜很多，结果造成了Celeron冲击高阶市场的局面。后来英特尔决定取消Celeron处理器的SMP功能，才解决了这个问题。\n\n### Pentium II Celeron处理器\n\nCeleron（赛扬）300A，是一个让多少人闻之动容的产品，又陪伴了多少曾经年少的读者度过悠长的学生时代。赛扬300A，从某种意义上已经是Intel的第二代赛扬处理器。第一代的赛扬处理器仅仅拥有266MHz、300MHz两种版本，第一代的Celeron处理器由于不拥有任何的二级缓存，虽然有效的降低了成本，但是性能也无法让人满意。为了弥补性能上的不足，Intel终于首次推出带有二级缓存的赛扬处理器——采用Mendocino核心的Celeron300A、333、366。经典，从此诞生。\n\n## 1999年：Intel Pentium III\n\n1999年2月26日，英特尔发布Pentium III 450MHz、Pentium III 500MHz处理器，同时采用了0.25微米工艺技术,核心由950万个晶体管组成，从此Intel开始踏上了PIII旅程。\n\nPentium III是给桌上型计算机的中央处理器芯片(CPU)，等于是Pentium II的加强版，新增七十条新指令(SIMD，SSE)。Pentium III与Pentium II一样有Mobile、Xeon以及Cerelon等不同的版本。Celeron系列与Pentium III最大的差距在于二级缓存，100MHz外频的Tualatin Celeron 1GHz可以轻松地跃上133MHz外频。更为重要的是，Tualatin Celeron还有很好的向下兼容性，甚至440BX主板在使用转接卡之后也有望采用该CPU，因此也成为很多升级用户的首选。\n\n特别指出的是，Pentium III光是桌上型就拥有Katmai Slot 1 、Coppermine Slot 1以及Coppermine Socket 370等三种不同的系列。到后期，英特尔放弃插卡式界面而又回归到插槽界面(Socket 370)。socket370封装开始推出的时候，有一部分消费者舍弃了slot1平台而选择了新的处理器。新的PGA封装分为PPGA和FC-PGA两种，前者较为廉价，因而被赛扬处理器所采用，而更为昂贵的后者则被奔腾III处理器所采用。例外的是：采用Mendocino核心的赛扬处理器同时有这两种不同封装的版本。采用PPGA封装的赛扬处理器可以通过转接卡在slot1主板上使用，而采用FC-PGA封装的奔三处理器则无能为力了。\n\n## 2000年：Intel Pentium IV\n\nPentium 4处理器集成了4200万个晶体管，到了改进版的Pentium 4(Northwood)更是集成了5千5百万个晶体管；并且开始采用0.18微米进行制造，初始速度就达到了1.5GHz。\n\nPentium 4还提供的SSE2指令集，这套指令集增加144个全新的指令，在128bit压缩的数据，在SSE时，仅能以4个单精度浮点值的形式来处理，而在SSE2指令集，该资料能采用多种数据结构来处理：\n\n4个单精度浮点数(SSE)对应2个双精度浮点数(SSE2)，对应16字节数(SSE2)，对应8个字数(word)，对应4个双字数(SSE2)，对应2个四字数(SSE2)，对应1个128位长的整数(SSE2) 。\n\n## 2002-2004年：超线程P4处理器\n\n2002年11月14日，英特尔在全新英特尔奔腾4处理器3.06GHz上推出其创新超线程(Hyper-Threading，HT)技术。超线程(HT)技术支持全新级别的高性能台式机，同时快速运行多个计算应用，或为采用多线程的单独软件程序提供更多性能。超线程(HT)技术可将电脑性能提升达25%。除了为台式机用户引入超线程(HT)技术外，英特尔在推出英特尔奔腾4处理器3.06GHZ时达到了一个电脑里程碑。这是第一款商用微处理器，运行速率为每秒30亿周期，并且采用当时业界最先进的0.13微米制程制作。\n\n### P4处理器3.06GHz\n\n2003年，英特尔发布前端总线为533MHz的Pentium 4 3.06GHz处理器，采用了0.13微米工艺技术,提供512K的二级缓存，核心由5500万个晶体管组成。\n\n### P4处理器至尊版3.20GHz\n\n2004年初发布，该处理器可兼容现有的英特尔865和英特尔875芯片组家族产品以及标准系统内存。2MB三级高速缓存可以预先加载图形帧缓冲区或视频帧，以满足处理器随后的要求，使在访问内存和I/O设备时实现更高的吞吐率和更快的帧带率。最终，这可带来更逼真的游戏效果和改进的视频编辑性能。增强的CPU性能还可支持软件厂商创建完善的软件物理引擎，从而带来栩栩如生的人物动作和人工智能，使电脑控制的人物更加形象、逼真。\n\n半年之后，2004年6月，英特尔发布了P4 3.4GHz处理器，该处理器支持超线程(HT)技术，采用0.13微米制程，具备512KB二级高速缓存、2MB三级高速缓存和800MHz系统前端总线速度。\n\nNorthwood是第二代产品，采用0.13微米制程，具有电压低、体积小、温度低的优点。接着就是Prescott(0.09微米)，虽然这技术很新，不过由于效能提升并不明显，而且有过热的问题。后来英特尔又推出Hyper Threading技术，大大增加工作效率，让P4又成为市场宠儿。英特尔之后又推出Extreme Edition、含有Prestonia(原本给服务器用的Xeon核心)以及Gallatin(0.13微米Northwood外频提升改良版)核心的CPU。现在市场上的高阶Pentium 4则是Socket LGA 775的Prescott为主。\n\n## 2005-2006年：双核处理器\n\n2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了。双核和多核处理器设计用于在一枚处理器中集成两个或多个完整执行内核，以支持同时管理多项活动。英特尔超线程(HT)技术能够使一个执行内核发挥两枚逻辑处理器的作用，因此与该技术结合使用时，英特尔奔腾处理器至尊版840能够充分利用以前可能被闲置的资源，同时处理四个软件线程。\n\n### 英特尔奔腾D处理器\n\n5月，带有两个处理内核的英特尔奔腾D处理器随英特尔945高速芯片组家族一同推出，可带来某些消费电子产品的特性，例如：环绕立体声音频、高清晰度视频和增强图形功能。2006年1月，英特尔发布了Pentium D 9xx系列处理器，包括了支持VT虚拟化技术的Pentium D 960(3.60GHz)、950(3.40GHz)和不支持VT的Pentium D 945(3.4 GHz)、925(3GHz)(注：925不支持VT虚拟化技术)和915(2.80GHz)。\n\n### 英特尔酷睿2双核处理器\n\n2006年7月，英特尔公司面向家用和商用个人电脑与笔记本电脑，发布了十款全新英特尔酷睿2双核处理器和英特尔酷睿至尊处理器。英特尔酷睿2双核处理器家族包括五款专门针对企业、家庭、工作站和玩家(如高端游戏玩家)而定制的台式机处理器，以及五款专门针对移动生活而定制的处理器。英特尔酷睿2双核处理器设计用于提供出色的能效表现，并更快速地运行多种复杂应用，支持用户改进各种任务的处理，例如：更流畅地观看和播放高清晰度视频；在电子商务交易过程中更好地保护电脑及其资产；以及提供更耐久的电池使用时间和更加纤巧时尚的笔记本电脑外形。\n\n全新处理器可实现高达40%的性能提升，其能效比最出色的英特尔奔腾处理器高出40%。英特尔酷睿2双核处理器包含2.91亿个晶体管。不过，Pentium D谈不上是一套完美的双核架构，Intel只是将两个完全独立的CPU核心做在同一枚芯片上，通过同一条前端总线与芯片组相连。两个核心缺乏必要的协同和资源共享能力，而且还必须频繁地对二级缓存作同步化刷新动作，以避免两个核心的工作步调出问题。从这个意义上说，Pentium D带来的进步并没有人们预想得那么大！\n\n## 2011年：重新确定处理器产品架构\n\n2011年3月，使用32nm工艺全新桌面级和移动端处理器采用了i3、i5和i7的产品分级架构。其中i3主攻低端市场，采用双核处理器架构，约2MB二级缓存；i5处理器主攻主流市场，采用四核处理器架构，4MB二级缓存；i7主攻高端市场，采用四核八线程或六核十二线程架构，二级缓存不少于8MB。\n\n## 2012年：发布22纳米工艺和第三代处理器\n\n使用22nm工艺的处理器热功耗普遍小于77W，使得处理器的散热需求大幅下降，提升了大规模数据运算的可靠性，并降低了散热功耗。\n\n## 2014年：首发桌面级8核心16线程处理器\n\n2014年9月上市的i7-5960X处理器是第一款基于22nm工艺的八核心桌面级处理器，拥有高达20MB的三级缓存，主频达到3.5GHz，热功耗140W。此处理器的处理能力可谓超群，浮点数计算能力是普通办公电脑的10倍以上。随着这一“怪兽”处理器的问世，Intel公司在处理器领域与AMD的差距越拉越大，已经完全形成了一家独大的局面。\n\n \n\n## 寻址空间发展表\n\n摘自 [寻访x86处理器“实模式”和“保护模式”的前世今生](http://blog.chinaunix.net/uid-23069658-id-3569341.html)\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170906002916601-1518759142.png)\n\n \n\n##  参考资料：\n\n[Intel CPU发展简史](http://www.360doc.com/content/15/0411/07/21966267_462329844.shtml)\n\n百度百科资料","source":"_posts/Intel-CPU-发展简史.md","raw":"---\ntitle: Intel CPU 发展简史\ndate: 2017-09-09 00:39:05\ncategories: CPU发展史\ntags:\n  - CPU\n  - 处理器\n---\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170904124918632-83277658.png)\n\n \n\n## 1971年11月15日：4004\n\n1971年11月15日，Intel公司的工程师霍夫发明了世界上第一个商用微处理器—4004。这款4位微处理器集成了2250个晶体管，晶体管之间的距离是10微米，能够处理4bit的数据，每秒运算6万次，频率为108KHz，前端总线为0.74MHz （4bit）。原为日本Busicom公司的计数器开发。\n\n编号为4004，第一个“4”代表此芯片是客户订购的产品编号，后一个“4”代表此芯片是英特尔公司制作的第四个订制芯片，之前还有4001（动态内存DRAM）、4002（[只读存储器](https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8)ROM）、4003（[Register](https://baike.baidu.com/item/Register/3414681)），这种数字代号却延用至今。采用4004芯片后，再配用一块程序存储器，数据存储器，移位寄存器，再加上键盘和数码管，就构成了一台完整的微型计算机。\n\n4004的最高频率有740kHz，能执行4位运算，支持8位指令集及12位地址集。\n\n4004只能称为世界上第一款商用处理器，而不是世界上第一款微处理器。第一款微处理器应该是美国军方研制，用于F-14雄猫战机中由6颗晶片组成的中央空气数据计算机：CADC（CenterAir Data Computer），虽然它的构造比4004还要简单，速度只有9.15KHz。\n\n## 1972年：8008\n\n8008频率为200KHz，晶体管的总数已经达到了3500个，能处理8比特的数据，性能是4004的两倍，速度为200KHz。更为重要的是，英特尔还首次获得了处理器的指令技术。\n\n8008芯片原本是为德克萨斯州的Datapoint公司设计的，但是这家公司最终却没有足够的财力支付这笔费用。于是双方达成协议，英特尔拥有这款芯片所有的知识产权，而且还获得了由Datapoint公司开发的指令集。这套指令集奠定了今天英特尔公司X86系列微处理器指令集的基础。\n\n执行8位运算，支持16位地址总线和16位数据总线。\n\n## 1974年：8080\n\n在微处理器发展初期，具有革新意义的芯片非Intel8080莫属了。由于采用了复杂的指令集以及40管脚封装，8080的处理能力大为提高，其功能是8008的10倍，每秒能执行29万条指令，集成晶体管数目6000，运行速度2MHz。\n\n与此同时，微处理器的优势已经被业内人士所认同，于是更多的公司开始接入这一领域，竞争开始变得日益激烈。当时与英特尔同台竞技的有RCA(美国无线电公司)、Honeywell、Fairchild、美国国家半导体公司、AMD、摩托罗拉以及Zilog公司。值得一提的是Zilog，世界上第一块4004芯片的设计者Faggin就加盟了该公司。由该公司推出的Z80微处理器比Intel8080功能更为强大，而且直到今天这款处理器仍然被尊为经典。\n\n8080有幸成为了第一款个人计算机Altair的大脑。\n\n8位元处理器，拥有16位地址总线和8位数据总线，包含7个八位寄存器，支持16位寻址，同时也包含一些输入输出端口，有效解决了外部设备在内存寻址能力不足的问题。\n\n## 1978年：8086-8088\n\n1978年，英特尔推出了首枚16位微处理器8086，同时生产出与之配合的数学协处理器8087，这两种芯片使用相同的指令集，以后英特尔生产的处理器，均对其兼容。趁着市场销售正好的时机，以及市场需求的提升，Intel在同一年推出了性能更出色的8088处理器。三款处理器都拥有29000只晶体管，速度可分为5MHz、8MHz、10MHz，内部数据总线(处理器内部传输数据的总线)、外部数据总线(处理器外部传输数据的总线)均为16位，地址总线为20位，可寻址1MB内存。首次在商业市场给消费者提供了更自由选择。\n\n## 1982年：80286\n\n80286(也称286)是处理器进入全新技术的标准产品，具备16位字长，集成了14.3万只晶体管，具有6MHz、8MHz、10MHz、12.5MHz四个主频的产品。286是Intel第一款具有完全兼容性的处理器，即可以运行所有针对其前代处理器编写的软件，这一软件兼容性也成为了Intel处理器家族一个恒久不变的特点。286是英特尔的最后一块16位处理器\n\n最大主频为20MHz，采用16位数据总线和24位地址总线。\n\n80286有两种工作模式：实模式和保护模式。在实模式下，80286直接访问内存的空间被限制在1M字节，更多内存需要通过EMS或XMS内存机制进行映射。而在保护模式下，80286可以直接访问16M字节的内存，并具有异常处理机制。\n\n## 1985年：80386\n\n英特尔第一款32位处理器，集成了27万5千只晶体管，超过了4004芯片的一百倍，每秒可以处理500万条指令。同时也是第一款具有“多任务”功能的处理器，所谓“多任务”就是说它可以同时处理多个程序程序的指令，这对微软的操作系统发展有着重要的影响。\n\n重要特点：\n\n1. 首次在x86处理器中实现了32位系统，\n2. 可配合使用80387数字辅助处理器增强浮点运算能力\n3. 首次采用高速缓存（外置）解决内存速度瓶颈问题。\n\n由于这些设计，80386的[运算速度](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6)达到了前代产品80286的数倍。80386DX的内部和外部数据总线（或资料汇流排）是32位，地址总线（或位址汇流排）也是32位，可以定址到4GB内存，并可以管理64TB的虚拟存储空间（虚拟存储空间：通过硬件和软件的综合来扩大用户可存储空间，它在内存储器和外存储器（磁盘、光盘）之间增加一定的硬件和软件支持，使两者形成一个有机整体，支持运行比实际配置的内存容量大的多的大任务程序）。\n\n80386有三种工作模式：实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M字节（也叫做位元组）；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。\n\n## Intel RapidCAD 被遗忘的微处理器\n\nRapidCAD是英特尔有史以来第一款为旧款个人计算机所提供的升级套件(也就是OverDrive的始祖)。原386的使用者不需要更换主机板，只要把RapidCAD买回来将主机板上旧有的中央处理器芯片(CPU)替换掉，就可以享受接近486的运算能力。RapidCAD其实就是把486 DX芯片去掉内部高速缓存然后装入386的封装里面，RapidCAD也不支持486增加的新指令。不过由于386封装的频宽限制，RapidCAD对整体的效能提升比不上直接升级到486 DX。相同频率下，486 DX可以有比386/387快上两倍的速度，而RapidCAD在整数运算方面最多只能提升35%，在浮点运算方面，则可以提升将近70%。\n\nIntel RapidCAD特殊的地方在于，它是由两颗芯片组成，缺一不可。这归咎于486 DX内建浮点运算器(FPU)，而386则是将浮点运算器分开(就是387)。由于RapidCAD-1本身就含有浮点运算器(因为它就是486 DX阉割版)，根本不需要387，所以RapidCAD-2就是用来替代原来主机板上的387芯片。RapidCAD-1负责所有的运算，而RapidCAD-2则是负责模拟浮点运算器，以防止旧有主机板以为没有安装浮点运算功能(尤其在执行286/287的程序时)。市面上有时候把RapidCAD-1与RapidCAD-2分开卖，这就是不了解RapidCAD运作方式的结果。\n\n## 1989年：80486\n\n80486处理器集成了125万个晶体管，时钟频率由25MHz逐步提升到33MHz、40MHz、50MHz及后来的100MHz。486家族的指令集与386非常相似，只有增加少量的指令。\n\n486处理器的应用意味着用户从此摆脱了命令形式的计算机，进入“选中并点击(point-and-click)”的计算时代。英特尔486处理器首次采用内建的数学协处理器，将负载的数学运算功能从中央处理器中分离出来，从而显著加快了计算速度。\n\n386和486推向市场后，均大获成功，英特尔在芯片领域的霸主地位日益凸现。此后，英特尔开始告别微处理器数字编号时代，进入到了Pentium时代。\n\n## 1994年3月10日：Intel Pentium中央处理器芯片\n\n1993年，英特尔发布了Pentium(俗称586)中央处理器芯片(CPU)。本来按照惯常的命名规律是80586，但是在486发展末期，就已经有公司将486等级的产品标识成586来销售了。因此英特尔决定使用自创的品牌来作为新产品的商标—Pentium。\n\n英特尔奔腾处理器采用了0.60微米工艺技术制造，核心由320万个晶体管组成。支持计算机更轻松的集成“现实世界”数据，如语音、声音、手写体和图片等。\n\nPentium是x86系列一大革新。其中晶体管数大幅提高、增强了浮点运算功能、并把十年未变的工作电压降至3.3V。Pentium刚推出的时候拥有浮点数除法不正确的错误(FDIV Bug)，导致英特尔大量回收第一代产品(1994年12月之前的产品)，所以有FDIV Bug的微处理器所剩不多。Pentium 50MHz也有这个FDIV错误，不过A80501-50只是业界样本，从来没有在市场上出现过。\n\n1995年3月27日，英特尔发布Pentium 120MHz处理器，采用了0.60微米/0.35两种工艺技术，不过核心依旧由320万个晶体管组成。\n\n1995年6月，英特尔发布Pentium 133MHz处理器，采用0.35工艺技术制造,核心提升到由330万个晶体管组成。\n\n1995年11月1日，英特尔发布Pentium 150MHz、Pentium 166MHz、Pentium 180MHz、Pentium 200MHz四款处理器，并且采用了0.60微米/0.35两种工艺技术,核心提升到由550万个晶体管组成。此时INTEL在以前设计基础上增加了L2 cache为256K和512K两种版本。\n\n1996年1月4日，英特尔又发布Pentium 150MHz、Pentium 166MHz两款处理器，采用了0.35微米工艺技术,不过核心由330万个晶体管组成。\n\n1996年6月10日，英特尔发布Pentium 200MHz处理器，采用了0.35微米工艺技术，不过核心还是由330万个晶体管组成。\n\n## 1996年：Intel Pentium Pro\n\nPentimuPro的内部含有高达550万个的晶体管，内部时钟频率为133MHz，处理速度几乎是100MHz的Pentium的2倍。PentimuPro的一级(片内)缓存为8KB指令和8KB数据。值得注意的是在PentimuPro的一个封装中除PentimuPro芯片外还包括有一个256KB的二级缓存芯片，两个芯片之间用高频宽的内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。PentiumPro 200MHz CPU的L2 Cache就是运行在200MHz，也就是工作在与处理器相同的频率上。这样的设计领PentiumPro达到了最高的性能。而PentimuPro最引人注目的地方是它具有一项称为“动态执行”的创新技术，这是继Pentium在[超标量体系结构](https://baike.baidu.com/item/%E8%B6%85%E6%A0%87%E9%87%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)上实现实破之后的又一次飞跃。PentimuPro系列的工作频率是150/166/180/200，一级缓存都是16KB，而前三者都有256KB的二级缓存，至于频率为200的CPU还分为三种版本，不同就在于他们的内置的缓存分别是256KB，512KB，1MB。\n\n## 1997年1月：Intel Pentium MMX\n\nPentium MMX芯片在X86指令集的基础上加入了57条多媒体指令。这些指令专门用来处理视频、音频和图象数据，使CPU在多媒体操作上具有更强大的处理能力，Pentium MMX还使用了许多新技术。单指令多数据流SIMD技术能够用一个指令并行处理多个数据，缩短了CPU在处理视频、音频、图形和动画时用于运算的时间；流水线从5级增加到6级，一级高速缓存扩充为16K，一个用于数据高速缓存，另一个用于指令高速缓存，因而速度大大加快；Pentium MMX还吸收了其他CPU的优秀处理技术，如分支预测技术和返回堆栈技术。\n\nPentium MMX等于是Pentium的加强版中央处理器芯片(CPU)，除了增加67个MMX(Multi-Media eXtension)指令以及64位数据型态之外之外，也将内建指令及数据暂存(Cache)从之前的8KB增加到16KB，内部工作电压降到2.8V。而英特尔之后的桌上型中央处理器皆包含了MMX指令。\n\n## 1997年：Intel Pentium Overdrive\n\nIntel Pentium OverDrive中央处理器芯片(CPU)，又是一项英特尔造福旧计算机使用者的升级选择。Pentium OverDrive有两种，一种(不含MMX，5V)是给80486升级用的，另一种(含MMX，3.3V)是给Pentium早期产品(Socket6, 50-66MHz)升级的。他们都有含散热器及风扇。\n\n## 1997-1998年：Pentium II\n\n1997年5月7日，英特尔发布Pentium II 233MHz、Pentium II 266MHz、Pentium II 300MHz三款PII处理器，采用了0.35微米工艺技术，核心提升到750万个晶体管组成。采用SLOT1架构，通过单边插接卡(SEC)与主板相连，SEC卡盒将CPU内核和二级高速缓存封装在一起，二级高速缓存的工作速度是处理器内核工作速度的一半；处理器采用了与Pentium PRO相同的动态执行技术，可以加速软件的执行；通过双重独立总线与系统总线相连，可进行多重数据交换，提高系统性能；PentiumII也包含MMX指令集。Intel此举希望用SLOT1构架的专利将AMD等一棍打死，可没想到Socket 7平台在以AMD的K6-2为首的处理器的支持下，走入了另一个春天。而从此开始，Intel也开始走上了一条前途不明的道路，开始频繁的强行制定自己的标准，企图借此达到迅速挤垮竞争对手的目的，但市场与用户的需要使得Intel开始不断的陷入被动和不利的局面。\n\n在这个时期100MHz频率的SDR内存已经出现在市场上，但是Intel却惊人地宣布他们将放弃并行内存而主推一种名为Rambus的内存，而一时间众多大公司如西门子、HP和DELL等都投入了Rambus的门下，不过后来DDR内存的流行也证明了Intel的失败。\n\n1997年6月2日，英特尔发布MMX指令技术的Pentium II 233MHz处理器，采用了0.35微米工艺技术,核心由450万个晶体管组成。\n\n1997年8月18日，英特尔发布L2 cache为1M的Pentium II 200MHz处理器，采用了0.35微米工艺技术,核心由550万个晶体管组成。\n\n1998年1月26日，英特尔发布Pentium II 333MHz处理器，采用了0.35微米工艺技术，核心由750万个晶体管组成。\n\n1998年4月15日，英特尔发布Pentium II 350MHz、Pentium II 400MHz和第一款Celeron 266MHz处理器，此三款CPU都采用了最新0.25微米工艺技术,核心由750万个晶体管组成。\n\n1998年8月24日，英特尔发布Pentium II 450MHz处理器，采用了0.25微米工艺技术,核心由750万个晶体管组成。\n\nCPU发展到这个时期，就不能不说说Intel Pentium II Cerelon处理器。英特尔将Celeron处理器的L2 Cache设定为只有Pentium II的一半(也就是128KB)，这样既有合理的效能，又有相对低廉的售价(有A字尾的)；这样的策略一直延续到今天。不过很快有人发现，使用双Celeron的系统与双Pentium II的系统差距不大，而价格却便宜很多，结果造成了Celeron冲击高阶市场的局面。后来英特尔决定取消Celeron处理器的SMP功能，才解决了这个问题。\n\n### Pentium II Celeron处理器\n\nCeleron（赛扬）300A，是一个让多少人闻之动容的产品，又陪伴了多少曾经年少的读者度过悠长的学生时代。赛扬300A，从某种意义上已经是Intel的第二代赛扬处理器。第一代的赛扬处理器仅仅拥有266MHz、300MHz两种版本，第一代的Celeron处理器由于不拥有任何的二级缓存，虽然有效的降低了成本，但是性能也无法让人满意。为了弥补性能上的不足，Intel终于首次推出带有二级缓存的赛扬处理器——采用Mendocino核心的Celeron300A、333、366。经典，从此诞生。\n\n## 1999年：Intel Pentium III\n\n1999年2月26日，英特尔发布Pentium III 450MHz、Pentium III 500MHz处理器，同时采用了0.25微米工艺技术,核心由950万个晶体管组成，从此Intel开始踏上了PIII旅程。\n\nPentium III是给桌上型计算机的中央处理器芯片(CPU)，等于是Pentium II的加强版，新增七十条新指令(SIMD，SSE)。Pentium III与Pentium II一样有Mobile、Xeon以及Cerelon等不同的版本。Celeron系列与Pentium III最大的差距在于二级缓存，100MHz外频的Tualatin Celeron 1GHz可以轻松地跃上133MHz外频。更为重要的是，Tualatin Celeron还有很好的向下兼容性，甚至440BX主板在使用转接卡之后也有望采用该CPU，因此也成为很多升级用户的首选。\n\n特别指出的是，Pentium III光是桌上型就拥有Katmai Slot 1 、Coppermine Slot 1以及Coppermine Socket 370等三种不同的系列。到后期，英特尔放弃插卡式界面而又回归到插槽界面(Socket 370)。socket370封装开始推出的时候，有一部分消费者舍弃了slot1平台而选择了新的处理器。新的PGA封装分为PPGA和FC-PGA两种，前者较为廉价，因而被赛扬处理器所采用，而更为昂贵的后者则被奔腾III处理器所采用。例外的是：采用Mendocino核心的赛扬处理器同时有这两种不同封装的版本。采用PPGA封装的赛扬处理器可以通过转接卡在slot1主板上使用，而采用FC-PGA封装的奔三处理器则无能为力了。\n\n## 2000年：Intel Pentium IV\n\nPentium 4处理器集成了4200万个晶体管，到了改进版的Pentium 4(Northwood)更是集成了5千5百万个晶体管；并且开始采用0.18微米进行制造，初始速度就达到了1.5GHz。\n\nPentium 4还提供的SSE2指令集，这套指令集增加144个全新的指令，在128bit压缩的数据，在SSE时，仅能以4个单精度浮点值的形式来处理，而在SSE2指令集，该资料能采用多种数据结构来处理：\n\n4个单精度浮点数(SSE)对应2个双精度浮点数(SSE2)，对应16字节数(SSE2)，对应8个字数(word)，对应4个双字数(SSE2)，对应2个四字数(SSE2)，对应1个128位长的整数(SSE2) 。\n\n## 2002-2004年：超线程P4处理器\n\n2002年11月14日，英特尔在全新英特尔奔腾4处理器3.06GHz上推出其创新超线程(Hyper-Threading，HT)技术。超线程(HT)技术支持全新级别的高性能台式机，同时快速运行多个计算应用，或为采用多线程的单独软件程序提供更多性能。超线程(HT)技术可将电脑性能提升达25%。除了为台式机用户引入超线程(HT)技术外，英特尔在推出英特尔奔腾4处理器3.06GHZ时达到了一个电脑里程碑。这是第一款商用微处理器，运行速率为每秒30亿周期，并且采用当时业界最先进的0.13微米制程制作。\n\n### P4处理器3.06GHz\n\n2003年，英特尔发布前端总线为533MHz的Pentium 4 3.06GHz处理器，采用了0.13微米工艺技术,提供512K的二级缓存，核心由5500万个晶体管组成。\n\n### P4处理器至尊版3.20GHz\n\n2004年初发布，该处理器可兼容现有的英特尔865和英特尔875芯片组家族产品以及标准系统内存。2MB三级高速缓存可以预先加载图形帧缓冲区或视频帧，以满足处理器随后的要求，使在访问内存和I/O设备时实现更高的吞吐率和更快的帧带率。最终，这可带来更逼真的游戏效果和改进的视频编辑性能。增强的CPU性能还可支持软件厂商创建完善的软件物理引擎，从而带来栩栩如生的人物动作和人工智能，使电脑控制的人物更加形象、逼真。\n\n半年之后，2004年6月，英特尔发布了P4 3.4GHz处理器，该处理器支持超线程(HT)技术，采用0.13微米制程，具备512KB二级高速缓存、2MB三级高速缓存和800MHz系统前端总线速度。\n\nNorthwood是第二代产品，采用0.13微米制程，具有电压低、体积小、温度低的优点。接着就是Prescott(0.09微米)，虽然这技术很新，不过由于效能提升并不明显，而且有过热的问题。后来英特尔又推出Hyper Threading技术，大大增加工作效率，让P4又成为市场宠儿。英特尔之后又推出Extreme Edition、含有Prestonia(原本给服务器用的Xeon核心)以及Gallatin(0.13微米Northwood外频提升改良版)核心的CPU。现在市场上的高阶Pentium 4则是Socket LGA 775的Prescott为主。\n\n## 2005-2006年：双核处理器\n\n2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了。双核和多核处理器设计用于在一枚处理器中集成两个或多个完整执行内核，以支持同时管理多项活动。英特尔超线程(HT)技术能够使一个执行内核发挥两枚逻辑处理器的作用，因此与该技术结合使用时，英特尔奔腾处理器至尊版840能够充分利用以前可能被闲置的资源，同时处理四个软件线程。\n\n### 英特尔奔腾D处理器\n\n5月，带有两个处理内核的英特尔奔腾D处理器随英特尔945高速芯片组家族一同推出，可带来某些消费电子产品的特性，例如：环绕立体声音频、高清晰度视频和增强图形功能。2006年1月，英特尔发布了Pentium D 9xx系列处理器，包括了支持VT虚拟化技术的Pentium D 960(3.60GHz)、950(3.40GHz)和不支持VT的Pentium D 945(3.4 GHz)、925(3GHz)(注：925不支持VT虚拟化技术)和915(2.80GHz)。\n\n### 英特尔酷睿2双核处理器\n\n2006年7月，英特尔公司面向家用和商用个人电脑与笔记本电脑，发布了十款全新英特尔酷睿2双核处理器和英特尔酷睿至尊处理器。英特尔酷睿2双核处理器家族包括五款专门针对企业、家庭、工作站和玩家(如高端游戏玩家)而定制的台式机处理器，以及五款专门针对移动生活而定制的处理器。英特尔酷睿2双核处理器设计用于提供出色的能效表现，并更快速地运行多种复杂应用，支持用户改进各种任务的处理，例如：更流畅地观看和播放高清晰度视频；在电子商务交易过程中更好地保护电脑及其资产；以及提供更耐久的电池使用时间和更加纤巧时尚的笔记本电脑外形。\n\n全新处理器可实现高达40%的性能提升，其能效比最出色的英特尔奔腾处理器高出40%。英特尔酷睿2双核处理器包含2.91亿个晶体管。不过，Pentium D谈不上是一套完美的双核架构，Intel只是将两个完全独立的CPU核心做在同一枚芯片上，通过同一条前端总线与芯片组相连。两个核心缺乏必要的协同和资源共享能力，而且还必须频繁地对二级缓存作同步化刷新动作，以避免两个核心的工作步调出问题。从这个意义上说，Pentium D带来的进步并没有人们预想得那么大！\n\n## 2011年：重新确定处理器产品架构\n\n2011年3月，使用32nm工艺全新桌面级和移动端处理器采用了i3、i5和i7的产品分级架构。其中i3主攻低端市场，采用双核处理器架构，约2MB二级缓存；i5处理器主攻主流市场，采用四核处理器架构，4MB二级缓存；i7主攻高端市场，采用四核八线程或六核十二线程架构，二级缓存不少于8MB。\n\n## 2012年：发布22纳米工艺和第三代处理器\n\n使用22nm工艺的处理器热功耗普遍小于77W，使得处理器的散热需求大幅下降，提升了大规模数据运算的可靠性，并降低了散热功耗。\n\n## 2014年：首发桌面级8核心16线程处理器\n\n2014年9月上市的i7-5960X处理器是第一款基于22nm工艺的八核心桌面级处理器，拥有高达20MB的三级缓存，主频达到3.5GHz，热功耗140W。此处理器的处理能力可谓超群，浮点数计算能力是普通办公电脑的10倍以上。随着这一“怪兽”处理器的问世，Intel公司在处理器领域与AMD的差距越拉越大，已经完全形成了一家独大的局面。\n\n \n\n## 寻址空间发展表\n\n摘自 [寻访x86处理器“实模式”和“保护模式”的前世今生](http://blog.chinaunix.net/uid-23069658-id-3569341.html)\n\n![img](http://images2017.cnblogs.com/blog/945387/201709/945387-20170906002916601-1518759142.png)\n\n \n\n##  参考资料：\n\n[Intel CPU发展简史](http://www.360doc.com/content/15/0411/07/21966267_462329844.shtml)\n\n百度百科资料","slug":"Intel-CPU-发展简史","published":1,"updated":"2017-09-08T17:00:02.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7omlvhs0002ckfyfsm3v9l6","content":"<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904124918632-83277658.png\" alt=\"img\"></p>\n<h2 id=\"1971年11月15日：4004\"><a href=\"#1971年11月15日：4004\" class=\"headerlink\" title=\"1971年11月15日：4004\"></a>1971年11月15日：4004</h2><p>1971年11月15日，Intel公司的工程师霍夫发明了世界上第一个商用微处理器—4004。这款4位微处理器集成了2250个晶体管，晶体管之间的距离是10微米，能够处理4bit的数据，每秒运算6万次，频率为108KHz，前端总线为0.74MHz （4bit）。原为日本Busicom公司的计数器开发。</p>\n<p>编号为4004，第一个“4”代表此芯片是客户订购的产品编号，后一个“4”代表此芯片是英特尔公司制作的第四个订制芯片，之前还有4001（动态内存DRAM）、4002（<a href=\"https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8\" target=\"_blank\" rel=\"external\">只读存储器</a>ROM）、4003（<a href=\"https://baike.baidu.com/item/Register/3414681\" target=\"_blank\" rel=\"external\">Register</a>），这种数字代号却延用至今。采用4004芯片后，再配用一块程序存储器，数据存储器，移位寄存器，再加上键盘和数码管，就构成了一台完整的微型计算机。</p>\n<p>4004的最高频率有740kHz，能执行4位运算，支持8位指令集及12位地址集。</p>\n<p>4004只能称为世界上第一款商用处理器，而不是世界上第一款微处理器。第一款微处理器应该是美国军方研制，用于F-14雄猫战机中由6颗晶片组成的中央空气数据计算机：CADC（CenterAir Data Computer），虽然它的构造比4004还要简单，速度只有9.15KHz。</p>\n<h2 id=\"1972年：8008\"><a href=\"#1972年：8008\" class=\"headerlink\" title=\"1972年：8008\"></a>1972年：8008</h2><p>8008频率为200KHz，晶体管的总数已经达到了3500个，能处理8比特的数据，性能是4004的两倍，速度为200KHz。更为重要的是，英特尔还首次获得了处理器的指令技术。</p>\n<p>8008芯片原本是为德克萨斯州的Datapoint公司设计的，但是这家公司最终却没有足够的财力支付这笔费用。于是双方达成协议，英特尔拥有这款芯片所有的知识产权，而且还获得了由Datapoint公司开发的指令集。这套指令集奠定了今天英特尔公司X86系列微处理器指令集的基础。</p>\n<p>执行8位运算，支持16位地址总线和16位数据总线。</p>\n<h2 id=\"1974年：8080\"><a href=\"#1974年：8080\" class=\"headerlink\" title=\"1974年：8080\"></a>1974年：8080</h2><p>在微处理器发展初期，具有革新意义的芯片非Intel8080莫属了。由于采用了复杂的指令集以及40管脚封装，8080的处理能力大为提高，其功能是8008的10倍，每秒能执行29万条指令，集成晶体管数目6000，运行速度2MHz。</p>\n<p>与此同时，微处理器的优势已经被业内人士所认同，于是更多的公司开始接入这一领域，竞争开始变得日益激烈。当时与英特尔同台竞技的有RCA(美国无线电公司)、Honeywell、Fairchild、美国国家半导体公司、AMD、摩托罗拉以及Zilog公司。值得一提的是Zilog，世界上第一块4004芯片的设计者Faggin就加盟了该公司。由该公司推出的Z80微处理器比Intel8080功能更为强大，而且直到今天这款处理器仍然被尊为经典。</p>\n<p>8080有幸成为了第一款个人计算机Altair的大脑。</p>\n<p>8位元处理器，拥有16位地址总线和8位数据总线，包含7个八位寄存器，支持16位寻址，同时也包含一些输入输出端口，有效解决了外部设备在内存寻址能力不足的问题。</p>\n<h2 id=\"1978年：8086-8088\"><a href=\"#1978年：8086-8088\" class=\"headerlink\" title=\"1978年：8086-8088\"></a>1978年：8086-8088</h2><p>1978年，英特尔推出了首枚16位微处理器8086，同时生产出与之配合的数学协处理器8087，这两种芯片使用相同的指令集，以后英特尔生产的处理器，均对其兼容。趁着市场销售正好的时机，以及市场需求的提升，Intel在同一年推出了性能更出色的8088处理器。三款处理器都拥有29000只晶体管，速度可分为5MHz、8MHz、10MHz，内部数据总线(处理器内部传输数据的总线)、外部数据总线(处理器外部传输数据的总线)均为16位，地址总线为20位，可寻址1MB内存。首次在商业市场给消费者提供了更自由选择。</p>\n<h2 id=\"1982年：80286\"><a href=\"#1982年：80286\" class=\"headerlink\" title=\"1982年：80286\"></a>1982年：80286</h2><p>80286(也称286)是处理器进入全新技术的标准产品，具备16位字长，集成了14.3万只晶体管，具有6MHz、8MHz、10MHz、12.5MHz四个主频的产品。286是Intel第一款具有完全兼容性的处理器，即可以运行所有针对其前代处理器编写的软件，这一软件兼容性也成为了Intel处理器家族一个恒久不变的特点。286是英特尔的最后一块16位处理器</p>\n<p>最大主频为20MHz，采用16位数据总线和24位地址总线。</p>\n<p>80286有两种工作模式：实模式和保护模式。在实模式下，80286直接访问内存的空间被限制在1M字节，更多内存需要通过EMS或XMS内存机制进行映射。而在保护模式下，80286可以直接访问16M字节的内存，并具有异常处理机制。</p>\n<h2 id=\"1985年：80386\"><a href=\"#1985年：80386\" class=\"headerlink\" title=\"1985年：80386\"></a>1985年：80386</h2><p>英特尔第一款32位处理器，集成了27万5千只晶体管，超过了4004芯片的一百倍，每秒可以处理500万条指令。同时也是第一款具有“多任务”功能的处理器，所谓“多任务”就是说它可以同时处理多个程序程序的指令，这对微软的操作系统发展有着重要的影响。</p>\n<p>重要特点：</p>\n<ol>\n<li>首次在x86处理器中实现了32位系统，</li>\n<li>可配合使用80387数字辅助处理器增强浮点运算能力</li>\n<li>首次采用高速缓存（外置）解决内存速度瓶颈问题。</li>\n</ol>\n<p>由于这些设计，80386的<a href=\"https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6\" target=\"_blank\" rel=\"external\">运算速度</a>达到了前代产品80286的数倍。80386DX的内部和外部数据总线（或资料汇流排）是32位，地址总线（或位址汇流排）也是32位，可以定址到4GB内存，并可以管理64TB的虚拟存储空间（虚拟存储空间：通过硬件和软件的综合来扩大用户可存储空间，它在内存储器和外存储器（磁盘、光盘）之间增加一定的硬件和软件支持，使两者形成一个有机整体，支持运行比实际配置的内存容量大的多的大任务程序）。</p>\n<p>80386有三种工作模式：实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M字节（也叫做位元组）；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。</p>\n<h2 id=\"Intel-RapidCAD-被遗忘的微处理器\"><a href=\"#Intel-RapidCAD-被遗忘的微处理器\" class=\"headerlink\" title=\"Intel RapidCAD 被遗忘的微处理器\"></a>Intel RapidCAD 被遗忘的微处理器</h2><p>RapidCAD是英特尔有史以来第一款为旧款个人计算机所提供的升级套件(也就是OverDrive的始祖)。原386的使用者不需要更换主机板，只要把RapidCAD买回来将主机板上旧有的中央处理器芯片(CPU)替换掉，就可以享受接近486的运算能力。RapidCAD其实就是把486 DX芯片去掉内部高速缓存然后装入386的封装里面，RapidCAD也不支持486增加的新指令。不过由于386封装的频宽限制，RapidCAD对整体的效能提升比不上直接升级到486 DX。相同频率下，486 DX可以有比386/387快上两倍的速度，而RapidCAD在整数运算方面最多只能提升35%，在浮点运算方面，则可以提升将近70%。</p>\n<p>Intel RapidCAD特殊的地方在于，它是由两颗芯片组成，缺一不可。这归咎于486 DX内建浮点运算器(FPU)，而386则是将浮点运算器分开(就是387)。由于RapidCAD-1本身就含有浮点运算器(因为它就是486 DX阉割版)，根本不需要387，所以RapidCAD-2就是用来替代原来主机板上的387芯片。RapidCAD-1负责所有的运算，而RapidCAD-2则是负责模拟浮点运算器，以防止旧有主机板以为没有安装浮点运算功能(尤其在执行286/287的程序时)。市面上有时候把RapidCAD-1与RapidCAD-2分开卖，这就是不了解RapidCAD运作方式的结果。</p>\n<h2 id=\"1989年：80486\"><a href=\"#1989年：80486\" class=\"headerlink\" title=\"1989年：80486\"></a>1989年：80486</h2><p>80486处理器集成了125万个晶体管，时钟频率由25MHz逐步提升到33MHz、40MHz、50MHz及后来的100MHz。486家族的指令集与386非常相似，只有增加少量的指令。</p>\n<p>486处理器的应用意味着用户从此摆脱了命令形式的计算机，进入“选中并点击(point-and-click)”的计算时代。英特尔486处理器首次采用内建的数学协处理器，将负载的数学运算功能从中央处理器中分离出来，从而显著加快了计算速度。</p>\n<p>386和486推向市场后，均大获成功，英特尔在芯片领域的霸主地位日益凸现。此后，英特尔开始告别微处理器数字编号时代，进入到了Pentium时代。</p>\n<h2 id=\"1994年3月10日：Intel-Pentium中央处理器芯片\"><a href=\"#1994年3月10日：Intel-Pentium中央处理器芯片\" class=\"headerlink\" title=\"1994年3月10日：Intel Pentium中央处理器芯片\"></a>1994年3月10日：Intel Pentium中央处理器芯片</h2><p>1993年，英特尔发布了Pentium(俗称586)中央处理器芯片(CPU)。本来按照惯常的命名规律是80586，但是在486发展末期，就已经有公司将486等级的产品标识成586来销售了。因此英特尔决定使用自创的品牌来作为新产品的商标—Pentium。</p>\n<p>英特尔奔腾处理器采用了0.60微米工艺技术制造，核心由320万个晶体管组成。支持计算机更轻松的集成“现实世界”数据，如语音、声音、手写体和图片等。</p>\n<p>Pentium是x86系列一大革新。其中晶体管数大幅提高、增强了浮点运算功能、并把十年未变的工作电压降至3.3V。Pentium刚推出的时候拥有浮点数除法不正确的错误(FDIV Bug)，导致英特尔大量回收第一代产品(1994年12月之前的产品)，所以有FDIV Bug的微处理器所剩不多。Pentium 50MHz也有这个FDIV错误，不过A80501-50只是业界样本，从来没有在市场上出现过。</p>\n<p>1995年3月27日，英特尔发布Pentium 120MHz处理器，采用了0.60微米/0.35两种工艺技术，不过核心依旧由320万个晶体管组成。</p>\n<p>1995年6月，英特尔发布Pentium 133MHz处理器，采用0.35工艺技术制造,核心提升到由330万个晶体管组成。</p>\n<p>1995年11月1日，英特尔发布Pentium 150MHz、Pentium 166MHz、Pentium 180MHz、Pentium 200MHz四款处理器，并且采用了0.60微米/0.35两种工艺技术,核心提升到由550万个晶体管组成。此时INTEL在以前设计基础上增加了L2 cache为256K和512K两种版本。</p>\n<p>1996年1月4日，英特尔又发布Pentium 150MHz、Pentium 166MHz两款处理器，采用了0.35微米工艺技术,不过核心由330万个晶体管组成。</p>\n<p>1996年6月10日，英特尔发布Pentium 200MHz处理器，采用了0.35微米工艺技术，不过核心还是由330万个晶体管组成。</p>\n<h2 id=\"1996年：Intel-Pentium-Pro\"><a href=\"#1996年：Intel-Pentium-Pro\" class=\"headerlink\" title=\"1996年：Intel Pentium Pro\"></a>1996年：Intel Pentium Pro</h2><p>PentimuPro的内部含有高达550万个的晶体管，内部时钟频率为133MHz，处理速度几乎是100MHz的Pentium的2倍。PentimuPro的一级(片内)缓存为8KB指令和8KB数据。值得注意的是在PentimuPro的一个封装中除PentimuPro芯片外还包括有一个256KB的二级缓存芯片，两个芯片之间用高频宽的内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。PentiumPro 200MHz CPU的L2 Cache就是运行在200MHz，也就是工作在与处理器相同的频率上。这样的设计领PentiumPro达到了最高的性能。而PentimuPro最引人注目的地方是它具有一项称为“动态执行”的创新技术，这是继Pentium在<a href=\"https://baike.baidu.com/item/%E8%B6%85%E6%A0%87%E9%87%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"external\">超标量体系结构</a>上实现实破之后的又一次飞跃。PentimuPro系列的工作频率是150/166/180/200，一级缓存都是16KB，而前三者都有256KB的二级缓存，至于频率为200的CPU还分为三种版本，不同就在于他们的内置的缓存分别是256KB，512KB，1MB。</p>\n<h2 id=\"1997年1月：Intel-Pentium-MMX\"><a href=\"#1997年1月：Intel-Pentium-MMX\" class=\"headerlink\" title=\"1997年1月：Intel Pentium MMX\"></a>1997年1月：Intel Pentium MMX</h2><p>Pentium MMX芯片在X86指令集的基础上加入了57条多媒体指令。这些指令专门用来处理视频、音频和图象数据，使CPU在多媒体操作上具有更强大的处理能力，Pentium MMX还使用了许多新技术。单指令多数据流SIMD技术能够用一个指令并行处理多个数据，缩短了CPU在处理视频、音频、图形和动画时用于运算的时间；流水线从5级增加到6级，一级高速缓存扩充为16K，一个用于数据高速缓存，另一个用于指令高速缓存，因而速度大大加快；Pentium MMX还吸收了其他CPU的优秀处理技术，如分支预测技术和返回堆栈技术。</p>\n<p>Pentium MMX等于是Pentium的加强版中央处理器芯片(CPU)，除了增加67个MMX(Multi-Media eXtension)指令以及64位数据型态之外之外，也将内建指令及数据暂存(Cache)从之前的8KB增加到16KB，内部工作电压降到2.8V。而英特尔之后的桌上型中央处理器皆包含了MMX指令。</p>\n<h2 id=\"1997年：Intel-Pentium-Overdrive\"><a href=\"#1997年：Intel-Pentium-Overdrive\" class=\"headerlink\" title=\"1997年：Intel Pentium Overdrive\"></a>1997年：Intel Pentium Overdrive</h2><p>Intel Pentium OverDrive中央处理器芯片(CPU)，又是一项英特尔造福旧计算机使用者的升级选择。Pentium OverDrive有两种，一种(不含MMX，5V)是给80486升级用的，另一种(含MMX，3.3V)是给Pentium早期产品(Socket6, 50-66MHz)升级的。他们都有含散热器及风扇。</p>\n<h2 id=\"1997-1998年：Pentium-II\"><a href=\"#1997-1998年：Pentium-II\" class=\"headerlink\" title=\"1997-1998年：Pentium II\"></a>1997-1998年：Pentium II</h2><p>1997年5月7日，英特尔发布Pentium II 233MHz、Pentium II 266MHz、Pentium II 300MHz三款PII处理器，采用了0.35微米工艺技术，核心提升到750万个晶体管组成。采用SLOT1架构，通过单边插接卡(SEC)与主板相连，SEC卡盒将CPU内核和二级高速缓存封装在一起，二级高速缓存的工作速度是处理器内核工作速度的一半；处理器采用了与Pentium PRO相同的动态执行技术，可以加速软件的执行；通过双重独立总线与系统总线相连，可进行多重数据交换，提高系统性能；PentiumII也包含MMX指令集。Intel此举希望用SLOT1构架的专利将AMD等一棍打死，可没想到Socket 7平台在以AMD的K6-2为首的处理器的支持下，走入了另一个春天。而从此开始，Intel也开始走上了一条前途不明的道路，开始频繁的强行制定自己的标准，企图借此达到迅速挤垮竞争对手的目的，但市场与用户的需要使得Intel开始不断的陷入被动和不利的局面。</p>\n<p>在这个时期100MHz频率的SDR内存已经出现在市场上，但是Intel却惊人地宣布他们将放弃并行内存而主推一种名为Rambus的内存，而一时间众多大公司如西门子、HP和DELL等都投入了Rambus的门下，不过后来DDR内存的流行也证明了Intel的失败。</p>\n<p>1997年6月2日，英特尔发布MMX指令技术的Pentium II 233MHz处理器，采用了0.35微米工艺技术,核心由450万个晶体管组成。</p>\n<p>1997年8月18日，英特尔发布L2 cache为1M的Pentium II 200MHz处理器，采用了0.35微米工艺技术,核心由550万个晶体管组成。</p>\n<p>1998年1月26日，英特尔发布Pentium II 333MHz处理器，采用了0.35微米工艺技术，核心由750万个晶体管组成。</p>\n<p>1998年4月15日，英特尔发布Pentium II 350MHz、Pentium II 400MHz和第一款Celeron 266MHz处理器，此三款CPU都采用了最新0.25微米工艺技术,核心由750万个晶体管组成。</p>\n<p>1998年8月24日，英特尔发布Pentium II 450MHz处理器，采用了0.25微米工艺技术,核心由750万个晶体管组成。</p>\n<p>CPU发展到这个时期，就不能不说说Intel Pentium II Cerelon处理器。英特尔将Celeron处理器的L2 Cache设定为只有Pentium II的一半(也就是128KB)，这样既有合理的效能，又有相对低廉的售价(有A字尾的)；这样的策略一直延续到今天。不过很快有人发现，使用双Celeron的系统与双Pentium II的系统差距不大，而价格却便宜很多，结果造成了Celeron冲击高阶市场的局面。后来英特尔决定取消Celeron处理器的SMP功能，才解决了这个问题。</p>\n<h3 id=\"Pentium-II-Celeron处理器\"><a href=\"#Pentium-II-Celeron处理器\" class=\"headerlink\" title=\"Pentium II Celeron处理器\"></a>Pentium II Celeron处理器</h3><p>Celeron（赛扬）300A，是一个让多少人闻之动容的产品，又陪伴了多少曾经年少的读者度过悠长的学生时代。赛扬300A，从某种意义上已经是Intel的第二代赛扬处理器。第一代的赛扬处理器仅仅拥有266MHz、300MHz两种版本，第一代的Celeron处理器由于不拥有任何的二级缓存，虽然有效的降低了成本，但是性能也无法让人满意。为了弥补性能上的不足，Intel终于首次推出带有二级缓存的赛扬处理器——采用Mendocino核心的Celeron300A、333、366。经典，从此诞生。</p>\n<h2 id=\"1999年：Intel-Pentium-III\"><a href=\"#1999年：Intel-Pentium-III\" class=\"headerlink\" title=\"1999年：Intel Pentium III\"></a>1999年：Intel Pentium III</h2><p>1999年2月26日，英特尔发布Pentium III 450MHz、Pentium III 500MHz处理器，同时采用了0.25微米工艺技术,核心由950万个晶体管组成，从此Intel开始踏上了PIII旅程。</p>\n<p>Pentium III是给桌上型计算机的中央处理器芯片(CPU)，等于是Pentium II的加强版，新增七十条新指令(SIMD，SSE)。Pentium III与Pentium II一样有Mobile、Xeon以及Cerelon等不同的版本。Celeron系列与Pentium III最大的差距在于二级缓存，100MHz外频的Tualatin Celeron 1GHz可以轻松地跃上133MHz外频。更为重要的是，Tualatin Celeron还有很好的向下兼容性，甚至440BX主板在使用转接卡之后也有望采用该CPU，因此也成为很多升级用户的首选。</p>\n<p>特别指出的是，Pentium III光是桌上型就拥有Katmai Slot 1 、Coppermine Slot 1以及Coppermine Socket 370等三种不同的系列。到后期，英特尔放弃插卡式界面而又回归到插槽界面(Socket 370)。socket370封装开始推出的时候，有一部分消费者舍弃了slot1平台而选择了新的处理器。新的PGA封装分为PPGA和FC-PGA两种，前者较为廉价，因而被赛扬处理器所采用，而更为昂贵的后者则被奔腾III处理器所采用。例外的是：采用Mendocino核心的赛扬处理器同时有这两种不同封装的版本。采用PPGA封装的赛扬处理器可以通过转接卡在slot1主板上使用，而采用FC-PGA封装的奔三处理器则无能为力了。</p>\n<h2 id=\"2000年：Intel-Pentium-IV\"><a href=\"#2000年：Intel-Pentium-IV\" class=\"headerlink\" title=\"2000年：Intel Pentium IV\"></a>2000年：Intel Pentium IV</h2><p>Pentium 4处理器集成了4200万个晶体管，到了改进版的Pentium 4(Northwood)更是集成了5千5百万个晶体管；并且开始采用0.18微米进行制造，初始速度就达到了1.5GHz。</p>\n<p>Pentium 4还提供的SSE2指令集，这套指令集增加144个全新的指令，在128bit压缩的数据，在SSE时，仅能以4个单精度浮点值的形式来处理，而在SSE2指令集，该资料能采用多种数据结构来处理：</p>\n<p>4个单精度浮点数(SSE)对应2个双精度浮点数(SSE2)，对应16字节数(SSE2)，对应8个字数(word)，对应4个双字数(SSE2)，对应2个四字数(SSE2)，对应1个128位长的整数(SSE2) 。</p>\n<h2 id=\"2002-2004年：超线程P4处理器\"><a href=\"#2002-2004年：超线程P4处理器\" class=\"headerlink\" title=\"2002-2004年：超线程P4处理器\"></a>2002-2004年：超线程P4处理器</h2><p>2002年11月14日，英特尔在全新英特尔奔腾4处理器3.06GHz上推出其创新超线程(Hyper-Threading，HT)技术。超线程(HT)技术支持全新级别的高性能台式机，同时快速运行多个计算应用，或为采用多线程的单独软件程序提供更多性能。超线程(HT)技术可将电脑性能提升达25%。除了为台式机用户引入超线程(HT)技术外，英特尔在推出英特尔奔腾4处理器3.06GHZ时达到了一个电脑里程碑。这是第一款商用微处理器，运行速率为每秒30亿周期，并且采用当时业界最先进的0.13微米制程制作。</p>\n<h3 id=\"P4处理器3-06GHz\"><a href=\"#P4处理器3-06GHz\" class=\"headerlink\" title=\"P4处理器3.06GHz\"></a>P4处理器3.06GHz</h3><p>2003年，英特尔发布前端总线为533MHz的Pentium 4 3.06GHz处理器，采用了0.13微米工艺技术,提供512K的二级缓存，核心由5500万个晶体管组成。</p>\n<h3 id=\"P4处理器至尊版3-20GHz\"><a href=\"#P4处理器至尊版3-20GHz\" class=\"headerlink\" title=\"P4处理器至尊版3.20GHz\"></a>P4处理器至尊版3.20GHz</h3><p>2004年初发布，该处理器可兼容现有的英特尔865和英特尔875芯片组家族产品以及标准系统内存。2MB三级高速缓存可以预先加载图形帧缓冲区或视频帧，以满足处理器随后的要求，使在访问内存和I/O设备时实现更高的吞吐率和更快的帧带率。最终，这可带来更逼真的游戏效果和改进的视频编辑性能。增强的CPU性能还可支持软件厂商创建完善的软件物理引擎，从而带来栩栩如生的人物动作和人工智能，使电脑控制的人物更加形象、逼真。</p>\n<p>半年之后，2004年6月，英特尔发布了P4 3.4GHz处理器，该处理器支持超线程(HT)技术，采用0.13微米制程，具备512KB二级高速缓存、2MB三级高速缓存和800MHz系统前端总线速度。</p>\n<p>Northwood是第二代产品，采用0.13微米制程，具有电压低、体积小、温度低的优点。接着就是Prescott(0.09微米)，虽然这技术很新，不过由于效能提升并不明显，而且有过热的问题。后来英特尔又推出Hyper Threading技术，大大增加工作效率，让P4又成为市场宠儿。英特尔之后又推出Extreme Edition、含有Prestonia(原本给服务器用的Xeon核心)以及Gallatin(0.13微米Northwood外频提升改良版)核心的CPU。现在市场上的高阶Pentium 4则是Socket LGA 775的Prescott为主。</p>\n<h2 id=\"2005-2006年：双核处理器\"><a href=\"#2005-2006年：双核处理器\" class=\"headerlink\" title=\"2005-2006年：双核处理器\"></a>2005-2006年：双核处理器</h2><p>2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了。双核和多核处理器设计用于在一枚处理器中集成两个或多个完整执行内核，以支持同时管理多项活动。英特尔超线程(HT)技术能够使一个执行内核发挥两枚逻辑处理器的作用，因此与该技术结合使用时，英特尔奔腾处理器至尊版840能够充分利用以前可能被闲置的资源，同时处理四个软件线程。</p>\n<h3 id=\"英特尔奔腾D处理器\"><a href=\"#英特尔奔腾D处理器\" class=\"headerlink\" title=\"英特尔奔腾D处理器\"></a>英特尔奔腾D处理器</h3><p>5月，带有两个处理内核的英特尔奔腾D处理器随英特尔945高速芯片组家族一同推出，可带来某些消费电子产品的特性，例如：环绕立体声音频、高清晰度视频和增强图形功能。2006年1月，英特尔发布了Pentium D 9xx系列处理器，包括了支持VT虚拟化技术的Pentium D 960(3.60GHz)、950(3.40GHz)和不支持VT的Pentium D 945(3.4 GHz)、925(3GHz)(注：925不支持VT虚拟化技术)和915(2.80GHz)。</p>\n<h3 id=\"英特尔酷睿2双核处理器\"><a href=\"#英特尔酷睿2双核处理器\" class=\"headerlink\" title=\"英特尔酷睿2双核处理器\"></a>英特尔酷睿2双核处理器</h3><p>2006年7月，英特尔公司面向家用和商用个人电脑与笔记本电脑，发布了十款全新英特尔酷睿2双核处理器和英特尔酷睿至尊处理器。英特尔酷睿2双核处理器家族包括五款专门针对企业、家庭、工作站和玩家(如高端游戏玩家)而定制的台式机处理器，以及五款专门针对移动生活而定制的处理器。英特尔酷睿2双核处理器设计用于提供出色的能效表现，并更快速地运行多种复杂应用，支持用户改进各种任务的处理，例如：更流畅地观看和播放高清晰度视频；在电子商务交易过程中更好地保护电脑及其资产；以及提供更耐久的电池使用时间和更加纤巧时尚的笔记本电脑外形。</p>\n<p>全新处理器可实现高达40%的性能提升，其能效比最出色的英特尔奔腾处理器高出40%。英特尔酷睿2双核处理器包含2.91亿个晶体管。不过，Pentium D谈不上是一套完美的双核架构，Intel只是将两个完全独立的CPU核心做在同一枚芯片上，通过同一条前端总线与芯片组相连。两个核心缺乏必要的协同和资源共享能力，而且还必须频繁地对二级缓存作同步化刷新动作，以避免两个核心的工作步调出问题。从这个意义上说，Pentium D带来的进步并没有人们预想得那么大！</p>\n<h2 id=\"2011年：重新确定处理器产品架构\"><a href=\"#2011年：重新确定处理器产品架构\" class=\"headerlink\" title=\"2011年：重新确定处理器产品架构\"></a>2011年：重新确定处理器产品架构</h2><p>2011年3月，使用32nm工艺全新桌面级和移动端处理器采用了i3、i5和i7的产品分级架构。其中i3主攻低端市场，采用双核处理器架构，约2MB二级缓存；i5处理器主攻主流市场，采用四核处理器架构，4MB二级缓存；i7主攻高端市场，采用四核八线程或六核十二线程架构，二级缓存不少于8MB。</p>\n<h2 id=\"2012年：发布22纳米工艺和第三代处理器\"><a href=\"#2012年：发布22纳米工艺和第三代处理器\" class=\"headerlink\" title=\"2012年：发布22纳米工艺和第三代处理器\"></a>2012年：发布22纳米工艺和第三代处理器</h2><p>使用22nm工艺的处理器热功耗普遍小于77W，使得处理器的散热需求大幅下降，提升了大规模数据运算的可靠性，并降低了散热功耗。</p>\n<h2 id=\"2014年：首发桌面级8核心16线程处理器\"><a href=\"#2014年：首发桌面级8核心16线程处理器\" class=\"headerlink\" title=\"2014年：首发桌面级8核心16线程处理器\"></a>2014年：首发桌面级8核心16线程处理器</h2><p>2014年9月上市的i7-5960X处理器是第一款基于22nm工艺的八核心桌面级处理器，拥有高达20MB的三级缓存，主频达到3.5GHz，热功耗140W。此处理器的处理能力可谓超群，浮点数计算能力是普通办公电脑的10倍以上。随着这一“怪兽”处理器的问世，Intel公司在处理器领域与AMD的差距越拉越大，已经完全形成了一家独大的局面。</p>\n<h2 id=\"寻址空间发展表\"><a href=\"#寻址空间发展表\" class=\"headerlink\" title=\"寻址空间发展表\"></a>寻址空间发展表</h2><p>摘自 <a href=\"http://blog.chinaunix.net/uid-23069658-id-3569341.html\" target=\"_blank\" rel=\"external\">寻访x86处理器“实模式”和“保护模式”的前世今生</a></p>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170906002916601-1518759142.png\" alt=\"img\"></p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><a href=\"http://www.360doc.com/content/15/0411/07/21966267_462329844.shtml\" target=\"_blank\" rel=\"external\">Intel CPU发展简史</a></p>\n<p>百度百科资料</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170904124918632-83277658.png\" alt=\"img\"></p>\n<h2 id=\"1971年11月15日：4004\"><a href=\"#1971年11月15日：4004\" class=\"headerlink\" title=\"1971年11月15日：4004\"></a>1971年11月15日：4004</h2><p>1971年11月15日，Intel公司的工程师霍夫发明了世界上第一个商用微处理器—4004。这款4位微处理器集成了2250个晶体管，晶体管之间的距离是10微米，能够处理4bit的数据，每秒运算6万次，频率为108KHz，前端总线为0.74MHz （4bit）。原为日本Busicom公司的计数器开发。</p>\n<p>编号为4004，第一个“4”代表此芯片是客户订购的产品编号，后一个“4”代表此芯片是英特尔公司制作的第四个订制芯片，之前还有4001（动态内存DRAM）、4002（<a href=\"https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8\" target=\"_blank\" rel=\"external\">只读存储器</a>ROM）、4003（<a href=\"https://baike.baidu.com/item/Register/3414681\" target=\"_blank\" rel=\"external\">Register</a>），这种数字代号却延用至今。采用4004芯片后，再配用一块程序存储器，数据存储器，移位寄存器，再加上键盘和数码管，就构成了一台完整的微型计算机。</p>\n<p>4004的最高频率有740kHz，能执行4位运算，支持8位指令集及12位地址集。</p>\n<p>4004只能称为世界上第一款商用处理器，而不是世界上第一款微处理器。第一款微处理器应该是美国军方研制，用于F-14雄猫战机中由6颗晶片组成的中央空气数据计算机：CADC（CenterAir Data Computer），虽然它的构造比4004还要简单，速度只有9.15KHz。</p>\n<h2 id=\"1972年：8008\"><a href=\"#1972年：8008\" class=\"headerlink\" title=\"1972年：8008\"></a>1972年：8008</h2><p>8008频率为200KHz，晶体管的总数已经达到了3500个，能处理8比特的数据，性能是4004的两倍，速度为200KHz。更为重要的是，英特尔还首次获得了处理器的指令技术。</p>\n<p>8008芯片原本是为德克萨斯州的Datapoint公司设计的，但是这家公司最终却没有足够的财力支付这笔费用。于是双方达成协议，英特尔拥有这款芯片所有的知识产权，而且还获得了由Datapoint公司开发的指令集。这套指令集奠定了今天英特尔公司X86系列微处理器指令集的基础。</p>\n<p>执行8位运算，支持16位地址总线和16位数据总线。</p>\n<h2 id=\"1974年：8080\"><a href=\"#1974年：8080\" class=\"headerlink\" title=\"1974年：8080\"></a>1974年：8080</h2><p>在微处理器发展初期，具有革新意义的芯片非Intel8080莫属了。由于采用了复杂的指令集以及40管脚封装，8080的处理能力大为提高，其功能是8008的10倍，每秒能执行29万条指令，集成晶体管数目6000，运行速度2MHz。</p>\n<p>与此同时，微处理器的优势已经被业内人士所认同，于是更多的公司开始接入这一领域，竞争开始变得日益激烈。当时与英特尔同台竞技的有RCA(美国无线电公司)、Honeywell、Fairchild、美国国家半导体公司、AMD、摩托罗拉以及Zilog公司。值得一提的是Zilog，世界上第一块4004芯片的设计者Faggin就加盟了该公司。由该公司推出的Z80微处理器比Intel8080功能更为强大，而且直到今天这款处理器仍然被尊为经典。</p>\n<p>8080有幸成为了第一款个人计算机Altair的大脑。</p>\n<p>8位元处理器，拥有16位地址总线和8位数据总线，包含7个八位寄存器，支持16位寻址，同时也包含一些输入输出端口，有效解决了外部设备在内存寻址能力不足的问题。</p>\n<h2 id=\"1978年：8086-8088\"><a href=\"#1978年：8086-8088\" class=\"headerlink\" title=\"1978年：8086-8088\"></a>1978年：8086-8088</h2><p>1978年，英特尔推出了首枚16位微处理器8086，同时生产出与之配合的数学协处理器8087，这两种芯片使用相同的指令集，以后英特尔生产的处理器，均对其兼容。趁着市场销售正好的时机，以及市场需求的提升，Intel在同一年推出了性能更出色的8088处理器。三款处理器都拥有29000只晶体管，速度可分为5MHz、8MHz、10MHz，内部数据总线(处理器内部传输数据的总线)、外部数据总线(处理器外部传输数据的总线)均为16位，地址总线为20位，可寻址1MB内存。首次在商业市场给消费者提供了更自由选择。</p>\n<h2 id=\"1982年：80286\"><a href=\"#1982年：80286\" class=\"headerlink\" title=\"1982年：80286\"></a>1982年：80286</h2><p>80286(也称286)是处理器进入全新技术的标准产品，具备16位字长，集成了14.3万只晶体管，具有6MHz、8MHz、10MHz、12.5MHz四个主频的产品。286是Intel第一款具有完全兼容性的处理器，即可以运行所有针对其前代处理器编写的软件，这一软件兼容性也成为了Intel处理器家族一个恒久不变的特点。286是英特尔的最后一块16位处理器</p>\n<p>最大主频为20MHz，采用16位数据总线和24位地址总线。</p>\n<p>80286有两种工作模式：实模式和保护模式。在实模式下，80286直接访问内存的空间被限制在1M字节，更多内存需要通过EMS或XMS内存机制进行映射。而在保护模式下，80286可以直接访问16M字节的内存，并具有异常处理机制。</p>\n<h2 id=\"1985年：80386\"><a href=\"#1985年：80386\" class=\"headerlink\" title=\"1985年：80386\"></a>1985年：80386</h2><p>英特尔第一款32位处理器，集成了27万5千只晶体管，超过了4004芯片的一百倍，每秒可以处理500万条指令。同时也是第一款具有“多任务”功能的处理器，所谓“多任务”就是说它可以同时处理多个程序程序的指令，这对微软的操作系统发展有着重要的影响。</p>\n<p>重要特点：</p>\n<ol>\n<li>首次在x86处理器中实现了32位系统，</li>\n<li>可配合使用80387数字辅助处理器增强浮点运算能力</li>\n<li>首次采用高速缓存（外置）解决内存速度瓶颈问题。</li>\n</ol>\n<p>由于这些设计，80386的<a href=\"https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6\" target=\"_blank\" rel=\"external\">运算速度</a>达到了前代产品80286的数倍。80386DX的内部和外部数据总线（或资料汇流排）是32位，地址总线（或位址汇流排）也是32位，可以定址到4GB内存，并可以管理64TB的虚拟存储空间（虚拟存储空间：通过硬件和软件的综合来扩大用户可存储空间，它在内存储器和外存储器（磁盘、光盘）之间增加一定的硬件和软件支持，使两者形成一个有机整体，支持运行比实际配置的内存容量大的多的大任务程序）。</p>\n<p>80386有三种工作模式：实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M字节（也叫做位元组）；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。</p>\n<h2 id=\"Intel-RapidCAD-被遗忘的微处理器\"><a href=\"#Intel-RapidCAD-被遗忘的微处理器\" class=\"headerlink\" title=\"Intel RapidCAD 被遗忘的微处理器\"></a>Intel RapidCAD 被遗忘的微处理器</h2><p>RapidCAD是英特尔有史以来第一款为旧款个人计算机所提供的升级套件(也就是OverDrive的始祖)。原386的使用者不需要更换主机板，只要把RapidCAD买回来将主机板上旧有的中央处理器芯片(CPU)替换掉，就可以享受接近486的运算能力。RapidCAD其实就是把486 DX芯片去掉内部高速缓存然后装入386的封装里面，RapidCAD也不支持486增加的新指令。不过由于386封装的频宽限制，RapidCAD对整体的效能提升比不上直接升级到486 DX。相同频率下，486 DX可以有比386/387快上两倍的速度，而RapidCAD在整数运算方面最多只能提升35%，在浮点运算方面，则可以提升将近70%。</p>\n<p>Intel RapidCAD特殊的地方在于，它是由两颗芯片组成，缺一不可。这归咎于486 DX内建浮点运算器(FPU)，而386则是将浮点运算器分开(就是387)。由于RapidCAD-1本身就含有浮点运算器(因为它就是486 DX阉割版)，根本不需要387，所以RapidCAD-2就是用来替代原来主机板上的387芯片。RapidCAD-1负责所有的运算，而RapidCAD-2则是负责模拟浮点运算器，以防止旧有主机板以为没有安装浮点运算功能(尤其在执行286/287的程序时)。市面上有时候把RapidCAD-1与RapidCAD-2分开卖，这就是不了解RapidCAD运作方式的结果。</p>\n<h2 id=\"1989年：80486\"><a href=\"#1989年：80486\" class=\"headerlink\" title=\"1989年：80486\"></a>1989年：80486</h2><p>80486处理器集成了125万个晶体管，时钟频率由25MHz逐步提升到33MHz、40MHz、50MHz及后来的100MHz。486家族的指令集与386非常相似，只有增加少量的指令。</p>\n<p>486处理器的应用意味着用户从此摆脱了命令形式的计算机，进入“选中并点击(point-and-click)”的计算时代。英特尔486处理器首次采用内建的数学协处理器，将负载的数学运算功能从中央处理器中分离出来，从而显著加快了计算速度。</p>\n<p>386和486推向市场后，均大获成功，英特尔在芯片领域的霸主地位日益凸现。此后，英特尔开始告别微处理器数字编号时代，进入到了Pentium时代。</p>\n<h2 id=\"1994年3月10日：Intel-Pentium中央处理器芯片\"><a href=\"#1994年3月10日：Intel-Pentium中央处理器芯片\" class=\"headerlink\" title=\"1994年3月10日：Intel Pentium中央处理器芯片\"></a>1994年3月10日：Intel Pentium中央处理器芯片</h2><p>1993年，英特尔发布了Pentium(俗称586)中央处理器芯片(CPU)。本来按照惯常的命名规律是80586，但是在486发展末期，就已经有公司将486等级的产品标识成586来销售了。因此英特尔决定使用自创的品牌来作为新产品的商标—Pentium。</p>\n<p>英特尔奔腾处理器采用了0.60微米工艺技术制造，核心由320万个晶体管组成。支持计算机更轻松的集成“现实世界”数据，如语音、声音、手写体和图片等。</p>\n<p>Pentium是x86系列一大革新。其中晶体管数大幅提高、增强了浮点运算功能、并把十年未变的工作电压降至3.3V。Pentium刚推出的时候拥有浮点数除法不正确的错误(FDIV Bug)，导致英特尔大量回收第一代产品(1994年12月之前的产品)，所以有FDIV Bug的微处理器所剩不多。Pentium 50MHz也有这个FDIV错误，不过A80501-50只是业界样本，从来没有在市场上出现过。</p>\n<p>1995年3月27日，英特尔发布Pentium 120MHz处理器，采用了0.60微米/0.35两种工艺技术，不过核心依旧由320万个晶体管组成。</p>\n<p>1995年6月，英特尔发布Pentium 133MHz处理器，采用0.35工艺技术制造,核心提升到由330万个晶体管组成。</p>\n<p>1995年11月1日，英特尔发布Pentium 150MHz、Pentium 166MHz、Pentium 180MHz、Pentium 200MHz四款处理器，并且采用了0.60微米/0.35两种工艺技术,核心提升到由550万个晶体管组成。此时INTEL在以前设计基础上增加了L2 cache为256K和512K两种版本。</p>\n<p>1996年1月4日，英特尔又发布Pentium 150MHz、Pentium 166MHz两款处理器，采用了0.35微米工艺技术,不过核心由330万个晶体管组成。</p>\n<p>1996年6月10日，英特尔发布Pentium 200MHz处理器，采用了0.35微米工艺技术，不过核心还是由330万个晶体管组成。</p>\n<h2 id=\"1996年：Intel-Pentium-Pro\"><a href=\"#1996年：Intel-Pentium-Pro\" class=\"headerlink\" title=\"1996年：Intel Pentium Pro\"></a>1996年：Intel Pentium Pro</h2><p>PentimuPro的内部含有高达550万个的晶体管，内部时钟频率为133MHz，处理速度几乎是100MHz的Pentium的2倍。PentimuPro的一级(片内)缓存为8KB指令和8KB数据。值得注意的是在PentimuPro的一个封装中除PentimuPro芯片外还包括有一个256KB的二级缓存芯片，两个芯片之间用高频宽的内部通讯总线互连，处理器与高速缓存的连接线路也被安置在该封装中，这样就使高速缓存能更容易地运行在更高的频率上。PentiumPro 200MHz CPU的L2 Cache就是运行在200MHz，也就是工作在与处理器相同的频率上。这样的设计领PentiumPro达到了最高的性能。而PentimuPro最引人注目的地方是它具有一项称为“动态执行”的创新技术，这是继Pentium在<a href=\"https://baike.baidu.com/item/%E8%B6%85%E6%A0%87%E9%87%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"external\">超标量体系结构</a>上实现实破之后的又一次飞跃。PentimuPro系列的工作频率是150/166/180/200，一级缓存都是16KB，而前三者都有256KB的二级缓存，至于频率为200的CPU还分为三种版本，不同就在于他们的内置的缓存分别是256KB，512KB，1MB。</p>\n<h2 id=\"1997年1月：Intel-Pentium-MMX\"><a href=\"#1997年1月：Intel-Pentium-MMX\" class=\"headerlink\" title=\"1997年1月：Intel Pentium MMX\"></a>1997年1月：Intel Pentium MMX</h2><p>Pentium MMX芯片在X86指令集的基础上加入了57条多媒体指令。这些指令专门用来处理视频、音频和图象数据，使CPU在多媒体操作上具有更强大的处理能力，Pentium MMX还使用了许多新技术。单指令多数据流SIMD技术能够用一个指令并行处理多个数据，缩短了CPU在处理视频、音频、图形和动画时用于运算的时间；流水线从5级增加到6级，一级高速缓存扩充为16K，一个用于数据高速缓存，另一个用于指令高速缓存，因而速度大大加快；Pentium MMX还吸收了其他CPU的优秀处理技术，如分支预测技术和返回堆栈技术。</p>\n<p>Pentium MMX等于是Pentium的加强版中央处理器芯片(CPU)，除了增加67个MMX(Multi-Media eXtension)指令以及64位数据型态之外之外，也将内建指令及数据暂存(Cache)从之前的8KB增加到16KB，内部工作电压降到2.8V。而英特尔之后的桌上型中央处理器皆包含了MMX指令。</p>\n<h2 id=\"1997年：Intel-Pentium-Overdrive\"><a href=\"#1997年：Intel-Pentium-Overdrive\" class=\"headerlink\" title=\"1997年：Intel Pentium Overdrive\"></a>1997年：Intel Pentium Overdrive</h2><p>Intel Pentium OverDrive中央处理器芯片(CPU)，又是一项英特尔造福旧计算机使用者的升级选择。Pentium OverDrive有两种，一种(不含MMX，5V)是给80486升级用的，另一种(含MMX，3.3V)是给Pentium早期产品(Socket6, 50-66MHz)升级的。他们都有含散热器及风扇。</p>\n<h2 id=\"1997-1998年：Pentium-II\"><a href=\"#1997-1998年：Pentium-II\" class=\"headerlink\" title=\"1997-1998年：Pentium II\"></a>1997-1998年：Pentium II</h2><p>1997年5月7日，英特尔发布Pentium II 233MHz、Pentium II 266MHz、Pentium II 300MHz三款PII处理器，采用了0.35微米工艺技术，核心提升到750万个晶体管组成。采用SLOT1架构，通过单边插接卡(SEC)与主板相连，SEC卡盒将CPU内核和二级高速缓存封装在一起，二级高速缓存的工作速度是处理器内核工作速度的一半；处理器采用了与Pentium PRO相同的动态执行技术，可以加速软件的执行；通过双重独立总线与系统总线相连，可进行多重数据交换，提高系统性能；PentiumII也包含MMX指令集。Intel此举希望用SLOT1构架的专利将AMD等一棍打死，可没想到Socket 7平台在以AMD的K6-2为首的处理器的支持下，走入了另一个春天。而从此开始，Intel也开始走上了一条前途不明的道路，开始频繁的强行制定自己的标准，企图借此达到迅速挤垮竞争对手的目的，但市场与用户的需要使得Intel开始不断的陷入被动和不利的局面。</p>\n<p>在这个时期100MHz频率的SDR内存已经出现在市场上，但是Intel却惊人地宣布他们将放弃并行内存而主推一种名为Rambus的内存，而一时间众多大公司如西门子、HP和DELL等都投入了Rambus的门下，不过后来DDR内存的流行也证明了Intel的失败。</p>\n<p>1997年6月2日，英特尔发布MMX指令技术的Pentium II 233MHz处理器，采用了0.35微米工艺技术,核心由450万个晶体管组成。</p>\n<p>1997年8月18日，英特尔发布L2 cache为1M的Pentium II 200MHz处理器，采用了0.35微米工艺技术,核心由550万个晶体管组成。</p>\n<p>1998年1月26日，英特尔发布Pentium II 333MHz处理器，采用了0.35微米工艺技术，核心由750万个晶体管组成。</p>\n<p>1998年4月15日，英特尔发布Pentium II 350MHz、Pentium II 400MHz和第一款Celeron 266MHz处理器，此三款CPU都采用了最新0.25微米工艺技术,核心由750万个晶体管组成。</p>\n<p>1998年8月24日，英特尔发布Pentium II 450MHz处理器，采用了0.25微米工艺技术,核心由750万个晶体管组成。</p>\n<p>CPU发展到这个时期，就不能不说说Intel Pentium II Cerelon处理器。英特尔将Celeron处理器的L2 Cache设定为只有Pentium II的一半(也就是128KB)，这样既有合理的效能，又有相对低廉的售价(有A字尾的)；这样的策略一直延续到今天。不过很快有人发现，使用双Celeron的系统与双Pentium II的系统差距不大，而价格却便宜很多，结果造成了Celeron冲击高阶市场的局面。后来英特尔决定取消Celeron处理器的SMP功能，才解决了这个问题。</p>\n<h3 id=\"Pentium-II-Celeron处理器\"><a href=\"#Pentium-II-Celeron处理器\" class=\"headerlink\" title=\"Pentium II Celeron处理器\"></a>Pentium II Celeron处理器</h3><p>Celeron（赛扬）300A，是一个让多少人闻之动容的产品，又陪伴了多少曾经年少的读者度过悠长的学生时代。赛扬300A，从某种意义上已经是Intel的第二代赛扬处理器。第一代的赛扬处理器仅仅拥有266MHz、300MHz两种版本，第一代的Celeron处理器由于不拥有任何的二级缓存，虽然有效的降低了成本，但是性能也无法让人满意。为了弥补性能上的不足，Intel终于首次推出带有二级缓存的赛扬处理器——采用Mendocino核心的Celeron300A、333、366。经典，从此诞生。</p>\n<h2 id=\"1999年：Intel-Pentium-III\"><a href=\"#1999年：Intel-Pentium-III\" class=\"headerlink\" title=\"1999年：Intel Pentium III\"></a>1999年：Intel Pentium III</h2><p>1999年2月26日，英特尔发布Pentium III 450MHz、Pentium III 500MHz处理器，同时采用了0.25微米工艺技术,核心由950万个晶体管组成，从此Intel开始踏上了PIII旅程。</p>\n<p>Pentium III是给桌上型计算机的中央处理器芯片(CPU)，等于是Pentium II的加强版，新增七十条新指令(SIMD，SSE)。Pentium III与Pentium II一样有Mobile、Xeon以及Cerelon等不同的版本。Celeron系列与Pentium III最大的差距在于二级缓存，100MHz外频的Tualatin Celeron 1GHz可以轻松地跃上133MHz外频。更为重要的是，Tualatin Celeron还有很好的向下兼容性，甚至440BX主板在使用转接卡之后也有望采用该CPU，因此也成为很多升级用户的首选。</p>\n<p>特别指出的是，Pentium III光是桌上型就拥有Katmai Slot 1 、Coppermine Slot 1以及Coppermine Socket 370等三种不同的系列。到后期，英特尔放弃插卡式界面而又回归到插槽界面(Socket 370)。socket370封装开始推出的时候，有一部分消费者舍弃了slot1平台而选择了新的处理器。新的PGA封装分为PPGA和FC-PGA两种，前者较为廉价，因而被赛扬处理器所采用，而更为昂贵的后者则被奔腾III处理器所采用。例外的是：采用Mendocino核心的赛扬处理器同时有这两种不同封装的版本。采用PPGA封装的赛扬处理器可以通过转接卡在slot1主板上使用，而采用FC-PGA封装的奔三处理器则无能为力了。</p>\n<h2 id=\"2000年：Intel-Pentium-IV\"><a href=\"#2000年：Intel-Pentium-IV\" class=\"headerlink\" title=\"2000年：Intel Pentium IV\"></a>2000年：Intel Pentium IV</h2><p>Pentium 4处理器集成了4200万个晶体管，到了改进版的Pentium 4(Northwood)更是集成了5千5百万个晶体管；并且开始采用0.18微米进行制造，初始速度就达到了1.5GHz。</p>\n<p>Pentium 4还提供的SSE2指令集，这套指令集增加144个全新的指令，在128bit压缩的数据，在SSE时，仅能以4个单精度浮点值的形式来处理，而在SSE2指令集，该资料能采用多种数据结构来处理：</p>\n<p>4个单精度浮点数(SSE)对应2个双精度浮点数(SSE2)，对应16字节数(SSE2)，对应8个字数(word)，对应4个双字数(SSE2)，对应2个四字数(SSE2)，对应1个128位长的整数(SSE2) 。</p>\n<h2 id=\"2002-2004年：超线程P4处理器\"><a href=\"#2002-2004年：超线程P4处理器\" class=\"headerlink\" title=\"2002-2004年：超线程P4处理器\"></a>2002-2004年：超线程P4处理器</h2><p>2002年11月14日，英特尔在全新英特尔奔腾4处理器3.06GHz上推出其创新超线程(Hyper-Threading，HT)技术。超线程(HT)技术支持全新级别的高性能台式机，同时快速运行多个计算应用，或为采用多线程的单独软件程序提供更多性能。超线程(HT)技术可将电脑性能提升达25%。除了为台式机用户引入超线程(HT)技术外，英特尔在推出英特尔奔腾4处理器3.06GHZ时达到了一个电脑里程碑。这是第一款商用微处理器，运行速率为每秒30亿周期，并且采用当时业界最先进的0.13微米制程制作。</p>\n<h3 id=\"P4处理器3-06GHz\"><a href=\"#P4处理器3-06GHz\" class=\"headerlink\" title=\"P4处理器3.06GHz\"></a>P4处理器3.06GHz</h3><p>2003年，英特尔发布前端总线为533MHz的Pentium 4 3.06GHz处理器，采用了0.13微米工艺技术,提供512K的二级缓存，核心由5500万个晶体管组成。</p>\n<h3 id=\"P4处理器至尊版3-20GHz\"><a href=\"#P4处理器至尊版3-20GHz\" class=\"headerlink\" title=\"P4处理器至尊版3.20GHz\"></a>P4处理器至尊版3.20GHz</h3><p>2004年初发布，该处理器可兼容现有的英特尔865和英特尔875芯片组家族产品以及标准系统内存。2MB三级高速缓存可以预先加载图形帧缓冲区或视频帧，以满足处理器随后的要求，使在访问内存和I/O设备时实现更高的吞吐率和更快的帧带率。最终，这可带来更逼真的游戏效果和改进的视频编辑性能。增强的CPU性能还可支持软件厂商创建完善的软件物理引擎，从而带来栩栩如生的人物动作和人工智能，使电脑控制的人物更加形象、逼真。</p>\n<p>半年之后，2004年6月，英特尔发布了P4 3.4GHz处理器，该处理器支持超线程(HT)技术，采用0.13微米制程，具备512KB二级高速缓存、2MB三级高速缓存和800MHz系统前端总线速度。</p>\n<p>Northwood是第二代产品，采用0.13微米制程，具有电压低、体积小、温度低的优点。接着就是Prescott(0.09微米)，虽然这技术很新，不过由于效能提升并不明显，而且有过热的问题。后来英特尔又推出Hyper Threading技术，大大增加工作效率，让P4又成为市场宠儿。英特尔之后又推出Extreme Edition、含有Prestonia(原本给服务器用的Xeon核心)以及Gallatin(0.13微米Northwood外频提升改良版)核心的CPU。现在市场上的高阶Pentium 4则是Socket LGA 775的Prescott为主。</p>\n<h2 id=\"2005-2006年：双核处理器\"><a href=\"#2005-2006年：双核处理器\" class=\"headerlink\" title=\"2005-2006年：双核处理器\"></a>2005-2006年：双核处理器</h2><p>2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了。双核和多核处理器设计用于在一枚处理器中集成两个或多个完整执行内核，以支持同时管理多项活动。英特尔超线程(HT)技术能够使一个执行内核发挥两枚逻辑处理器的作用，因此与该技术结合使用时，英特尔奔腾处理器至尊版840能够充分利用以前可能被闲置的资源，同时处理四个软件线程。</p>\n<h3 id=\"英特尔奔腾D处理器\"><a href=\"#英特尔奔腾D处理器\" class=\"headerlink\" title=\"英特尔奔腾D处理器\"></a>英特尔奔腾D处理器</h3><p>5月，带有两个处理内核的英特尔奔腾D处理器随英特尔945高速芯片组家族一同推出，可带来某些消费电子产品的特性，例如：环绕立体声音频、高清晰度视频和增强图形功能。2006年1月，英特尔发布了Pentium D 9xx系列处理器，包括了支持VT虚拟化技术的Pentium D 960(3.60GHz)、950(3.40GHz)和不支持VT的Pentium D 945(3.4 GHz)、925(3GHz)(注：925不支持VT虚拟化技术)和915(2.80GHz)。</p>\n<h3 id=\"英特尔酷睿2双核处理器\"><a href=\"#英特尔酷睿2双核处理器\" class=\"headerlink\" title=\"英特尔酷睿2双核处理器\"></a>英特尔酷睿2双核处理器</h3><p>2006年7月，英特尔公司面向家用和商用个人电脑与笔记本电脑，发布了十款全新英特尔酷睿2双核处理器和英特尔酷睿至尊处理器。英特尔酷睿2双核处理器家族包括五款专门针对企业、家庭、工作站和玩家(如高端游戏玩家)而定制的台式机处理器，以及五款专门针对移动生活而定制的处理器。英特尔酷睿2双核处理器设计用于提供出色的能效表现，并更快速地运行多种复杂应用，支持用户改进各种任务的处理，例如：更流畅地观看和播放高清晰度视频；在电子商务交易过程中更好地保护电脑及其资产；以及提供更耐久的电池使用时间和更加纤巧时尚的笔记本电脑外形。</p>\n<p>全新处理器可实现高达40%的性能提升，其能效比最出色的英特尔奔腾处理器高出40%。英特尔酷睿2双核处理器包含2.91亿个晶体管。不过，Pentium D谈不上是一套完美的双核架构，Intel只是将两个完全独立的CPU核心做在同一枚芯片上，通过同一条前端总线与芯片组相连。两个核心缺乏必要的协同和资源共享能力，而且还必须频繁地对二级缓存作同步化刷新动作，以避免两个核心的工作步调出问题。从这个意义上说，Pentium D带来的进步并没有人们预想得那么大！</p>\n<h2 id=\"2011年：重新确定处理器产品架构\"><a href=\"#2011年：重新确定处理器产品架构\" class=\"headerlink\" title=\"2011年：重新确定处理器产品架构\"></a>2011年：重新确定处理器产品架构</h2><p>2011年3月，使用32nm工艺全新桌面级和移动端处理器采用了i3、i5和i7的产品分级架构。其中i3主攻低端市场，采用双核处理器架构，约2MB二级缓存；i5处理器主攻主流市场，采用四核处理器架构，4MB二级缓存；i7主攻高端市场，采用四核八线程或六核十二线程架构，二级缓存不少于8MB。</p>\n<h2 id=\"2012年：发布22纳米工艺和第三代处理器\"><a href=\"#2012年：发布22纳米工艺和第三代处理器\" class=\"headerlink\" title=\"2012年：发布22纳米工艺和第三代处理器\"></a>2012年：发布22纳米工艺和第三代处理器</h2><p>使用22nm工艺的处理器热功耗普遍小于77W，使得处理器的散热需求大幅下降，提升了大规模数据运算的可靠性，并降低了散热功耗。</p>\n<h2 id=\"2014年：首发桌面级8核心16线程处理器\"><a href=\"#2014年：首发桌面级8核心16线程处理器\" class=\"headerlink\" title=\"2014年：首发桌面级8核心16线程处理器\"></a>2014年：首发桌面级8核心16线程处理器</h2><p>2014年9月上市的i7-5960X处理器是第一款基于22nm工艺的八核心桌面级处理器，拥有高达20MB的三级缓存，主频达到3.5GHz，热功耗140W。此处理器的处理能力可谓超群，浮点数计算能力是普通办公电脑的10倍以上。随着这一“怪兽”处理器的问世，Intel公司在处理器领域与AMD的差距越拉越大，已经完全形成了一家独大的局面。</p>\n<h2 id=\"寻址空间发展表\"><a href=\"#寻址空间发展表\" class=\"headerlink\" title=\"寻址空间发展表\"></a>寻址空间发展表</h2><p>摘自 <a href=\"http://blog.chinaunix.net/uid-23069658-id-3569341.html\" target=\"_blank\" rel=\"external\">寻访x86处理器“实模式”和“保护模式”的前世今生</a></p>\n<p><img src=\"http://images2017.cnblogs.com/blog/945387/201709/945387-20170906002916601-1518759142.png\" alt=\"img\"></p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><a href=\"http://www.360doc.com/content/15/0411/07/21966267_462329844.shtml\" target=\"_blank\" rel=\"external\">Intel CPU发展简史</a></p>\n<p>百度百科资料</p>\n"},{"title":"Linux 内存寻址","date":"2017-09-08T16:50:08.000Z","_content":"\n## 内存地址分类\n\n逻辑地址：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。\n\n线性地址（或 虚拟地址）：一个32位（或64位）无符号整数，在32位系统中可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 \\* 1024 \\* 1024 \\* 1024个内存单元（字节）。\n\n物理地址（physical address）：芯片级内存单元寻址。与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。\n\n内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。\n\n## 硬件中的分段\n\n### 段选择符和段寄存器\n\n逻辑地址由两部分组成：段选择符和指定段内相对地址的偏移量。段选择符（Segment Selector）是一个16位长的字段，而偏移量是一个32位长的字段。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true)\n\n| 字段名  | 描述                                       |\n| ---- | ---------------------------------------- |\n| 索引   | 指定了放在GDT或LDT中的相应段描述符                     |\n| TI   | TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） |\n| RPL  | 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 |\n\n处理器提供段寄存器来存放段选择符以保证查找段选择符的效率。这些段寄存器称为cs, ss, ds, es, fs和gs。程序可以把同一个段寄存器用于不同的目的：先将其值保存在内存中，用完后再恢复。6个段寄存器中3个有专门的用途：\n\n- cs 代码段寄存器，指向包含程序指令的段。\n- ss 栈段寄存器，指向包含当前程序栈的段。\n- ds 数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。\n\n其他3个段寄存器作一般用途，可以指向任意的数据段。cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。0代表最高优先级——内核态，而3代表最低优先级——用户态。\n\n### 段描述符\n\n每个段由一个 8字节（64 bit） 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.jpg?raw=true)\n\n| 字段名       | 描述                                       |\n| --------- | ---------------------------------------- |\n| 基地址（Base） | 包含段的首字节的线性地址 （32 bit）                    |\n| G         | 粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计         |\n| Limit     | 最大段偏移量，段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化 |\n| S         | 系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段 |\n| Type      | 描述了段的类型特征和它的存取权限                         |\n| DPL       | 描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级 |\n| P         | Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去 |\n| D或B       | 取决于是代码段还是数据段                             |\n| AVL       | 操作系统使用，但被Linux忽略                         |\n\n为加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。\n\n### 分段单元\n\n下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作：\n\n- 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。\n- 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。\n- 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.jpg?raw=true)\n\n有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。\n\n## Linux中的分段\n\n2.6版的Linux只有在x86结构下才需要分段。\n\n运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：内核代码段和内核数据段。\n\n下表显示了这4个重要段的段描述符字段的值：\n\n| 段     | Base        | G    | Limit   | S    | Type | DPL  | D/B  | p    |\n| ----- | ----------- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |\n| 用户代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 3    | 1    | 1    |\n| 用户数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 3    | 1    | 1    |\n| 内核代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 0    | 1    | 1    |\n| 内核数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 0    | 1    | 1    |\n\nG为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB\n\n相应的段选择符由宏定义。\n\n```\n  __USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS\n```\n\n为了对内核代码段寻址，内核只需把__KERNEL_CS宏产生的值装进cs段寄存器即可。\n\n注意，与段相关的线性地址从0开始，达到2<sup>23</sup> - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。\n\n所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。\n\n当对指向指令或者数据结构的指针进行保存时，内核不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏__KERNEL_CS定义，所以只要当CPU切换到内核态时将__KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。\n\n### Linux GDT\n\n在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。这些符号都在文件arch/i386/kernel/head.S中被定义。\n\n下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg?raw=true)\n\n每一个GDT中包含的18个段描述符指同下列的段：\n\n- 用户态和内核态下的代码段和数据段，共4个。\n- 任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb, 因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置 为0，因为不允许用户态下的进程访问TSS段。\n- 1个包括缺省局部描述符表的段，这个段通常被所有进程共享。\n- 3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。\n- 与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。\n- 与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。\n- 被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。\n\n系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项：\n\n- 每个处理器都有它自己的TSS段。\n- GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。\n- 在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。\n\n### Linux LDT\n\n大多数用户态下的Linux程序不使用局部描述符表，因此内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。\n\n## 硬件中的分页\n\n分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。\n\n为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。\n\n分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。\n\n把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。\n\n从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。<需要了解控制寄存器(cr0~cr3)的结构及作用>\n\n### 常规分页\n\n从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域：\n\n- Directory（目录）：最高10位\n- Table（页表）：中间10位\n- Offset（偏移量）：最低12位\n\n线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )。\n\n页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。\n\n使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2<sup>20</sup>个表项(4GB/4KB = 2<sup>20</sup> ，也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些“虚拟内存区”请求页表来减少内存容量。\n\n每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。\n\n正在使用的页目录的物理地址存放在控制寄存器cr3中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/x86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E9%A1%B5.jpg?raw=true)\n\n页目录项和页表项有相同的结构，每项都包含下面的字段：\n\n| 字段                | 描述                                       |\n| ----------------- | ---------------------------------------- |\n| Present标志         | 置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。 |\n| 包含页框物理地址最高20位的字段  | 由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。 |\n| Accessed标志        | 每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。 |\n| Dirty标志           | 只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。 |\n| Read/Write标志      | 含有页或页表的存取权限。                             |\n| User/Supervisor标志 | 含有访问页或页表所需的特权级。                          |\n| PCD和PWT标志         | 控制硬件高速缓存处理页或页表的方式。                       |\n| Page Size标志       | 只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。          |\n| Global标志          | 只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。 |\n\n### 扩展分页\n\n从Pentium模型开始，80x86微处理器引入了扩展分页（extended paging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。\n\n通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段：\n\n- Directory：最高10位\n- Offset：其余22位\n\n扩展分页和正常分页的目录项基本相同，除了：\n\n- Page Size标志必须被设置。\n- 32位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。\n\n通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。\n\n### 硬件保护方案\n\n分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。\n\n此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。\n\n### 物理地址扩展（PAE）分页机制\n\n处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。\n\n然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到2<sup>36</sup> = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。\n\n从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。\n\n通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。\n\nIntel为了支持PAE改变了分页机制：\n\n- 64GB的RAM被分为2<sup>24</sup>个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。\n- 引入一个叫做页目录指针表(Page Directory Pointer Table, PDPT)的页表新级别，它由4个64位表项组成。\n- cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(25)的倍数上对齐，因此27位足以表示这种表的基地址。\n- 当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释：\n  - cr3：指向一个PDPT\n  - 位31-30：指向PDPT中4个项中的一个\n  - 位29-21：指向页目录中512个项目中的一个\n  - 位20-12：指向页表中512项中的一个\n  - 位11-0：4KB页中的偏移量\n- 当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释：\n  - cr3：指向一个PDPT\n  - 位31-30：指向PDPT中4个项中的一个\n  - 位29-21：指向页目录中512个项中的一个\n  - 位20-0：2MB页中的偏移量\n\n总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。\n\n### 64位系统中的分页\n\n| 平台名称   | 页大小  | 寻址使用的位数 | 分页级别数 | 线性地址分级      |\n| ------ | ---- | ------- | ----- | ----------- |\n| alpha  | 8KB  | 43      | 3     | 10+10+10+13 |\n| ia64   | 4KB  | 39      | 3     | 9+9+9+12    |\n| ppc64  | 4KB  | 41      | 3     | 10+10+9+12  |\n| sh64   | 4KB  | 41      | 3     | 10+10+9+12  |\n| x86_64 | 4KB  | 48      | 4     | 9+9+9+9+12  |\n\n### 转换后援缓冲器（TLB）\n\nx86处理器包含了一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。\n\n在多处理系统中，每个CPU都有自己的TLB，叫做该CPU的本地TLB。\n\n当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。\n\n## Linux中的分页\n\nLinux采用了一种同时适用于32位和64位系统的普通分页模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为：\n\n- 页全局目录(Page Global Directory )\n- 页上级目录(Page Upper Directory )\n- 页中级目录(Page Middle Directory )\n- 页表(Page Table)\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n\n对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。\n\n启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。\n\n最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。\n\nLinux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：\n\n- 给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。\n- 区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。\n\n每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。\n\n### 物理内存布局\n\n可参考 [地址空间布局](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html)\n\n在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。\n\n内核将下列页框记为保留：\n\n- 在不可用的物理地址范围内的页框。\n- 含有内核代码和已初始化的数据结构的页框。\n\n保留页框中的页绝不能被动态分配或交换到磁盘上。\n\n一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小于3MB的RAM中。\n\n为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如：\n\n- 页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。\n- 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。\n- 第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。\n\n在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。\n\n随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。\n\n| 开始          | 结束           | 类型        |\n| ----------- | ------------ | --------- |\n| 0x0000 0000 | 0x0009 ffff  | Usable    |\n| 0x000f 0000 | 0x000f ffff  | Reserved  |\n| 0x0010 0000 | 0x07fe ffff  | Usable    |\n| 0x07ff 0000 | 0x07ff 2ffff | ACPI data |\n| 0x07ff 3000 | 0x07ff ffff  | ACPI NVS  |\n| 0xffff 0000 | 0xffff ffff  | Reserved  |\n\n上表显示了具有128MB(0x0800 0000) RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。\n\n内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局。\n\n为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM：\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux2.6%E7%9A%84%E5%89%8D768%E4%B8%AA%E9%A1%B5%E6%A1%86%EF%BC%883MB%EF%BC%89.jpg?raw=true)\n\n符号_text对应于物理地址0x0010 0000 （16MB），表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在_etext后开始，在_edata处结束。紧接着是未初始化的数据并以_end结束。\n\n图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。\n\n### 进程页表\n\n进程的线性地址空间分成两部分：\n\n- 从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。\n- 从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。\n\n进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。\n\n宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。\n\n### 内核页表\n\n内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。\n\n内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。\n\n第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。\n\n第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。\n\n### 临时内核页表\n\n临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。\n\n临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。\n\n分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。\n\n内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化：\n\n- 0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。\n- 把这四个项中的Present、Read/Write和User/Supervisor标志置位。\n- 把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。\n\n汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段：\n\n```\nmovl $swapper_pg_dir-0xc0000000,%eax\nmovl %eax,%cr3      /*设置页表指针*/\nmovl %cr0,%eax\norl $0x80000000,%eax\nmovl %eax,%cr0      /*设置分页(PG)位“/\n```","source":"_posts/Linux-内存寻址.md","raw":"---\ntitle: Linux 内存寻址\ndate: 2017-09-09 00:50:08\ncategories: Linux内核\ntags:\n  - 内存寻址\n  - 分段\n  - 分页\n  - GDT\n  - LDT\n---\n\n## 内存地址分类\n\n逻辑地址：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。\n\n线性地址（或 虚拟地址）：一个32位（或64位）无符号整数，在32位系统中可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 \\* 1024 \\* 1024 \\* 1024个内存单元（字节）。\n\n物理地址（physical address）：芯片级内存单元寻址。与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。\n\n内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。\n\n## 硬件中的分段\n\n### 段选择符和段寄存器\n\n逻辑地址由两部分组成：段选择符和指定段内相对地址的偏移量。段选择符（Segment Selector）是一个16位长的字段，而偏移量是一个32位长的字段。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true)\n\n| 字段名  | 描述                                       |\n| ---- | ---------------------------------------- |\n| 索引   | 指定了放在GDT或LDT中的相应段描述符                     |\n| TI   | TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） |\n| RPL  | 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 |\n\n处理器提供段寄存器来存放段选择符以保证查找段选择符的效率。这些段寄存器称为cs, ss, ds, es, fs和gs。程序可以把同一个段寄存器用于不同的目的：先将其值保存在内存中，用完后再恢复。6个段寄存器中3个有专门的用途：\n\n- cs 代码段寄存器，指向包含程序指令的段。\n- ss 栈段寄存器，指向包含当前程序栈的段。\n- ds 数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。\n\n其他3个段寄存器作一般用途，可以指向任意的数据段。cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。0代表最高优先级——内核态，而3代表最低优先级——用户态。\n\n### 段描述符\n\n每个段由一个 8字节（64 bit） 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.jpg?raw=true)\n\n| 字段名       | 描述                                       |\n| --------- | ---------------------------------------- |\n| 基地址（Base） | 包含段的首字节的线性地址 （32 bit）                    |\n| G         | 粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计         |\n| Limit     | 最大段偏移量，段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化 |\n| S         | 系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段 |\n| Type      | 描述了段的类型特征和它的存取权限                         |\n| DPL       | 描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级 |\n| P         | Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去 |\n| D或B       | 取决于是代码段还是数据段                             |\n| AVL       | 操作系统使用，但被Linux忽略                         |\n\n为加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。\n\n### 分段单元\n\n下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作：\n\n- 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。\n- 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。\n- 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.jpg?raw=true)\n\n有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。\n\n## Linux中的分段\n\n2.6版的Linux只有在x86结构下才需要分段。\n\n运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：内核代码段和内核数据段。\n\n下表显示了这4个重要段的段描述符字段的值：\n\n| 段     | Base        | G    | Limit   | S    | Type | DPL  | D/B  | p    |\n| ----- | ----------- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |\n| 用户代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 3    | 1    | 1    |\n| 用户数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 3    | 1    | 1    |\n| 内核代码段 | 0x0000 0000 | 1    | 0xfffff | 1    | 10   | 0    | 1    | 1    |\n| 内核数据段 | 0x0000 0000 | 1    | 0xfffff | 1    | 2    | 0    | 1    | 1    |\n\nG为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB\n\n相应的段选择符由宏定义。\n\n```\n  __USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS\n```\n\n为了对内核代码段寻址，内核只需把__KERNEL_CS宏产生的值装进cs段寄存器即可。\n\n注意，与段相关的线性地址从0开始，达到2<sup>23</sup> - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。\n\n所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。\n\n当对指向指令或者数据结构的指针进行保存时，内核不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏__KERNEL_CS定义，所以只要当CPU切换到内核态时将__KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。\n\n### Linux GDT\n\n在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。这些符号都在文件arch/i386/kernel/head.S中被定义。\n\n下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg?raw=true)\n\n每一个GDT中包含的18个段描述符指同下列的段：\n\n- 用户态和内核态下的代码段和数据段，共4个。\n- 任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb, 因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置 为0，因为不允许用户态下的进程访问TSS段。\n- 1个包括缺省局部描述符表的段，这个段通常被所有进程共享。\n- 3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。\n- 与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。\n- 与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。\n- 被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。\n\n系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项：\n\n- 每个处理器都有它自己的TSS段。\n- GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。\n- 在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。\n\n### Linux LDT\n\n大多数用户态下的Linux程序不使用局部描述符表，因此内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。\n\n## 硬件中的分页\n\n分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。\n\n为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。\n\n分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。\n\n把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。\n\n从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。<需要了解控制寄存器(cr0~cr3)的结构及作用>\n\n### 常规分页\n\n从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域：\n\n- Directory（目录）：最高10位\n- Table（页表）：中间10位\n- Offset（偏移量）：最低12位\n\n线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )。\n\n页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。\n\n使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2<sup>20</sup>个表项(4GB/4KB = 2<sup>20</sup> ，也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些“虚拟内存区”请求页表来减少内存容量。\n\n每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。\n\n正在使用的页目录的物理地址存放在控制寄存器cr3中。\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/x86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E9%A1%B5.jpg?raw=true)\n\n页目录项和页表项有相同的结构，每项都包含下面的字段：\n\n| 字段                | 描述                                       |\n| ----------------- | ---------------------------------------- |\n| Present标志         | 置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。 |\n| 包含页框物理地址最高20位的字段  | 由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。 |\n| Accessed标志        | 每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。 |\n| Dirty标志           | 只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。 |\n| Read/Write标志      | 含有页或页表的存取权限。                             |\n| User/Supervisor标志 | 含有访问页或页表所需的特权级。                          |\n| PCD和PWT标志         | 控制硬件高速缓存处理页或页表的方式。                       |\n| Page Size标志       | 只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。          |\n| Global标志          | 只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。 |\n\n### 扩展分页\n\n从Pentium模型开始，80x86微处理器引入了扩展分页（extended paging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。\n\n通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段：\n\n- Directory：最高10位\n- Offset：其余22位\n\n扩展分页和正常分页的目录项基本相同，除了：\n\n- Page Size标志必须被设置。\n- 32位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。\n\n通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。\n\n### 硬件保护方案\n\n分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。\n\n此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。\n\n### 物理地址扩展（PAE）分页机制\n\n处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。\n\n然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到2<sup>36</sup> = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。\n\n从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。\n\n通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。\n\nIntel为了支持PAE改变了分页机制：\n\n- 64GB的RAM被分为2<sup>24</sup>个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。\n- 引入一个叫做页目录指针表(Page Directory Pointer Table, PDPT)的页表新级别，它由4个64位表项组成。\n- cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(25)的倍数上对齐，因此27位足以表示这种表的基地址。\n- 当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释：\n  - cr3：指向一个PDPT\n  - 位31-30：指向PDPT中4个项中的一个\n  - 位29-21：指向页目录中512个项目中的一个\n  - 位20-12：指向页表中512项中的一个\n  - 位11-0：4KB页中的偏移量\n- 当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释：\n  - cr3：指向一个PDPT\n  - 位31-30：指向PDPT中4个项中的一个\n  - 位29-21：指向页目录中512个项中的一个\n  - 位20-0：2MB页中的偏移量\n\n总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。\n\n### 64位系统中的分页\n\n| 平台名称   | 页大小  | 寻址使用的位数 | 分页级别数 | 线性地址分级      |\n| ------ | ---- | ------- | ----- | ----------- |\n| alpha  | 8KB  | 43      | 3     | 10+10+10+13 |\n| ia64   | 4KB  | 39      | 3     | 9+9+9+12    |\n| ppc64  | 4KB  | 41      | 3     | 10+10+9+12  |\n| sh64   | 4KB  | 41      | 3     | 10+10+9+12  |\n| x86_64 | 4KB  | 48      | 4     | 9+9+9+9+12  |\n\n### 转换后援缓冲器（TLB）\n\nx86处理器包含了一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。\n\n在多处理系统中，每个CPU都有自己的TLB，叫做该CPU的本地TLB。\n\n当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。\n\n## Linux中的分页\n\nLinux采用了一种同时适用于32位和64位系统的普通分页模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为：\n\n- 页全局目录(Page Global Directory )\n- 页上级目录(Page Upper Directory )\n- 页中级目录(Page Middle Directory )\n- 页表(Page Table)\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n\n对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。\n\n启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。\n\n最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。\n\nLinux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：\n\n- 给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。\n- 区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。\n\n每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。\n\n### 物理内存布局\n\n可参考 [地址空间布局](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html)\n\n在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。\n\n内核将下列页框记为保留：\n\n- 在不可用的物理地址范围内的页框。\n- 含有内核代码和已初始化的数据结构的页框。\n\n保留页框中的页绝不能被动态分配或交换到磁盘上。\n\n一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小于3MB的RAM中。\n\n为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如：\n\n- 页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。\n- 物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。\n- 第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。\n\n在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。\n\n随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。\n\n| 开始          | 结束           | 类型        |\n| ----------- | ------------ | --------- |\n| 0x0000 0000 | 0x0009 ffff  | Usable    |\n| 0x000f 0000 | 0x000f ffff  | Reserved  |\n| 0x0010 0000 | 0x07fe ffff  | Usable    |\n| 0x07ff 0000 | 0x07ff 2ffff | ACPI data |\n| 0x07ff 3000 | 0x07ff ffff  | ACPI NVS  |\n| 0xffff 0000 | 0xffff ffff  | Reserved  |\n\n上表显示了具有128MB(0x0800 0000) RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。\n\n内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局。\n\n为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM：\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux2.6%E7%9A%84%E5%89%8D768%E4%B8%AA%E9%A1%B5%E6%A1%86%EF%BC%883MB%EF%BC%89.jpg?raw=true)\n\n符号_text对应于物理地址0x0010 0000 （16MB），表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在_etext后开始，在_edata处结束。紧接着是未初始化的数据并以_end结束。\n\n图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。\n\n### 进程页表\n\n进程的线性地址空间分成两部分：\n\n- 从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。\n- 从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。\n\n进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。\n\n宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。\n\n### 内核页表\n\n内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。\n\n内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。\n\n第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。\n\n第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。\n\n### 临时内核页表\n\n临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。\n\n临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。\n\n分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。\n\n内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化：\n\n- 0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。\n- 把这四个项中的Present、Read/Write和User/Supervisor标志置位。\n- 把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。\n\n汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段：\n\n```\nmovl $swapper_pg_dir-0xc0000000,%eax\nmovl %eax,%cr3      /*设置页表指针*/\nmovl %cr0,%eax\norl $0x80000000,%eax\nmovl %eax,%cr0      /*设置分页(PG)位“/\n```","slug":"Linux-内存寻址","published":1,"updated":"2017-09-13T03:23:28.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7omlvi80006ckfyskuxw0fi","content":"<h2 id=\"内存地址分类\"><a href=\"#内存地址分类\" class=\"headerlink\" title=\"内存地址分类\"></a>内存地址分类</h2><p>逻辑地址：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</p>\n<p>线性地址（或 虚拟地址）：一个32位（或64位）无符号整数，在32位系统中可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 * 1024 * 1024 * 1024个内存单元（字节）。</p>\n<p>物理地址（physical address）：芯片级内存单元寻址。与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。</p>\n<p>内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。</p>\n<h2 id=\"硬件中的分段\"><a href=\"#硬件中的分段\" class=\"headerlink\" title=\"硬件中的分段\"></a>硬件中的分段</h2><h3 id=\"段选择符和段寄存器\"><a href=\"#段选择符和段寄存器\" class=\"headerlink\" title=\"段选择符和段寄存器\"></a>段选择符和段寄存器</h3><p>逻辑地址由两部分组成：段选择符和指定段内相对地址的偏移量。段选择符（Segment Selector）是一个16位长的字段，而偏移量是一个32位长的字段。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引</td>\n<td>指定了放在GDT或LDT中的相应段描述符</td>\n</tr>\n<tr>\n<td>TI</td>\n<td>TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1）</td>\n</tr>\n<tr>\n<td>RPL</td>\n<td>请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td>\n</tr>\n</tbody>\n</table>\n<p>处理器提供段寄存器来存放段选择符以保证查找段选择符的效率。这些段寄存器称为cs, ss, ds, es, fs和gs。程序可以把同一个段寄存器用于不同的目的：先将其值保存在内存中，用完后再恢复。6个段寄存器中3个有专门的用途：</p>\n<ul>\n<li>cs 代码段寄存器，指向包含程序指令的段。</li>\n<li>ss 栈段寄存器，指向包含当前程序栈的段。</li>\n<li>ds 数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。</li>\n</ul>\n<p>其他3个段寄存器作一般用途，可以指向任意的数据段。cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。0代表最高优先级——内核态，而3代表最低优先级——用户态。</p>\n<h3 id=\"段描述符\"><a href=\"#段描述符\" class=\"headerlink\" title=\"段描述符\"></a>段描述符</h3><p>每个段由一个 8字节（64 bit） 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基地址（Base）</td>\n<td>包含段的首字节的线性地址 （32 bit）</td>\n</tr>\n<tr>\n<td>G</td>\n<td>粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计</td>\n</tr>\n<tr>\n<td>Limit</td>\n<td>最大段偏移量，段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化</td>\n</tr>\n<tr>\n<td>S</td>\n<td>系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>描述了段的类型特征和它的存取权限</td>\n</tr>\n<tr>\n<td>DPL</td>\n<td>描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级</td>\n</tr>\n<tr>\n<td>P</td>\n<td>Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去</td>\n</tr>\n<tr>\n<td>D或B</td>\n<td>取决于是代码段还是数据段</td>\n</tr>\n<tr>\n<td>AVL</td>\n<td>操作系统使用，但被Linux忽略</td>\n</tr>\n</tbody>\n</table>\n<p>为加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。</p>\n<h3 id=\"分段单元\"><a href=\"#分段单元\" class=\"headerlink\" title=\"分段单元\"></a>分段单元</h3><p>下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作：</p>\n<ul>\n<li>先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。</li>\n<li>从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。</li>\n<li>把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。</li>\n</ul>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.jpg?raw=true\" alt=\"img\"></p>\n<p>有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。</p>\n<h2 id=\"Linux中的分段\"><a href=\"#Linux中的分段\" class=\"headerlink\" title=\"Linux中的分段\"></a>Linux中的分段</h2><p>2.6版的Linux只有在x86结构下才需要分段。</p>\n<p>运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：内核代码段和内核数据段。</p>\n<p>下表显示了这4个重要段的段描述符字段的值：</p>\n<table>\n<thead>\n<tr>\n<th>段</th>\n<th>Base</th>\n<th>G</th>\n<th>Limit</th>\n<th>S</th>\n<th>Type</th>\n<th>DPL</th>\n<th>D/B</th>\n<th>p</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户代码段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>10</td>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>用户数据段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>内核代码段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>10</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>内核数据段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>G为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB</p>\n<p>相应的段选择符由宏定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS</div></pre></td></tr></table></figure>\n<p>为了对内核代码段寻址，内核只需把__KERNEL_CS宏产生的值装进cs段寄存器即可。</p>\n<p>注意，与段相关的线性地址从0开始，达到2<sup>23</sup> - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</p>\n<p>所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p>\n<p>当对指向指令或者数据结构的指针进行保存时，内核不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏<strong>KERNEL_CS定义，所以只要当CPU切换到内核态时将</strong>KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。</p>\n<h3 id=\"Linux-GDT\"><a href=\"#Linux-GDT\" class=\"headerlink\" title=\"Linux GDT\"></a>Linux GDT</h3><p>在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。这些符号都在文件arch/i386/kernel/head.S中被定义。</p>\n<p>下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg?raw=true\" alt=\"img\"></p>\n<p>每一个GDT中包含的18个段描述符指同下列的段：</p>\n<ul>\n<li>用户态和内核态下的代码段和数据段，共4个。</li>\n<li>任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb, 因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置 为0，因为不允许用户态下的进程访问TSS段。</li>\n<li>1个包括缺省局部描述符表的段，这个段通常被所有进程共享。</li>\n<li>3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。</li>\n<li>与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。</li>\n<li>与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。</li>\n<li>被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。</li>\n</ul>\n<p>系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项：</p>\n<ul>\n<li>每个处理器都有它自己的TSS段。</li>\n<li>GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。</li>\n<li>在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。</li>\n</ul>\n<h3 id=\"Linux-LDT\"><a href=\"#Linux-LDT\" class=\"headerlink\" title=\"Linux LDT\"></a>Linux LDT</h3><p>大多数用户态下的Linux程序不使用局部描述符表，因此内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。</p>\n<h2 id=\"硬件中的分页\"><a href=\"#硬件中的分页\" class=\"headerlink\" title=\"硬件中的分页\"></a>硬件中的分页</h2><p>分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。</p>\n<p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。</p>\n<p>分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p>\n<p>把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p>\n<p>从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。&lt;需要了解控制寄存器(cr0~cr3)的结构及作用&gt;</p>\n<h3 id=\"常规分页\"><a href=\"#常规分页\" class=\"headerlink\" title=\"常规分页\"></a>常规分页</h3><p>从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域：</p>\n<ul>\n<li>Directory（目录）：最高10位</li>\n<li>Table（页表）：中间10位</li>\n<li>Offset（偏移量）：最低12位</li>\n</ul>\n<p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )。</p>\n<p>页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。</p>\n<p>使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2<sup>20</sup>个表项(4GB/4KB = 2<sup>20</sup> ，也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些“虚拟内存区”请求页表来减少内存容量。</p>\n<p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。</p>\n<p>正在使用的页目录的物理地址存放在控制寄存器cr3中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/x86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E9%A1%B5.jpg?raw=true\" alt=\"img\"></p>\n<p>页目录项和页表项有相同的结构，每项都包含下面的字段：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Present标志</td>\n<td>置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。</td>\n</tr>\n<tr>\n<td>包含页框物理地址最高20位的字段</td>\n<td>由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。</td>\n</tr>\n<tr>\n<td>Accessed标志</td>\n<td>每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。</td>\n</tr>\n<tr>\n<td>Dirty标志</td>\n<td>只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。</td>\n</tr>\n<tr>\n<td>Read/Write标志</td>\n<td>含有页或页表的存取权限。</td>\n</tr>\n<tr>\n<td>User/Supervisor标志</td>\n<td>含有访问页或页表所需的特权级。</td>\n</tr>\n<tr>\n<td>PCD和PWT标志</td>\n<td>控制硬件高速缓存处理页或页表的方式。</td>\n</tr>\n<tr>\n<td>Page Size标志</td>\n<td>只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。</td>\n</tr>\n<tr>\n<td>Global标志</td>\n<td>只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"扩展分页\"><a href=\"#扩展分页\" class=\"headerlink\" title=\"扩展分页\"></a>扩展分页</h3><p>从Pentium模型开始，80x86微处理器引入了扩展分页（extended paging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。</p>\n<p>通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段：</p>\n<ul>\n<li>Directory：最高10位</li>\n<li>Offset：其余22位</li>\n</ul>\n<p>扩展分页和正常分页的目录项基本相同，除了：</p>\n<ul>\n<li>Page Size标志必须被设置。</li>\n<li>32位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。</li>\n</ul>\n<p>通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。</p>\n<h3 id=\"硬件保护方案\"><a href=\"#硬件保护方案\" class=\"headerlink\" title=\"硬件保护方案\"></a>硬件保护方案</h3><p>分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。</p>\n<p>此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。</p>\n<h3 id=\"物理地址扩展（PAE）分页机制\"><a href=\"#物理地址扩展（PAE）分页机制\" class=\"headerlink\" title=\"物理地址扩展（PAE）分页机制\"></a>物理地址扩展（PAE）分页机制</h3><p>处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。</p>\n<p>然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到2<sup>36</sup> = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。</p>\n<p>从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。</p>\n<p>通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。</p>\n<p>Intel为了支持PAE改变了分页机制：</p>\n<ul>\n<li>64GB的RAM被分为2<sup>24</sup>个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。</li>\n<li>引入一个叫做页目录指针表(Page Directory Pointer Table, PDPT)的页表新级别，它由4个64位表项组成。</li>\n<li>cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(25)的倍数上对齐，因此27位足以表示这种表的基地址。</li>\n<li>当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释：<ul>\n<li>cr3：指向一个PDPT</li>\n<li>位31-30：指向PDPT中4个项中的一个</li>\n<li>位29-21：指向页目录中512个项目中的一个</li>\n<li>位20-12：指向页表中512项中的一个</li>\n<li>位11-0：4KB页中的偏移量</li>\n</ul>\n</li>\n<li>当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释：<ul>\n<li>cr3：指向一个PDPT</li>\n<li>位31-30：指向PDPT中4个项中的一个</li>\n<li>位29-21：指向页目录中512个项中的一个</li>\n<li>位20-0：2MB页中的偏移量</li>\n</ul>\n</li>\n</ul>\n<p>总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。</p>\n<h3 id=\"64位系统中的分页\"><a href=\"#64位系统中的分页\" class=\"headerlink\" title=\"64位系统中的分页\"></a>64位系统中的分页</h3><table>\n<thead>\n<tr>\n<th>平台名称</th>\n<th>页大小</th>\n<th>寻址使用的位数</th>\n<th>分页级别数</th>\n<th>线性地址分级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alpha</td>\n<td>8KB</td>\n<td>43</td>\n<td>3</td>\n<td>10+10+10+13</td>\n</tr>\n<tr>\n<td>ia64</td>\n<td>4KB</td>\n<td>39</td>\n<td>3</td>\n<td>9+9+9+12</td>\n</tr>\n<tr>\n<td>ppc64</td>\n<td>4KB</td>\n<td>41</td>\n<td>3</td>\n<td>10+10+9+12</td>\n</tr>\n<tr>\n<td>sh64</td>\n<td>4KB</td>\n<td>41</td>\n<td>3</td>\n<td>10+10+9+12</td>\n</tr>\n<tr>\n<td>x86_64</td>\n<td>4KB</td>\n<td>48</td>\n<td>4</td>\n<td>9+9+9+9+12</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转换后援缓冲器（TLB）\"><a href=\"#转换后援缓冲器（TLB）\" class=\"headerlink\" title=\"转换后援缓冲器（TLB）\"></a>转换后援缓冲器（TLB）</h3><p>x86处理器包含了一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。</p>\n<p>在多处理系统中，每个CPU都有自己的TLB，叫做该CPU的本地TLB。</p>\n<p>当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。</p>\n<h2 id=\"Linux中的分页\"><a href=\"#Linux中的分页\" class=\"headerlink\" title=\"Linux中的分页\"></a>Linux中的分页</h2><p>Linux采用了一种同时适用于32位和64位系统的普通分页模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为：</p>\n<ul>\n<li>页全局目录(Page Global Directory )</li>\n<li>页上级目录(Page Upper Directory )</li>\n<li>页中级目录(Page Middle Directory )</li>\n<li>页表(Page Table)</li>\n</ul>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"img\"></p>\n<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p>\n<p>启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。</p>\n<p>最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。</p>\n<p>Linux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：</p>\n<ul>\n<li>给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。</li>\n<li>区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。</li>\n</ul>\n<p>每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。</p>\n<h3 id=\"物理内存布局\"><a href=\"#物理内存布局\" class=\"headerlink\" title=\"物理内存布局\"></a>物理内存布局</h3><p>可参考 <a href=\"http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html\" target=\"_blank\" rel=\"external\">地址空间布局</a></p>\n<p>在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。</p>\n<p>内核将下列页框记为保留：</p>\n<ul>\n<li>在不可用的物理地址范围内的页框。</li>\n<li>含有内核代码和已初始化的数据结构的页框。</li>\n</ul>\n<p>保留页框中的页绝不能被动态分配或交换到磁盘上。</p>\n<p>一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小于3MB的RAM中。</p>\n<p>为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如：</p>\n<ul>\n<li>页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。</li>\n<li>物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。</li>\n<li>第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。</li>\n</ul>\n<p>在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。</p>\n<p>随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。</p>\n<table>\n<thead>\n<tr>\n<th>开始</th>\n<th>结束</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x0000 0000</td>\n<td>0x0009 ffff</td>\n<td>Usable</td>\n</tr>\n<tr>\n<td>0x000f 0000</td>\n<td>0x000f ffff</td>\n<td>Reserved</td>\n</tr>\n<tr>\n<td>0x0010 0000</td>\n<td>0x07fe ffff</td>\n<td>Usable</td>\n</tr>\n<tr>\n<td>0x07ff 0000</td>\n<td>0x07ff 2ffff</td>\n<td>ACPI data</td>\n</tr>\n<tr>\n<td>0x07ff 3000</td>\n<td>0x07ff ffff</td>\n<td>ACPI NVS</td>\n</tr>\n<tr>\n<td>0xffff 0000</td>\n<td>0xffff ffff</td>\n<td>Reserved</td>\n</tr>\n</tbody>\n</table>\n<p>上表显示了具有128MB(0x0800 0000) RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。</p>\n<p>内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局。</p>\n<p>为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM：</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux2.6%E7%9A%84%E5%89%8D768%E4%B8%AA%E9%A1%B5%E6%A1%86%EF%BC%883MB%EF%BC%89.jpg?raw=true\" alt=\"img\"></p>\n<p>符号_text对应于物理地址0x0010 0000 （16MB），表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在_etext后开始，在_edata处结束。紧接着是未初始化的数据并以_end结束。</p>\n<p>图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。</p>\n<h3 id=\"进程页表\"><a href=\"#进程页表\" class=\"headerlink\" title=\"进程页表\"></a>进程页表</h3><p>进程的线性地址空间分成两部分：</p>\n<ul>\n<li>从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。</li>\n<li>从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。</li>\n</ul>\n<p>进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。</p>\n<p>宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。</p>\n<h3 id=\"内核页表\"><a href=\"#内核页表\" class=\"headerlink\" title=\"内核页表\"></a>内核页表</h3><p>内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。</p>\n<p>内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。</p>\n<p>第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。</p>\n<p>第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。</p>\n<h3 id=\"临时内核页表\"><a href=\"#临时内核页表\" class=\"headerlink\" title=\"临时内核页表\"></a>临时内核页表</h3><p>临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。</p>\n<p>临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。</p>\n<p>分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。</p>\n<p>内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化：</p>\n<ul>\n<li>0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。</li>\n<li>把这四个项中的Present、Read/Write和User/Supervisor标志置位。</li>\n<li>把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。</li>\n</ul>\n<p>汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">movl $swapper_pg_dir-0xc0000000,%eax</div><div class=\"line\">movl %eax,%cr3      /*设置页表指针*/</div><div class=\"line\">movl %cr0,%eax</div><div class=\"line\">orl $0x80000000,%eax</div><div class=\"line\">movl %eax,%cr0      /*设置分页(PG)位“/</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存地址分类\"><a href=\"#内存地址分类\" class=\"headerlink\" title=\"内存地址分类\"></a>内存地址分类</h2><p>逻辑地址：机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset或displacement）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</p>\n<p>线性地址（或 虚拟地址）：一个32位（或64位）无符号整数，在32位系统中可以用来表示高达4GB（0x0000 0000 —— 0xffff ffff）的地址，也就是高达 4 * 1024 * 1024 * 1024个内存单元（字节）。</p>\n<p>物理地址（physical address）：芯片级内存单元寻址。与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位（开启PAE）无符号整数表示。</p>\n<p>内存管理单元（MMU）通过分段单元（segmentation unit）把逻辑地址转换成线性地址；然后，通过分页单元（paging unit）把线性地址转换成物理地址。分段单元和分页单元都是一种硬件电路。</p>\n<h2 id=\"硬件中的分段\"><a href=\"#硬件中的分段\" class=\"headerlink\" title=\"硬件中的分段\"></a>硬件中的分段</h2><h3 id=\"段选择符和段寄存器\"><a href=\"#段选择符和段寄存器\" class=\"headerlink\" title=\"段选择符和段寄存器\"></a>段选择符和段寄存器</h3><p>逻辑地址由两部分组成：段选择符和指定段内相对地址的偏移量。段选择符（Segment Selector）是一个16位长的字段，而偏移量是一个32位长的字段。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引</td>\n<td>指定了放在GDT或LDT中的相应段描述符</td>\n</tr>\n<tr>\n<td>TI</td>\n<td>TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1）</td>\n</tr>\n<tr>\n<td>RPL</td>\n<td>请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td>\n</tr>\n</tbody>\n</table>\n<p>处理器提供段寄存器来存放段选择符以保证查找段选择符的效率。这些段寄存器称为cs, ss, ds, es, fs和gs。程序可以把同一个段寄存器用于不同的目的：先将其值保存在内存中，用完后再恢复。6个段寄存器中3个有专门的用途：</p>\n<ul>\n<li>cs 代码段寄存器，指向包含程序指令的段。</li>\n<li>ss 栈段寄存器，指向包含当前程序栈的段。</li>\n<li>ds 数据段寄存器，指向包含静态数据或者全局数据段（初始化数据）。</li>\n</ul>\n<p>其他3个段寄存器作一般用途，可以指向任意的数据段。cs寄存器还有一个很重要的功能：它含有一个 两位的字段，用以指明CPU的 当前特权级(Current Privilege Level, CPL)。0代表最高优先级——内核态，而3代表最低优先级——用户态。</p>\n<h3 id=\"段描述符\"><a href=\"#段描述符\" class=\"headerlink\" title=\"段描述符\"></a>段描述符</h3><p>每个段由一个 8字节（64 bit） 的段描述符（Segment Descriptor）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table, GDT）或局部描述符表（Local Descriptor Table, LDT）中。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基地址（Base）</td>\n<td>包含段的首字节的线性地址 （32 bit）</td>\n</tr>\n<tr>\n<td>G</td>\n<td>粒度标志；置0，则段大小以字节为单位，否则以4096字节的倍数计</td>\n</tr>\n<tr>\n<td>Limit</td>\n<td>最大段偏移量，段的长度（20 bit）。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化</td>\n</tr>\n<tr>\n<td>S</td>\n<td>系统标志；置0，系统段，存储诸如LDT这种关键的数据结构，否则它是一个普通的代码段或数据段</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>描述了段的类型特征和它的存取权限</td>\n</tr>\n<tr>\n<td>DPL</td>\n<td>描述符特权级（Descriptor Privilege Level）字段；用于限制对这个段的存取。表示访问这个段要求的CPU最小的优先级</td>\n</tr>\n<tr>\n<td>P</td>\n<td>Segment-Present标志；为0表示段当前不在主存中。Linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去</td>\n</tr>\n<tr>\n<td>D或B</td>\n<td>取决于是代码段还是数据段</td>\n</tr>\n<tr>\n<td>AVL</td>\n<td>操作系统使用，但被Linux忽略</td>\n</tr>\n</tbody>\n</table>\n<p>为加速逻辑地址到线性地址的转换，80x86处理器提供一种附加的非编程的寄存器（不能被编程者设置的寄存器），供6个可编程的段寄存器使用。每一个非编程的寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。之后，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT。</p>\n<h3 id=\"分段单元\"><a href=\"#分段单元\" class=\"headerlink\" title=\"分段单元\"></a>分段单元</h3><p>下图显示一个逻辑地址转换的详细过程，分段单元（segmentation unit）执行以下操作：</p>\n<ul>\n<li>先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。GDT中，分段单元从gdtr寄存器得到GDT的线性基地址；LDT中，分段单元从ldtr寄存器得到LDT的线性基地址。</li>\n<li>从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。</li>\n<li>把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。</li>\n</ul>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.jpg?raw=true\" alt=\"img\"></p>\n<p>有了与段寄存器相关的不可编程寄存器，只有当段寄存器的内容被改变时才需要执行前两个操作。</p>\n<h2 id=\"Linux中的分段\"><a href=\"#Linux中的分段\" class=\"headerlink\" title=\"Linux中的分段\"></a>Linux中的分段</h2><p>2.6版的Linux只有在x86结构下才需要分段。</p>\n<p>运行在用户态的所有Linux进程都使用一对相同的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段。类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：内核代码段和内核数据段。</p>\n<p>下表显示了这4个重要段的段描述符字段的值：</p>\n<table>\n<thead>\n<tr>\n<th>段</th>\n<th>Base</th>\n<th>G</th>\n<th>Limit</th>\n<th>S</th>\n<th>Type</th>\n<th>DPL</th>\n<th>D/B</th>\n<th>p</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用户代码段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>10</td>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>用户数据段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>内核代码段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>10</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>内核数据段</td>\n<td>0x0000 0000</td>\n<td>1</td>\n<td>0xfffff</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>G为1，粒度为4KB，Limit为 0xfffff，则空间为 4GB</p>\n<p>相应的段选择符由宏定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__USER_CS、__USER_DS、__KERNEL_CS、__KERNEL_DS</div></pre></td></tr></table></figure>\n<p>为了对内核代码段寻址，内核只需把__KERNEL_CS宏产生的值装进cs段寄存器即可。</p>\n<p>注意，与段相关的线性地址从0开始，达到2<sup>23</sup> - 1的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</p>\n<p>所有段都从0x0000 0000 开始，那么，在Linux下逻辑地址与线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p>\n<p>当对指向指令或者数据结构的指针进行保存时，内核不需要为其设置逻辑地址的段选择符，因为cs寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条call汇编语言指令，该指令仅指定其逻辑地址的偏移量部分，而段选择符不用设置，它已经隐含在cs寄存器中了。因为“在内核态执行”的段只有一种，叫做代码段，由宏<strong>KERNEL_CS定义，所以只要当CPU切换到内核态时将</strong>KERNEL_CS装载进cs就足够了。同样的道理也适用于指向内核数据结构的指针(隐含地使用ds寄存器)以及指向用户数据结构的指针(内核显式地使用es寄存器)。</p>\n<h3 id=\"Linux-GDT\"><a href=\"#Linux-GDT\" class=\"headerlink\" title=\"Linux GDT\"></a>Linux GDT</h3><p>在单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT。所有的GDT都存放在cpu_gdt_table数组中，而所有GDT的地址和它们的大小(当初始化gdtr寄存器时使用)被存放在cpu_gdt_descr数组中。这些符号都在文件arch/i386/kernel/head.S中被定义。</p>\n<p>下图是GDT的布局示意图。每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg?raw=true\" alt=\"img\"></p>\n<p>每一个GDT中包含的18个段描述符指同下列的段：</p>\n<ul>\n<li>用户态和内核态下的代码段和数据段，共4个。</li>\n<li>任务状态段（TSS），每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，值得特别说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G(粒度)标志被清0，而Limit字段置为0xeb, 因为TSS段是236字节长。Type字段置为9或11(可用的32位TSS)，且DPL置 为0，因为不允许用户态下的进程访问TSS段。</li>\n<li>1个包括缺省局部描述符表的段，这个段通常被所有进程共享。</li>\n<li>3个局部线程存储（Thread-Local Storage, TLS）段：这种机制允许多线程应用程序使用最多3个局部于线程的数据段。系统使用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段。</li>\n<li>与高级电源管理（APM）相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和数据段。</li>\n<li>与支持即插即用（PnP）功能的BIOS服务程序相关的5个段。</li>\n<li>被内核用来处理“双重错误”异常（处理一个异常时可能会引发另一个异常）的特殊TSS段。</li>\n</ul>\n<p>系统中每个处理器都有一个GDT副本。除少数几种情况外，所有GDT的副本都存放相同的表项：</p>\n<ul>\n<li>每个处理器都有它自己的TSS段。</li>\n<li>GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）。</li>\n<li>在某些情况下，处理器可能临时修改GDT副本里的某个项，例如，当调用APM的BIOS例程时就会发生这种情况。</li>\n</ul>\n<h3 id=\"Linux-LDT\"><a href=\"#Linux-LDT\" class=\"headerlink\" title=\"Linux LDT\"></a>Linux LDT</h3><p>大多数用户态下的Linux程序不使用局部描述符表，因此内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述符表存放在default_ldt数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门。调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级（参考Intel文档以获取更多详情）。</p>\n<h2 id=\"硬件中的分页\"><a href=\"#硬件中的分页\" class=\"headerlink\" title=\"硬件中的分页\"></a>硬件中的分页</h2><p>分页单元(paging unit)把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。</p>\n<p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（page）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。我们遵循通常习惯，使用术语“页”既指一组线性地址，又指包含在这组地址中的数据。</p>\n<p>分页单元把所有的RAM分成固定长度的叶框（page frame）（也叫做物理页）。每一个叶框包含一个页，也就是说叶框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p>\n<p>把线性地址映射到物理地址的数据结构称为页表(page table )。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p>\n<p>从80386开始，所有的80x86处理器都支持分页，它通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。&lt;需要了解控制寄存器(cr0~cr3)的结构及作用&gt;</p>\n<h3 id=\"常规分页\"><a href=\"#常规分页\" class=\"headerlink\" title=\"常规分页\"></a>常规分页</h3><p>从80386起，Intel处理器的分页单元处理4KB的页。32位的线性地址被分成3个域：</p>\n<ul>\n<li>Directory（目录）：最高10位</li>\n<li>Table（页表）：中间10位</li>\n<li>Offset（偏移量）：最低12位</li>\n</ul>\n<p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表(page directory)，第二种转换表称为页表(page table )。</p>\n<p>页目录 及 页表都分别存放在1个页中（4KB），其中每个表项也都是4个字节。</p>\n<p>使用这种二级模式的目的在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2<sup>20</sup>个表项(4GB/4KB = 2<sup>20</sup> ，也就是，在每项4个字节时，需要4MB RAM)来表示每个进程的页表(如果进程使用全部4GB线性地址空间)，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些“虚拟内存区”请求页表来减少内存容量。</p>\n<p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更为有效率。</p>\n<p>正在使用的页目录的物理地址存放在控制寄存器cr3中。</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/x86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%88%86%E9%A1%B5.jpg?raw=true\" alt=\"img\"></p>\n<p>页目录项和页表项有相同的结构，每项都包含下面的字段：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Present标志</td>\n<td>置为1，所指的页（或页表）就在主存中；为0，则这一页不在主存，此时这个表项剩余的位可由操作系统用于自己的目的。如果只需一个地址转换所需的页表项或页目录项中Present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。</td>\n</tr>\n<tr>\n<td>包含页框物理地址最高20位的字段</td>\n<td>由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0。若这个字段指向一个页目录，相应的页框就含有一个页表，若指向一个页表，相应的页框就含有一页数据。</td>\n</tr>\n<tr>\n<td>Accessed标志</td>\n<td>每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。</td>\n</tr>\n<tr>\n<td>Dirty标志</td>\n<td>只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，“当选中…………系统去做”。</td>\n</tr>\n<tr>\n<td>Read/Write标志</td>\n<td>含有页或页表的存取权限。</td>\n</tr>\n<tr>\n<td>User/Supervisor标志</td>\n<td>含有访问页或页表所需的特权级。</td>\n</tr>\n<tr>\n<td>PCD和PWT标志</td>\n<td>控制硬件高速缓存处理页或页表的方式。</td>\n</tr>\n<tr>\n<td>Page Size标志</td>\n<td>只应用于页目录项。置为1，则页目录指的是2MB或4MB的页框。</td>\n</tr>\n<tr>\n<td>Global标志</td>\n<td>只应用于页表项。这个标志是在Pentium Pro中引入的，用来防止常用页从TLB（俗称“快表”）高速缓存中刷新出去。只有在cr4寄存器的页全局启用（Page Global Enable, PGE）标志置位时这个标志才起作用。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"扩展分页\"><a href=\"#扩展分页\" class=\"headerlink\" title=\"扩展分页\"></a>扩展分页</h3><p>从Pentium模型开始，80x86微处理器引入了扩展分页（extended paging），它允许页框大小为4MB而不是4KB。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。</p>\n<p>通过设置页目录项的Page Size标志启用扩展分页功能。分页单元吧32位线性地址分成两个字段：</p>\n<ul>\n<li>Directory：最高10位</li>\n<li>Offset：其余22位</li>\n</ul>\n<p>扩展分页和正常分页的目录项基本相同，除了：</p>\n<ul>\n<li>Page Size标志必须被设置。</li>\n<li>32位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0。</li>\n</ul>\n<p>通过设置cr4处理器寄存器的PSE标志能使扩展分页与常规分页共存。</p>\n<h3 id=\"硬件保护方案\"><a href=\"#硬件保护方案\" class=\"headerlink\" title=\"硬件保护方案\"></a>硬件保护方案</h3><p>分页单元和分段单元的保护方案不同。尽管x86处理器允许一个段使用4种可能的特权级别，但与页和页表相关的特权级只有两个，因为特权由User/Supervisor标志所控制。若这个标志为0，只有当CPL小于3(这意味着对于Linux而言，处理器处于内核态)时才能对页寻址。若该标志为1，则总能对页寻址。</p>\n<p>此外，与段的3种存取权限（读、写、执行）不同的是，页的存取权限只有两种（度、写）。如果页目录项或页表项的Read/Write标志等于0，说明相应的页表或页是只读的，否则是可读写的。</p>\n<h3 id=\"物理地址扩展（PAE）分页机制\"><a href=\"#物理地址扩展（PAE）分页机制\" class=\"headerlink\" title=\"物理地址扩展（PAE）分页机制\"></a>物理地址扩展（PAE）分页机制</h3><p>处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器从80386到Pentium使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。</p>\n<p>然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，所以必须扩展32位x86结构所支持的RAM容量。Intel通过在它的处理器上把管脚数从32增加到36已经满足了这些需求。寻址能力可达到2<sup>36</sup> = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。</p>\n<p>从Pentium Pro处理器开始，Intel引入一种叫做 物理地址扩展（Physical Address Extension, PAE）的机制。另外一种叫做页大小扩展[Page Size Extension (PSE-36)]的机制在Pentium 3处理器中引入，但是Linux并没有采用这种机制。</p>\n<p>通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页(在PAE启用时为2MB)。</p>\n<p>Intel为了支持PAE改变了分页机制：</p>\n<ul>\n<li>64GB的RAM被分为2<sup>24</sup>个页框（4KB），页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位(在前面已描述)和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。</li>\n<li>引入一个叫做页目录指针表(Page Directory Pointer Table, PDPT)的页表新级别，它由4个64位表项组成。</li>\n<li>cr3控制寄存器包含一个27位的页目录指针表(PDPT)基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节(25)的倍数上对齐，因此27位足以表示这种表的基地址。</li>\n<li>当把线性地址映射到4KB的页时(页目录项中的PS标志清0), 32位线性地址按下列方式解释：<ul>\n<li>cr3：指向一个PDPT</li>\n<li>位31-30：指向PDPT中4个项中的一个</li>\n<li>位29-21：指向页目录中512个项目中的一个</li>\n<li>位20-12：指向页表中512项中的一个</li>\n<li>位11-0：4KB页中的偏移量</li>\n</ul>\n</li>\n<li>当把线性地址映射到2MB的页时(页目录项中的PS标志置为1), 32位线性地址按下列方式解释：<ul>\n<li>cr3：指向一个PDPT</li>\n<li>位31-30：指向PDPT中4个项中的一个</li>\n<li>位29-21：指向页目录中512个项中的一个</li>\n<li>位20-0：2MB页中的偏移量</li>\n</ul>\n</li>\n</ul>\n<p>总之，一旦cr3被设置，就可能寻址高达4GB RAM。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM，从而显著增加了系统中的进程数量。</p>\n<h3 id=\"64位系统中的分页\"><a href=\"#64位系统中的分页\" class=\"headerlink\" title=\"64位系统中的分页\"></a>64位系统中的分页</h3><table>\n<thead>\n<tr>\n<th>平台名称</th>\n<th>页大小</th>\n<th>寻址使用的位数</th>\n<th>分页级别数</th>\n<th>线性地址分级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alpha</td>\n<td>8KB</td>\n<td>43</td>\n<td>3</td>\n<td>10+10+10+13</td>\n</tr>\n<tr>\n<td>ia64</td>\n<td>4KB</td>\n<td>39</td>\n<td>3</td>\n<td>9+9+9+12</td>\n</tr>\n<tr>\n<td>ppc64</td>\n<td>4KB</td>\n<td>41</td>\n<td>3</td>\n<td>10+10+9+12</td>\n</tr>\n<tr>\n<td>sh64</td>\n<td>4KB</td>\n<td>41</td>\n<td>3</td>\n<td>10+10+9+12</td>\n</tr>\n<tr>\n<td>x86_64</td>\n<td>4KB</td>\n<td>48</td>\n<td>4</td>\n<td>9+9+9+9+12</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转换后援缓冲器（TLB）\"><a href=\"#转换后援缓冲器（TLB）\" class=\"headerlink\" title=\"转换后援缓冲器（TLB）\"></a>转换后援缓冲器（TLB）</h3><p>x86处理器包含了一个称为转换后援缓冲器或TLB(Translation Lookaside Buffer)的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项(TLB entry)中，以便以后对同一个线性地址的引用可以快速地得到转换。</p>\n<p>在多处理系统中，每个CPU都有自己的TLB，叫做该CPU的本地TLB。</p>\n<p>当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。</p>\n<h2 id=\"Linux中的分页\"><a href=\"#Linux中的分页\" class=\"headerlink\" title=\"Linux中的分页\"></a>Linux中的分页</h2><p>Linux采用了一种同时适用于32位和64位系统的普通分页模型。从2.6.11版本开始，采用了四级分页模型。下图中展示的4种页表分别被为：</p>\n<ul>\n<li>页全局目录(Page Global Directory )</li>\n<li>页上级目录(Page Upper Directory )</li>\n<li>页中级目录(Page Middle Directory )</li>\n<li>页表(Page Table)</li>\n</ul>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"img\"></p>\n<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p>\n<p>启用了物理地址扩展（PAE）的32位系统使用了三级页表。Linux的页全局目录对应x86的页目录指针表(PDPT)，取消了页上级目录，页中间目录对应x86的页目录，Linux的页表对应x86的页表。</p>\n<p>最后，64位系统使用二级还是四级分页取决于硬件对线性地址的位的划分。</p>\n<p>Linux的进程处理很大程度上依赖于分页。事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：</p>\n<ul>\n<li>给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误。</li>\n<li>区别页(即一组数据)和页框(即主存中的物理地址)之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。</li>\n</ul>\n<p>每个进程有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内存保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。</p>\n<h3 id=\"物理内存布局\"><a href=\"#物理内存布局\" class=\"headerlink\" title=\"物理内存布局\"></a>物理内存布局</h3><p>可参考 <a href=\"http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html\" target=\"_blank\" rel=\"external\">地址空间布局</a></p>\n<p>在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用。</p>\n<p>内核将下列页框记为保留：</p>\n<ul>\n<li>在不可用的物理地址范围内的页框。</li>\n<li>含有内核代码和已初始化的数据结构的页框。</li>\n</ul>\n<p>保留页框中的页绝不能被动态分配或交换到磁盘上。</p>\n<p>一般来说，Linux内核安装在RAM中从物理地址0x00100000开始的地方，也就是说，从第二个MB开始。所需页框总数依赖干内核的配置方案：典型的配置所得到的内核可以被安装在小于3MB的RAM中。</p>\n<p>为什么内核没有安装在RAM第一个MB开始的地方?因为PC体系结构有几个独特的地方必须考虑到。例如：</p>\n<ul>\n<li>页框0由BIOS使用，存放加电自检(Power-On Self-Test, POST)期间检查到的系统硬件配置。</li>\n<li>物理地址从0x000a0000到0x000fffff的范围通常留给BIOS例程，并且映射ISA图形卡上的内部内存。这个区域就是所有IBM兼容PC上从640KB到1MB之间著名的洞：物理地址存在但被保留，对应的页框不能由操作系统使用。</li>\n<li>第一个MB内的其他页框可能由特定计算机模型保留。例如，IBM Thinkpnd把0xa0页框映射到0x9f页框。</li>\n</ul>\n<p>在启动过程的早期阶段，内核询问BIOS并了解物理内存的大小。在新近的计算机中，内核也调用BIOS过程建立一组物理地址范围和其对应的内存类型。</p>\n<p>随后，内核执行machine_specific_memory_setup()函数，该函数建立物理地址映射。当然，如果这张表是可获取的，那是内核在BIOS列表的基础上构建的。否则，内核按保守的缺省设置构建这张表：从0x9f000(LOWMEMSIZE())到0x100000(HIGH_MEMORY)号的所有页框都标记为保留。</p>\n<table>\n<thead>\n<tr>\n<th>开始</th>\n<th>结束</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x0000 0000</td>\n<td>0x0009 ffff</td>\n<td>Usable</td>\n</tr>\n<tr>\n<td>0x000f 0000</td>\n<td>0x000f ffff</td>\n<td>Reserved</td>\n</tr>\n<tr>\n<td>0x0010 0000</td>\n<td>0x07fe ffff</td>\n<td>Usable</td>\n</tr>\n<tr>\n<td>0x07ff 0000</td>\n<td>0x07ff 2ffff</td>\n<td>ACPI data</td>\n</tr>\n<tr>\n<td>0x07ff 3000</td>\n<td>0x07ff ffff</td>\n<td>ACPI NVS</td>\n</tr>\n<tr>\n<td>0xffff 0000</td>\n<td>0xffff ffff</td>\n<td>Reserved</td>\n</tr>\n</tbody>\n</table>\n<p>上表显示了具有128MB(0x0800 0000) RAM计算机的典型配置。从0x07ff 0000到0x07ff 2fff 的物理地址范围中存有加电自检(POST)阶段由BIOS写入的系统硬件设备信息。在初始化阶段，内核把这些信息拷贝到一个合适的内核数据结构中，然后认为这些页框是可用的。相反，从0x07ff3000到0x07ff ffff的物理地址范围被映射到硬件设备的ROM芯片。从0xffff 0000开始的物理地址范围标记为保留，因为它由硬件映射到BIOS的ROM芯片。注意BIOS也许并不提供一些物理地址范围的信息(在上述表中，范围是0x000a 0000到0x000e ffff)。为安全可靠起见，Linux假定这样的范围是不可用的。</p>\n<p>内核可能不会见到BIOS报告的所有物理内存：例如，如果未使用PAE支持来编译，即使有更大的物理内存可供使用，内核也只能寻址4GB大小的RAM。setup_memory()函数在machine_specific_memory_setup()执行后被调用：它分析物理内存区域表并初始化一些变量来描述内核的物理内存布局。</p>\n<p>为了避免把内核装入一组不连续的页框里，Linux更愿跳过RAM的第一个MB。明确地说，Linux用PC体系结构未保留的页框来动态存放所分配的页。下图显示了Linux怎样填充前3MB的RAM：</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/Linux2.6%E7%9A%84%E5%89%8D768%E4%B8%AA%E9%A1%B5%E6%A1%86%EF%BC%883MB%EF%BC%89.jpg?raw=true\" alt=\"img\"></p>\n<p>符号_text对应于物理地址0x0010 0000 （16MB），表示内核代码第一个字节的地址。内核代码的结束位代由另外一个类似的符号_etext表示。内核数据分为两组：初始化过的数据的和没有初始化的数据。初始化过的数据在_etext后开始，在_edata处结束。紧接着是未初始化的数据并以_end结束。</p>\n<p>图中出现的符号并没有在Linux源代码中定义，它们是编译内核时产生的（可以在System.map文件中找到这些符号，System.map是编译内核以后所创建的）。</p>\n<h3 id=\"进程页表\"><a href=\"#进程页表\" class=\"headerlink\" title=\"进程页表\"></a>进程页表</h3><p>进程的线性地址空间分成两部分：</p>\n<ul>\n<li>从0x0000 0000——0xbfff ffff的线性地址，无论进程运行在用户态还是内核态都可以寻址（0—3GB）。</li>\n<li>从0xc000 0000——0xffff ffff的线性地址，只有内核的进程才能寻址。</li>\n</ul>\n<p>进程运行在用户态时，所产生的线性地址小于0xc000 0000，而运行在内核态时，执行内核代码，所产生的地址大于等于0xc000 0000。但是，在某些情况下，内核为了检索或存放数据必须访问用户态线性地址空间。</p>\n<p>宏PAGE_OFFSET产生的值是0xc000 0000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处。</p>\n<h3 id=\"内核页表\"><a href=\"#内核页表\" class=\"headerlink\" title=\"内核页表\"></a>内核页表</h3><p>内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录(master kernel Page Global Directory)中。系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用；更确切地说，主内核页全局目录的最高目录项部分作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。</p>\n<p>内核初始化自己的页表，这个过程分为两个阶段。事实上，内核映像刚刚被装入内存后，CPU仍然运行于实模式，所以分页功能没有被启用。</p>\n<p>第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。这个最小限度的地址空间仅够将内核装入RAM和对其初始化的核心数据结构。</p>\n<p>第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。下一节解释这个方案是怎样实施的。</p>\n<h3 id=\"临时内核页表\"><a href=\"#临时内核页表\" class=\"headerlink\" title=\"临时内核页表\"></a>临时内核页表</h3><p>临时页全局目录是在内核编译过程中静态地初始化的，而临时页表是由startup_32()汇编语言函数(定义于arch/i386/kernel/head.S)初始化的。不再过多提及页上级目录和页中间目录，因为它们相当于页全局目录项。在这个阶段PAE支持并未激活。</p>\n<p>临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段(_end符号)后面。为简单起见，我们假设内核使用的段、临时页表和128KB的内存范围能容纳于RAM前8MB空间里。为了映射RAM前8MB的空间，需要用到两个页表。</p>\n<p>分页第一个阶段的目标是允许在实模式下和保护模式下都能很容易地对这8MB寻址。因此，内核必须创建一个映射，把从0x0000 0000到0x007f ffff的线性地址和从0xc000 0000到0xc07f ffff的线性地址映射到从0x0000 0000到0x007f ffff的物理地址。换句话说，内核在初始化的第一阶段，可以通过与物理地址相同的线性地址或者通过从0xc000 0000开始的8MB线性地址对RAM的前8MB进行寻址。</p>\n<p>内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射，不过，0、1、0x300(十进制768)和0x301(十进制769)这四项除外。后两项包含了从0xc000 0000到0xc07f ffff间的所有线性地址。0、1、0x300和0x301按以下方式初始化：</p>\n<ul>\n<li>0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段 置为紧随pg0后的页框的物理地址。</li>\n<li>把这四个项中的Present、Read/Write和User/Supervisor标志置位。</li>\n<li>把这四个项中的Accessed、Dirty、PCD、PWD和Page Size标志清0。</li>\n</ul>\n<p>汇编语言函数startup_32()也启用分页单元，通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG标志来达到这一目的。下面是等价的代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">movl $swapper_pg_dir-0xc0000000,%eax</div><div class=\"line\">movl %eax,%cr3      /*设置页表指针*/</div><div class=\"line\">movl %cr0,%eax</div><div class=\"line\">orl $0x80000000,%eax</div><div class=\"line\">movl %eax,%cr0      /*设置分页(PG)位“/</div></pre></td></tr></table></figure>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: Diary\ntags:\n  - Testing\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-09-14T17:57:49.847Z","updated":"2017-09-14T17:57:49.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7omlvie0008ckfydcsu5q7t","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"处理器发展的两种处理模式：实模式和保护模式","date":"2017-09-08T16:48:42.000Z","_content":"\nIntel从80286开始引入保护模式，并与之前已存在的实模式并存。作为CPU运行的两种工作方式，具体有何区别，本文对其做简要说明。\n\n## 实模式\n\n80286之前，处理器的内部数据总线、外部数据总线及位宽都是16位，但地址总线（物理引脚）为20位。因此它的可访问物理地址空间为 1MB（2<sup>20</sup>字节）。\n\n但是，由于其数据总线及位宽都是16位，最大只能代表有64KB的空间，小于地址总线能代表的1MB空间。为了解决这个问题，设计人员通过用16位的段寄存器内容左移4位，并和16位的段内偏移相加组成的20位代表1MB空间：物理地址 = (段寄存器内容 << 4) + 段内偏移。\n\n通过这种方式能表示的内存地址最大范围即为：0xfff << 4 + 0xffff = 0x10 ffef。已大于1MB，为使地址正常访问，对已得地址对1MB取模，此方法称为 wrap-around。\n\n现代处理器地址总线数已远超20，但是为了向下兼容，系统刚加电时依旧使用实模式。\n\n## 保护模式\n\n实模式带来了一些问题，主要是物理地址可见带来的无法保证地址空间的安全性问题：不区分系统程序及用户程序，用户可随意更改处于物理内存的敏感数据，极易导致系统崩溃。因此引入保护模式。\n\n以现在32位处理器为例：内部数据总线、外部数据总线、位宽及地址总线都为32位。\n\n处于保护模式时，寻址方式发生些许改变：由逻辑地址转换为物理地址（开启分页时，中间需通过线性地址进行转换，本文不开启分页）。\n\n逻辑地址由 16位段选择符和32位偏移量组成。段选择符格式如下图：\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true)\n\n \n\n| 字段名  | 描述                                       |\n| ---- | ---------------------------------------- |\n| 索引   | 指定了放在GDT或LDT中的相应段描述符的入口                  |\n| TI   | TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） |\n| RPL  | 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 |\n\n索引指向存放在GDT（Global Descriptor Table，全局描述符表）或LDT（Local Descriptor Table，局部描述符表）中的段描述符，而段描述符中会存放段基地址，将得到的段基地址与逻辑地址中的段偏移量相加即得物理内存地址。\n\n## 总结\n\n实模式中内存被划分成段，每个段的大小为64KB，而这样的段地址可以用16位来表示。内存段的处理是通过和段寄存器相关联的内部机制来处理的，这些段寄存器（CS、DS、 SS和ES）的内容形成了物理地址的一部分。具体来说，最终的物理地址是由16位的段寄存器和16位的段内偏移地址组成的。\n\n在保护模式下，段是通过一系列被称之为“描述符表”的表所定义的。段寄存器存储的段选择符，指向GDT或LDT中的位置。","source":"_posts/处理器发展的两种处理模式：实模式和保护模式.md","raw":"---\ntitle: 处理器发展的两种处理模式：实模式和保护模式\ndate: 2017-09-09 00:48:42\ncategories: 处理器工作方式\ntags:\n  - 实模式\n  - 保护模式\n---\n\nIntel从80286开始引入保护模式，并与之前已存在的实模式并存。作为CPU运行的两种工作方式，具体有何区别，本文对其做简要说明。\n\n## 实模式\n\n80286之前，处理器的内部数据总线、外部数据总线及位宽都是16位，但地址总线（物理引脚）为20位。因此它的可访问物理地址空间为 1MB（2<sup>20</sup>字节）。\n\n但是，由于其数据总线及位宽都是16位，最大只能代表有64KB的空间，小于地址总线能代表的1MB空间。为了解决这个问题，设计人员通过用16位的段寄存器内容左移4位，并和16位的段内偏移相加组成的20位代表1MB空间：物理地址 = (段寄存器内容 << 4) + 段内偏移。\n\n通过这种方式能表示的内存地址最大范围即为：0xfff << 4 + 0xffff = 0x10 ffef。已大于1MB，为使地址正常访问，对已得地址对1MB取模，此方法称为 wrap-around。\n\n现代处理器地址总线数已远超20，但是为了向下兼容，系统刚加电时依旧使用实模式。\n\n## 保护模式\n\n实模式带来了一些问题，主要是物理地址可见带来的无法保证地址空间的安全性问题：不区分系统程序及用户程序，用户可随意更改处于物理内存的敏感数据，极易导致系统崩溃。因此引入保护模式。\n\n以现在32位处理器为例：内部数据总线、外部数据总线、位宽及地址总线都为32位。\n\n处于保护模式时，寻址方式发生些许改变：由逻辑地址转换为物理地址（开启分页时，中间需通过线性地址进行转换，本文不开启分页）。\n\n逻辑地址由 16位段选择符和32位偏移量组成。段选择符格式如下图：\n\n![img](https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true)\n\n \n\n| 字段名  | 描述                                       |\n| ---- | ---------------------------------------- |\n| 索引   | 指定了放在GDT或LDT中的相应段描述符的入口                  |\n| TI   | TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1） |\n| RPL  | 请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级 |\n\n索引指向存放在GDT（Global Descriptor Table，全局描述符表）或LDT（Local Descriptor Table，局部描述符表）中的段描述符，而段描述符中会存放段基地址，将得到的段基地址与逻辑地址中的段偏移量相加即得物理内存地址。\n\n## 总结\n\n实模式中内存被划分成段，每个段的大小为64KB，而这样的段地址可以用16位来表示。内存段的处理是通过和段寄存器相关联的内部机制来处理的，这些段寄存器（CS、DS、 SS和ES）的内容形成了物理地址的一部分。具体来说，最终的物理地址是由16位的段寄存器和16位的段内偏移地址组成的。\n\n在保护模式下，段是通过一系列被称之为“描述符表”的表所定义的。段寄存器存储的段选择符，指向GDT或LDT中的位置。","slug":"处理器发展的两种处理模式：实模式和保护模式","published":1,"updated":"2017-09-11T07:05:52.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7omlvil0009ckfytlc4nfb4","content":"<p>Intel从80286开始引入保护模式，并与之前已存在的实模式并存。作为CPU运行的两种工作方式，具体有何区别，本文对其做简要说明。</p>\n<h2 id=\"实模式\"><a href=\"#实模式\" class=\"headerlink\" title=\"实模式\"></a>实模式</h2><p>80286之前，处理器的内部数据总线、外部数据总线及位宽都是16位，但地址总线（物理引脚）为20位。因此它的可访问物理地址空间为 1MB（2<sup>20</sup>字节）。</p>\n<p>但是，由于其数据总线及位宽都是16位，最大只能代表有64KB的空间，小于地址总线能代表的1MB空间。为了解决这个问题，设计人员通过用16位的段寄存器内容左移4位，并和16位的段内偏移相加组成的20位代表1MB空间：物理地址 = (段寄存器内容 &lt;&lt; 4) + 段内偏移。</p>\n<p>通过这种方式能表示的内存地址最大范围即为：0xfff &lt;&lt; 4 + 0xffff = 0x10 ffef。已大于1MB，为使地址正常访问，对已得地址对1MB取模，此方法称为 wrap-around。</p>\n<p>现代处理器地址总线数已远超20，但是为了向下兼容，系统刚加电时依旧使用实模式。</p>\n<h2 id=\"保护模式\"><a href=\"#保护模式\" class=\"headerlink\" title=\"保护模式\"></a>保护模式</h2><p>实模式带来了一些问题，主要是物理地址可见带来的无法保证地址空间的安全性问题：不区分系统程序及用户程序，用户可随意更改处于物理内存的敏感数据，极易导致系统崩溃。因此引入保护模式。</p>\n<p>以现在32位处理器为例：内部数据总线、外部数据总线、位宽及地址总线都为32位。</p>\n<p>处于保护模式时，寻址方式发生些许改变：由逻辑地址转换为物理地址（开启分页时，中间需通过线性地址进行转换，本文不开启分页）。</p>\n<p>逻辑地址由 16位段选择符和32位偏移量组成。段选择符格式如下图：</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引</td>\n<td>指定了放在GDT或LDT中的相应段描述符的入口</td>\n</tr>\n<tr>\n<td>TI</td>\n<td>TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1）</td>\n</tr>\n<tr>\n<td>RPL</td>\n<td>请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td>\n</tr>\n</tbody>\n</table>\n<p>索引指向存放在GDT（Global Descriptor Table，全局描述符表）或LDT（Local Descriptor Table，局部描述符表）中的段描述符，而段描述符中会存放段基地址，将得到的段基地址与逻辑地址中的段偏移量相加即得物理内存地址。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实模式中内存被划分成段，每个段的大小为64KB，而这样的段地址可以用16位来表示。内存段的处理是通过和段寄存器相关联的内部机制来处理的，这些段寄存器（CS、DS、 SS和ES）的内容形成了物理地址的一部分。具体来说，最终的物理地址是由16位的段寄存器和16位的段内偏移地址组成的。</p>\n<p>在保护模式下，段是通过一系列被称之为“描述符表”的表所定义的。段寄存器存储的段选择符，指向GDT或LDT中的位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Intel从80286开始引入保护模式，并与之前已存在的实模式并存。作为CPU运行的两种工作方式，具体有何区别，本文对其做简要说明。</p>\n<h2 id=\"实模式\"><a href=\"#实模式\" class=\"headerlink\" title=\"实模式\"></a>实模式</h2><p>80286之前，处理器的内部数据总线、外部数据总线及位宽都是16位，但地址总线（物理引脚）为20位。因此它的可访问物理地址空间为 1MB（2<sup>20</sup>字节）。</p>\n<p>但是，由于其数据总线及位宽都是16位，最大只能代表有64KB的空间，小于地址总线能代表的1MB空间。为了解决这个问题，设计人员通过用16位的段寄存器内容左移4位，并和16位的段内偏移相加组成的20位代表1MB空间：物理地址 = (段寄存器内容 &lt;&lt; 4) + 段内偏移。</p>\n<p>通过这种方式能表示的内存地址最大范围即为：0xfff &lt;&lt; 4 + 0xffff = 0x10 ffef。已大于1MB，为使地址正常访问，对已得地址对1MB取模，此方法称为 wrap-around。</p>\n<p>现代处理器地址总线数已远超20，但是为了向下兼容，系统刚加电时依旧使用实模式。</p>\n<h2 id=\"保护模式\"><a href=\"#保护模式\" class=\"headerlink\" title=\"保护模式\"></a>保护模式</h2><p>实模式带来了一些问题，主要是物理地址可见带来的无法保证地址空间的安全性问题：不区分系统程序及用户程序，用户可随意更改处于物理内存的敏感数据，极易导致系统崩溃。因此引入保护模式。</p>\n<p>以现在32位处理器为例：内部数据总线、外部数据总线、位宽及地址总线都为32位。</p>\n<p>处于保护模式时，寻址方式发生些许改变：由逻辑地址转换为物理地址（开启分页时，中间需通过线性地址进行转换，本文不开启分页）。</p>\n<p>逻辑地址由 16位段选择符和32位偏移量组成。段选择符格式如下图：</p>\n<p><img src=\"https://github.com/LiuChengqian90/Study-notes/blob/master/image/Linux/%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg?raw=true\" alt=\"img\"></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引</td>\n<td>指定了放在GDT或LDT中的相应段描述符的入口</td>\n</tr>\n<tr>\n<td>TI</td>\n<td>TI（Table Indicator）标志，指明段描述符是在GDT中（TI=0）或在LDT中（TI=1）</td>\n</tr>\n<tr>\n<td>RPL</td>\n<td>请求者特权级，当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级</td>\n</tr>\n</tbody>\n</table>\n<p>索引指向存放在GDT（Global Descriptor Table，全局描述符表）或LDT（Local Descriptor Table，局部描述符表）中的段描述符，而段描述符中会存放段基地址，将得到的段基地址与逻辑地址中的段偏移量相加即得物理内存地址。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实模式中内存被划分成段，每个段的大小为64KB，而这样的段地址可以用16位来表示。内存段的处理是通过和段寄存器相关联的内部机制来处理的，这些段寄存器（CS、DS、 SS和ES）的内容形成了物理地址的一部分。具体来说，最终的物理地址是由16位的段寄存器和16位的段内偏移地址组成的。</p>\n<p>在保护模式下，段是通过一系列被称之为“描述符表”的表所定义的。段寄存器存储的段选择符，指向GDT或LDT中的位置。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj7omlvhf0000ckfyq6bruvby","category_id":"cj7omlvhz0004ckfyfibshc9u","_id":"cj7omlviq000cckfyqrz4afny"},{"post_id":"cj7omlvhs0002ckfyfsm3v9l6","category_id":"cj7omlvin000ackfy0ajz3qk3","_id":"cj7omlviw000hckfyppjnu0j5"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","category_id":"cj7omlvir000dckfygdiga65d","_id":"cj7omlvj0000kckfyktqbko19"},{"post_id":"cj7omlvie0008ckfydcsu5q7t","category_id":"cj7omlviw000jckfy3sr6menp","_id":"cj7omlvj3000pckfy6dht8vkj"},{"post_id":"cj7omlvil0009ckfytlc4nfb4","category_id":"cj7omlvj0000mckfy5ggr60rn","_id":"cj7omlvj4000rckfyfucesqj1"}],"PostTag":[{"post_id":"cj7omlvhf0000ckfyq6bruvby","tag_id":"cj7omlvi60005ckfydoqmxfvc","_id":"cj7omlviv000fckfydo4zp7ui"},{"post_id":"cj7omlvhf0000ckfyq6bruvby","tag_id":"cj7omlvio000bckfy9sjva22q","_id":"cj7omlviw000gckfy8hqfayet"},{"post_id":"cj7omlvhs0002ckfyfsm3v9l6","tag_id":"cj7omlvio000bckfy9sjva22q","_id":"cj7omlvj1000nckfy5gsyvw7x"},{"post_id":"cj7omlvhs0002ckfyfsm3v9l6","tag_id":"cj7omlviw000ickfy9lqmkab1","_id":"cj7omlvj2000ockfyxe8fbtrt"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","tag_id":"cj7omlvj0000lckfyieb3clq8","_id":"cj7omlvjd000wckfyswnqaicx"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","tag_id":"cj7omlvj3000qckfyyfqlcci0","_id":"cj7omlvjd000xckfy46ewctvb"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","tag_id":"cj7omlvj5000sckfym4lhfm21","_id":"cj7omlvje000zckfy6hfnayez"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","tag_id":"cj7omlvj6000tckfynglho3q8","_id":"cj7omlvjf0010ckfyjo3cucjz"},{"post_id":"cj7omlvi80006ckfyskuxw0fi","tag_id":"cj7omlvja000uckfy9b3o3alo","_id":"cj7omlvjh0012ckfyudmfzjzt"},{"post_id":"cj7omlvie0008ckfydcsu5q7t","tag_id":"cj7omlvjc000vckfy3u8uqvdi","_id":"cj7omlvji0013ckfyvjloydml"},{"post_id":"cj7omlvil0009ckfytlc4nfb4","tag_id":"cj7omlvjd000yckfyrubg7jy8","_id":"cj7omlvjl0014ckfyht30158m"},{"post_id":"cj7omlvil0009ckfytlc4nfb4","tag_id":"cj7omlvjg0011ckfyz56b57t0","_id":"cj7omlvjl0015ckfyid57j5zq"}],"Tag":[{"name":"寄存器","_id":"cj7omlvi60005ckfydoqmxfvc"},{"name":"CPU","_id":"cj7omlvio000bckfy9sjva22q"},{"name":"处理器","_id":"cj7omlviw000ickfy9lqmkab1"},{"name":"内存寻址","_id":"cj7omlvj0000lckfyieb3clq8"},{"name":"分段","_id":"cj7omlvj3000qckfyyfqlcci0"},{"name":"分页","_id":"cj7omlvj5000sckfym4lhfm21"},{"name":"GDT","_id":"cj7omlvj6000tckfynglho3q8"},{"name":"LDT","_id":"cj7omlvja000uckfy9b3o3alo"},{"name":"Testing","_id":"cj7omlvjc000vckfy3u8uqvdi"},{"name":"实模式","_id":"cj7omlvjd000yckfyrubg7jy8"},{"name":"保护模式","_id":"cj7omlvjg0011ckfyz56b57t0"}]}}