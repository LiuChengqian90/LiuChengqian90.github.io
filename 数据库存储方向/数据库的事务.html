<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="事务的基本概念数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 在执行某些SQL语句的时候，会要求该系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作："><meta property="og:type" content="article"><meta property="og:title" content="数据库的事务"><meta property="og:url" content="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1.html"><meta property="og:site_name" content="工作日志"><meta property="og:description" content="事务的基本概念数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 在执行某些SQL语句的时候，会要求该系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作："><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-07-10T11:57:52.000Z"><meta property="article:modified_time" content="2022-04-02T09:58:08.460Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="事务"><meta property="article:tag" content="ACID"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>数据库的事务 | 工作日志</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="工作日志" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">工作日志</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">事务的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">事务的四个特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Uncommitted"><span class="nav-number">3.1.</span> <span class="nav-text">Read Uncommitted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Committed"><span class="nav-number">3.2.</span> <span class="nav-text">Read Committed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repeatable-Read"><span class="nav-number">3.3.</span> <span class="nav-text">Repeatable Read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable"><span class="nav-number">3.4.</span> <span class="nav-text">Serializable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.5.</span> <span class="nav-text">默认隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.6.</span> <span class="nav-text">查询和设置隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC"><span class="nav-number">4.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">95</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="工作日志"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 数据库的事务</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-10 19:57:52" itemprop="dateCreated datePublished" datetime="2021-07-10T19:57:52+08:00">2021-07-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-04-02 17:58:08" itemprop="dateModified" datetime="2022-04-02T17:58:08+08:00">2022-04-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span></span><span id="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1.html" class="post-meta-item leancloud_visitors" data-flag-title="数据库的事务" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h2><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><p>在执行某些SQL语句的时候，会要求该系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一步：将id=1的A账户余额减去100</span></span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：将id=2的B账户余额加上100</span></span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><p>这种把<strong>多条语句作为一个整体进行操作的功能，被称为数据库事务</strong>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>数据库事务具有ACID这4个特性：</p><ul><li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistent：一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离。但实际上，事务并发时并没有完全隔离，互相会有影响，<strong>需要设置隔离级别</strong>。例如同时有T1和T2两个并发事务，从T1角度来看，T2要不在T1执行之前就已经结束，要么在T1执行完成后才开始。将多个事务隔离开，每个事务都不能访问到其他事务操作过程中的状态。</li><li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>隐式事务和显式事务：</p><ul><li>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</li><li>要手动把多条SQL语句作为一个事务执行，使用 BEGIN（MySQL中也可以用START TRANSACTION）开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<strong>显式事务。</strong><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。多条SQL语句要想作为一个事务执行，就必须使用显式事务。</li></ul><p>例如，把上述的转账操作作为一个显式事务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  -- MySQL中也可以用START TRANSACTION</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th align="left">Isolation Level</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（Non Repeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">Read Uncommitted</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Read Committed</td><td align="left">-</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Repeatable Read</td><td align="left">-</td><td align="left">-</td><td align="left">Yes</td></tr><tr><td align="left">Serializable</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr></tbody></table><h3 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h3><p>Read Uncommitted(读未提交)是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p><p>测试例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from students;</span></span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1;</td></tr><tr><td align="left">5</td><td align="left">ROLLBACK;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1;</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p><p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p><p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p><h3 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h3><p>在Read Committed(读已提交)隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from students;</span></span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td><td align="left">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1;</td></tr><tr><td align="left">4</td><td align="left">UPDATE students SET name = ‘Bob’ WHERE id = 1;</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 1;</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p><h3 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h3><p>在Repeatable Read(可重复读)隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p>我们仍然先准备好<code>students</code>表的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from students;</span></span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td><td align="left">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td></tr><tr><td align="left">2</td><td align="left">BEGIN;</td><td align="left">BEGIN;</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99;</td></tr><tr><td align="left">4</td><td align="left">INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">COMMIT;</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99;</td></tr><tr><td align="left">7</td><td align="left"></td><td align="left">UPDATE students SET name = ‘Alice’ WHERE id = 99;</td></tr><tr><td align="left">8</td><td align="left"></td><td align="left">SELECT * FROM students WHERE id = 99;</td></tr><tr><td align="left">9</td><td align="left"></td><td align="left">COMMIT;</td></tr></tbody></table><p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p><p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable(串行化)是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><h3 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h3><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p><h3 id="查询和设置隔离级别"><a href="#查询和设置隔离级别" class="headerlink" title="查询和设置隔离级别"></a>查询和设置隔离级别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;   -- 查看当前会话的隔离级别</span><br><span class="line">select @@global.tx_isolation;   -- 查看全局的隔离级别</span><br></pre></td></tr></table></figure><p>可以通过命令行设置全局或会话的隔离级别，重启数据库或者退出会话对应的隔离级别将会失效。</p><p>设置隔离级别命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;   -- 当未指定设置的是会话还是全局时，默认是设置会话的隔离级别</span><br></pre></td></tr></table></figure><p>具体命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置全局隔离级别</span></span><br><span class="line">set global transaction isolation level REPEATABLE READ;</span><br><span class="line">set global transaction isolation level  READ COMMITTED;</span><br><span class="line">set global transaction isolation level READ UNCOMMITTED;</span><br><span class="line">set global transaction isolation level SERIALIZABLE;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置会话隔离级别</span> </span><br><span class="line">set session transaction isolation level REPEATABLE READ;</span><br><span class="line">set session transaction isolation level READ COMMITTED;</span><br><span class="line">set session transaction isolation level READ UNCOMMITTED;</span><br><span class="line">set session transaction isolation level SERIALIZABLE;</span><br></pre></td></tr></table></figure><p>当同时设置了会话和全局的隔离级别时，当前会话的隔离级别的设置是由当前会话所设置的隔离级别决定的。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC就是用来实现上面的第三个隔离级别，可重复读RR。</p><blockquote><p><strong>MVCC</strong>：Multi-Version Concurrency Control，即多版本的并发控制协议。</p></blockquote><p>MVCC的特点就是在同一时刻，不同事务可以读取到不同版本的数据，从而可以解决脏读和不可重复读的问题。</p><p>MVCC实际上就是通过<strong>数据的隐藏列和回滚日志（undo log）</strong>，实现多个版本数据的共存。这样的好处是，使用MVCC进行读数据的时候，不用加锁，从而避免了同时读写的冲突。</p><p>在实现MVCC时，每一行的数据中会额外保存几个隐藏的列，比如当前行创建时的版本号和删除时间和指向undo log的回滚指针。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p><p>每个事务又有自己的版本号，这样事务内执行数据操作时，就通过版本号的比较来达到数据版本控制的目的。</p><p>另外，InnoDB实现的隔离级别RR时可以避免幻读现象的，这是通过<code>next-key lock</code>机制实现的。</p><p><code>next-key lock</code>实际上就是行锁的一种，只不过它不只是会锁住当前行记录的本身，还会锁定一个范围。比如查询0&lt;阅读量&lt;100的文章时，只查到了一个结果。<code>next-key lock</code>会将查询出的这一行进行锁定，<strong>同时还会对0&lt;阅读量&lt;100这个范围进行加锁</strong>，这实际上是一种间隙锁。间隙锁能够防止其他事务在这个间隙修改或者插入记录。这样一来，就保证了在0&lt;阅读量&lt;100这个间隙中，只存在原来的一行数据，从而避免了幻读。</p><blockquote><p><strong>间隙锁</strong>：封锁索引记录中的间隔</p></blockquote><p>虽然InnoDB使用<code>next-key lock</code>能够避免幻读问题，但却并不是真正的可串行化隔离。</p><table><thead><tr><th align="left">时刻</th><th align="left">事务A</th><th align="left">事务B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">开始事务</td><td align="left">开始事务</td></tr><tr><td align="left">2</td><td align="left">查询 0 &lt; 阅读量 &lt;100 的文章，结果：文章A，阅读量为99</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">插入一篇文章B，阅读量为50</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">提交事务</td></tr><tr><td align="left">5</td><td align="left">修改 0 &lt; 阅读量 &lt;100 的所有文章的阅读量为10000</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">提交事务</td><td align="left"></td></tr></tbody></table><p>那么 ，在T6时间，事务A提交事务之后，猜一猜文章A和文章B的阅读量为多少？</p><p>答案是，文章AB的阅读量都被修改成了10000。这代表着事务B的提交实际上对事务A的执行产生了影响，表明两个事务之间并不是完全隔离的。虽然能够避免幻读现象，但是却没有达到可串行化的级别。</p><p>这还说明，避免脏读、不可重复读和幻读，是达到可串行化的隔离级别的必要不充分条件。可串行化是都能够避免脏读、不可重复读和幻读，但是避免脏读、不可重复读和幻读却不一定达到了可串行化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cxyxiaowu.com/10740.html">为了让你彻底弄懂 MySQL 事务日志，我通宵肝出了这份图解！</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wenxuehai/p/13485440.html">数据库的事务</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoujinyi/p/3437475.html">MySQL 四种事务隔离级的说明</a></p><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848">事务</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"># 事务</a> <a href="/tags/ACID/" rel="tag"># ACID</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86.html" rel="prev" title="数据库基本概念整理"><i class="fa fa-chevron-left"></i> 数据库基本概念整理</a></div><div class="post-nav-item"> <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%96%B9%E5%90%91/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D.html" rel="next" title="MySQL三大日志介绍">MySQL三大日志介绍<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "数据库存储方向/数据库的事务.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>