<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="ovs版本为 2.8.2。 OVS整体架构"><meta property="og:type" content="article"><meta property="og:title" content="OVS数据收发流程解析"><meta property="og:url" content="http://chengqian90.com/Openvswitch/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.html"><meta property="og:site_name" content="小刘的杂货铺"><meta property="og:description" content="ovs版本为 2.8.2。 OVS整体架构"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://chengqian90.com/images/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/OVS%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png"><meta property="og:image" content="http://chengqian90.com/images/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3master.png"><meta property="article:published_time" content="2017-12-28T07:38:08.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="ovs-patch"><meta property="article:tag" content="ovs-internal"><meta property="article:tag" content="ovs-system"><meta property="article:tag" content="ovs-vxlan"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://chengqian90.com/images/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/OVS%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png"><link rel="canonical" href="http://chengqian90.com/Openvswitch/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>OVS数据收发流程解析 | 小刘的杂货铺</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="小刘的杂货铺" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">小刘的杂货铺</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">OVS整体架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">OVS接口类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system"><span class="nav-number">2.1.</span> <span class="nav-text">system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#internal"><span class="nav-number">2.2.</span> <span class="nav-text">internal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vxlan"><span class="nav-number">2.3.</span> <span class="nav-text">vxlan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patch"><span class="nav-number">2.4.</span> <span class="nav-text">patch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS%E6%8E%A5%E5%8F%A3%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">OVS接口报文处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.1.</span> <span class="nav-text">system接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E5%8C%85%E5%A4%84%E7%90%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">收包处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%8C%85%E5%A4%84%E7%90%86"><span class="nav-number">3.1.2.</span> <span class="nav-text">发包处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#internal%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.2.</span> <span class="nav-text">internal接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E5%8C%85%E5%A4%84%E7%90%86-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">收包处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%8C%85%E5%A4%84%E7%90%86-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">发包处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vxlan%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.3.</span> <span class="nav-text">vxlan接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">优秀资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">85</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">130</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/Openvswitch/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小刘的杂货铺"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> OVS数据收发流程解析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-12-28 15:38:08" itemprop="dateCreated datePublished" datetime="2017-12-28T15:38:08+08:00">2017-12-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/openvswitch/" itemprop="url" rel="index"><span itemprop="name">openvswitch</span></a></span></span><span id="/Openvswitch/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.html" class="post-meta-item leancloud_visitors" data-flag-title="OVS数据收发流程解析" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>15k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>ovs版本为 2.8.2。</p><h2 id="OVS整体架构"><a href="#OVS整体架构" class="headerlink" title="OVS整体架构"></a>OVS整体架构</h2><span id="more"></span><p>OVS架构图如下，具体每个部件功能不具体分析，本文主要涉及内核部分。</p><p><img src="/images/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/OVS%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="OVS内部结构"></p><h2 id="OVS接口类型"><a href="#OVS接口类型" class="headerlink" title="OVS接口类型"></a>OVS接口类型</h2><p>执行命令<code>ovs-vsctl show</code> 或者 <code>ovs-dpctl show</code>(显示默认datapath)，来查看ovs接口信息时，常会看到接口类型，以下对OVS中有哪些接口类型及不同接口类型的接口之间的区别进行分析。</p><p>在源码中有这么一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">get_vport_type(<span class="keyword">const</span> struct dpif_netlink_vport *vport)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vlog_rate_limit</span> <span class="title">rl</span> =</span> VLOG_RATE_LIMIT_INIT(<span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (vport-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_NETDEV: &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type = netdev_get_type_from_name(vport-&gt;name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type ? type : <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_INTERNAL:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;internal&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_GENEVE:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;geneve&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_GRE:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;gre&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_VXLAN:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;vxlan&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_LISP:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;lisp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_STT:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;stt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OVS_VPORT_TYPE_UNSPEC:</span><br><span class="line">    <span class="keyword">case</span> __OVS_VPORT_TYPE_MAX:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VLOG_WARN_RL(&amp;rl, <span class="string">&quot;dp%d: port `%s&#x27; has unsupported type %u&quot;</span>,</span><br><span class="line">                 vport-&gt;dp_ifindex, vport-&gt;name, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) vport-&gt;type);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出，<code>ovs-vsctl show</code>时的类型显示在内核中都有对应关系。宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ovs_vport_type</span> &#123;</span></span><br><span class="line">	OVS_VPORT_TYPE_UNSPEC,</span><br><span class="line">	OVS_VPORT_TYPE_NETDEV,   <span class="comment">/* network device */</span></span><br><span class="line">	OVS_VPORT_TYPE_INTERNAL, <span class="comment">/* network device implemented by datapath */</span></span><br><span class="line">	OVS_VPORT_TYPE_GRE,      <span class="comment">/* GRE tunnel. */</span></span><br><span class="line">	OVS_VPORT_TYPE_VXLAN,	 <span class="comment">/* VXLAN tunnel. */</span></span><br><span class="line">	OVS_VPORT_TYPE_GENEVE,	 <span class="comment">/* Geneve tunnel. */</span></span><br><span class="line">	OVS_VPORT_TYPE_LISP = <span class="number">105</span>,  <span class="comment">/* LISP tunnel */</span></span><br><span class="line">	OVS_VPORT_TYPE_STT = <span class="number">106</span>, <span class="comment">/* STT tunnel */</span></span><br><span class="line">	__OVS_VPORT_TYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面，选取具有代表性的几个类型进行分析。</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>此类vport（<code>ovs-dpctl show</code>未显示类型的接口）是对设备原有接口的封装，内核类型为’OVS_VPORT_TYPE_NETDEV’。定义的vport操作变量为’ovs_netdev_vport_ops’。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vport_ops</span> <span class="title">ovs_netdev_vport_ops</span> =</span> &#123;</span><br><span class="line">	.type		= OVS_VPORT_TYPE_NETDEV,</span><br><span class="line">	.create		= netdev_create,</span><br><span class="line">	.destroy	= netdev_destroy,</span><br><span class="line">	.send		= dev_queue_xmit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此种接口创建内部比较特殊，因此需要特殊强调。在’netdev_create’中有一段如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct vport *<span class="title">netdev_create</span><span class="params">(<span class="keyword">const</span> struct vport_parms *parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line"></span><br><span class="line">	vport = ovs_vport_alloc(<span class="number">0</span>, &amp;ovs_netdev_vport_ops, parms);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(vport))</span><br><span class="line">		<span class="keyword">return</span> vport;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ovs_netdev_link(vport, parms-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct vport *<span class="title">ovs_vport_alloc</span><span class="params">(<span class="keyword">int</span> priv_size, <span class="keyword">const</span> struct vport_ops *ops,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">const</span> struct vport_parms *parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alloc_size;</span><br><span class="line">	<span class="comment">/*vport分配空间*/</span></span><br><span class="line">	alloc_size = <span class="keyword">sizeof</span>(struct vport);</span><br><span class="line">	<span class="keyword">if</span> (priv_size) &#123;</span><br><span class="line">		alloc_size = ALIGN(alloc_size, VPORT_ALIGN);</span><br><span class="line">		alloc_size += priv_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vport = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!vport)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	vport-&gt;dp = parms-&gt;dp;</span><br><span class="line">	vport-&gt;port_no = parms-&gt;port_no;</span><br><span class="line">	vport-&gt;ops = ops;</span><br><span class="line">	INIT_HLIST_NODE(&amp;vport-&gt;dp_hash_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ovs_vport_set_upcall_portids(vport, parms-&gt;upcall_portids)) &#123;</span><br><span class="line">		kfree(vport);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct vport *<span class="title">ovs_netdev_link</span><span class="params">(struct vport *vport, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="comment">/*此种类型接口是对系统原有口的映射，因此dev赋值为系统原有接口的dev*/</span></span><br><span class="line">	vport-&gt;dev = dev_get_by_name(ovs_dp_get_net(vport-&gt;dp), name);</span><br><span class="line">	<span class="keyword">if</span> (!vport-&gt;dev) &#123;</span><br><span class="line">		err = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> error_free_vport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*系统接口为以下情况是报错退出：</span></span><br><span class="line"><span class="comment">	- loopback口</span></span><br><span class="line"><span class="comment">   	- 非ARPHRD_ETHER接口</span></span><br><span class="line"><span class="comment">    - OVS_VPORT_TYPE_INTERNAL类型接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (vport-&gt;dev-&gt;flags &amp; IFF_LOOPBACK ||</span><br><span class="line">	    vport-&gt;dev-&gt;type != ARPHRD_ETHER ||</span><br><span class="line">	    ovs_is_internal_dev(vport-&gt;dev)) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> error_put;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*所有system都是datapatch 接口的slave接口；</span></span><br><span class="line"><span class="comment">	默认只要一个datapath接口(ovs-system)，所有system类型的master都为此接口。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	err = netdev_master_upper_dev_link(vport-&gt;dev,</span><br><span class="line">					   get_dpdev(vport-&gt;dp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error_unlock;</span><br><span class="line"></span><br><span class="line">	err = netdev_rx_handler_register(vport-&gt;dev, netdev_frame_hook,</span><br><span class="line">					 vport);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error_master_upper_dev_unlink;</span><br><span class="line">	<span class="comment">/*禁用接口的lro功能；*/</span></span><br><span class="line">	dev_disable_lro(vport-&gt;dev);</span><br><span class="line">  	<span class="comment">/*开启混杂模式*/</span></span><br><span class="line">	dev_set_promiscuity(vport-&gt;dev, <span class="number">1</span>);</span><br><span class="line">  	<span class="comment">/*设置接口私有类型*/</span></span><br><span class="line">	vport-&gt;dev-&gt;priv_flags |= IFF_OVS_DATAPATH;</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vport;</span><br><span class="line">…………</span><br><span class="line">…………    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘netdev_rx_handler_register’实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdev_rx_handler_register</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">rx_handler_func_t</span> *rx_handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">void</span> *rx_handler_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ASSERT_RTNL();</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;rx_handler)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	<span class="comment">/* Note: rx_handler_data must be set before rx_handler */</span></span><br><span class="line">  	<span class="comment">/*定义dev收包处理私有数据，即 vport指针，此处完成系统dev到vport的对应。</span></span><br><span class="line"><span class="comment">  	定义接口收包处理函数。*/</span></span><br><span class="line">	rcu_assign_pointer(dev-&gt;rx_handler_data, rx_handler_data);</span><br><span class="line">	rcu_assign_pointer(dev-&gt;rx_handler, rx_handler);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类接口定义了 ‘rx_handler’，因此，在CPU报文处理函数’__netif_receive_skb_core’中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);</span><br><span class="line">……</span><br><span class="line">type = skb-&gt;protocol;</span><br><span class="line">	list_for_each_entry_rcu(ptype,</span><br><span class="line">			&amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ptype-&gt;type == type &amp;&amp;</span><br><span class="line">		    (ptype-&gt;dev == null_or_dev || ptype-&gt;dev == skb-&gt;dev ||</span><br><span class="line">		     ptype-&gt;dev == orig_dev)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pt_prev)</span><br><span class="line">				ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">			pt_prev = ptype;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>也就是说此类接口处理报文在协议栈之前，因此netfilter对此类接口不起作用，所以在云环境（openstack）中，需要在虚拟机tap口与虚拟交换机之间增加Linux bridge设备来使报文经过协议栈（netfilter起作用）来实现security group。</p><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>OVS内部创建的虚拟网卡接口。每创建一个ovs bridge，OVS会自动创建一个同名接口(Interface)挂载到新创建的bridge上。或者也可以通过<code>type=internal</code>把已经挂载的接口设置为‘internal’类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ovs-vsctl add-br ovs-switch</span></span><br><span class="line">/*OpenFlow 端口编号为 100*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> ovs-vsctl add-port ovs-switch p0 -- <span class="built_in">set</span> Interface p0 ofport_request=100</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ovs-vsctl <span class="built_in">set</span> Interface p0 <span class="built_in">type</span>=internal</span></span><br></pre></td></tr></table></figure><p>对于 internal 类型的的网络接口，OVS 会同时在 Linux 系统中创建一个可以用来收发数据的模拟网络设备。我们可以为这个网络设备<strong>配置 IP 地址</strong>、进行数据监听等等。</p><p>内核中对’internal’接口的类型定义为’OVS_VPORT_TYPE_INTERNAL’（network device implemented by datapath，datapath实现的网络设备）。定义的vport操作变量为’ovs_internal_vport_ops’。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vport_ops</span> <span class="title">ovs_internal_vport_ops</span> =</span> &#123;</span><br><span class="line">	.type		= OVS_VPORT_TYPE_INTERNAL,</span><br><span class="line">	.create		= internal_dev_create,</span><br><span class="line">	.destroy	= internal_dev_destroy,</span><br><span class="line">	.send		= internal_dev_recv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口创建时，调用’internal_dev_create’进行接口初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct vport *<span class="title">internal_dev_create</span><span class="params">(<span class="keyword">const</span> struct vport_parms *parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">internal_dev</span> *<span class="title">internal_dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	vport = ovs_vport_alloc(<span class="number">0</span>, &amp;ovs_internal_vport_ops, parms);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(vport)) &#123;</span><br><span class="line">		err = PTR_ERR(vport);</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*内核创建接口，初始之后调用do_setup 初始化其他变量*/</span></span><br><span class="line">	vport-&gt;dev = alloc_netdev(<span class="keyword">sizeof</span>(struct internal_dev),</span><br><span class="line">				  parms-&gt;name, NET_NAME_USER, do_setup);</span><br><span class="line">	<span class="keyword">if</span> (!vport-&gt;dev) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> error_free_vport;</span><br><span class="line">	&#125;</span><br><span class="line">	vport-&gt;dev-&gt;tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);</span><br><span class="line">	<span class="keyword">if</span> (!vport-&gt;dev-&gt;tstats) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> error_free_netdev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_IFF_PHONY_HEADROOM</span></span><br><span class="line">	vport-&gt;dev-&gt;needed_headroom = vport-&gt;dp-&gt;max_headroom;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  	<span class="comment">/*设置接口nd_net属性*/</span></span><br><span class="line">	dev_net_set(vport-&gt;dev, ovs_dp_get_net(vport-&gt;dp));</span><br><span class="line">  	<span class="comment">/*dev私有数据 映射*/</span></span><br><span class="line">	internal_dev = internal_dev_priv(vport-&gt;dev);</span><br><span class="line">	internal_dev-&gt;vport = vport;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restrict bridge port to current netns. */</span></span><br><span class="line">	<span class="keyword">if</span> (vport-&gt;port_no == OVSP_LOCAL)</span><br><span class="line">		vport-&gt;dev-&gt;features |= NETIF_F_NETNS_LOCAL;</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	err = register_netdevice(vport-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error_unlock;</span><br><span class="line">	<span class="comment">/*设置混杂模式*/</span></span><br><span class="line">	dev_set_promiscuity(vport-&gt;dev, <span class="number">1</span>);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line">	netif_start_queue(vport-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vport;</span><br><span class="line">…………</span><br><span class="line">…………    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vxlan"><a href="#vxlan" class="headerlink" title="vxlan"></a>vxlan</h3><ul><li>‘ovs-vsctl show’显示的type 为’vxlan’类型，此种接口为ovs虚拟接口。</li><li>‘ovs-dpctl show’显示的type 为’vxlan’类型，此种接口是对系统的封装，可看做系统口。</li></ul><p>内核中对<code>vxlan</code>类型的接口定义为<code>OVS_VPORT_TYPE_VXLAN</code>。ovs vxlan创建在文件’vport-vxlan.c’中，定义 操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vport_ops</span> <span class="title">ovs_vxlan_netdev_vport_ops</span> =</span> &#123;</span><br><span class="line">	.type			= OVS_VPORT_TYPE_VXLAN,</span><br><span class="line">	.create			= vxlan_create,</span><br><span class="line">	.destroy		= ovs_netdev_tunnel_destroy,</span><br><span class="line">	.get_options		= vxlan_get_options,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USE_UPSTREAM_TUNNEL</span></span><br><span class="line">	.fill_metadata_dst	= vxlan_fill_metadata_dst,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	.send			= vxlan_xmit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>vxlan_create定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct vport *<span class="title">vxlan_create</span><span class="params">(<span class="keyword">const</span> struct vport_parms *parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line">	<span class="comment">/*alloc 创建接口*/</span></span><br><span class="line">	vport = vxlan_tnl_create(parms);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(vport))</span><br><span class="line">		<span class="keyword">return</span> vport;</span><br><span class="line">	<span class="comment">/*link设置*/</span></span><br><span class="line">	<span class="keyword">return</span> ovs_netdev_link(vport, parms-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘ovs_netdev_link’ 函数上面已经分析过，值得注意的是，vxlan类型的接口收包函数也是 ‘netdev_frame_hook’ 。</p><p>基本上系统口都有master，而master为’ovs-system’。</p><p><img src="/images/OVS%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3master.png" alt="系统接口master"></p><p>对于ovs-system作用，还没搞清楚。</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>patch 类型的接口是ovs中比较特殊的类型，其官方定义为“A pair of virtual devices that act as a patch cable”，在系统中运行<code>man 5 ovs-vswitchd.conf.db</code>可看到。</p><p>patch port类似于Linux系统中的<code>veth</code>，总是成对出现，分别连接在两个网桥上，从一个patch port收到的数据包会被转发到另一个patch port。</p><h2 id="OVS接口报文处理"><a href="#OVS接口报文处理" class="headerlink" title="OVS接口报文处理"></a>OVS接口报文处理</h2><h3 id="system接口"><a href="#system接口" class="headerlink" title="system接口"></a>system接口</h3><p>虚拟机利用TUN/TAP端口来与宿主机通信，此种端口是通过命令’ip tuntap add’来创建。ovs对原有接口的封装，也包括这类接口。</p><h4 id="收包处理"><a href="#收包处理" class="headerlink" title="收包处理"></a>收包处理</h4><ol><li>netdev_frame_hook</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called with rcu_read_lock and bottom-halves disabled. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rx_handler_result_t</span> <span class="title">netdev_frame_hook</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> *pskb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"><span class="comment">/*USE_UPSTREAM_TUNNEL管理不同的目的处理*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USE_UPSTREAM_TUNNEL</span></span><br><span class="line">	netdev_port_receive(skb, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	netdev_port_receive(skb, skb_tunnel_info(skb));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>netdev_port_receive</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">netdev_port_receive</span><span class="params">(struct sk_buff *skb, struct ip_tunnel_info *tun_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line">	<span class="comment">/*获取vport数据*/</span></span><br><span class="line">	vport = ovs_netdev_get_vport(skb-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!vport))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="comment">/*接口禁止了lro相关，因此skb需要lro相关则报错退出*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_warn_if_lro(skb)))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">  	<span class="comment">/*user不唯一则进行clone*/</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*恢复二层头，下面用得到*/</span></span><br><span class="line">	skb_push(skb, ETH_HLEN);</span><br><span class="line">  	<span class="comment">/*重新计算校验和*/</span></span><br><span class="line">	skb_postpush_rcsum(skb, skb-&gt;data, ETH_HLEN);</span><br><span class="line">	ovs_vport_receive(vport, skb, tun_info);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">error:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ovs_vport_receive</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ovs_vport_receive</span><span class="params">(struct vport *vport, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct ip_tunnel_info *tun_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_key</span> <span class="title">key</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="comment">/*设置ovs私有数据*/</span></span><br><span class="line">	OVS_CB(skb)-&gt;input_vport = vport;</span><br><span class="line">	OVS_CB(skb)-&gt;mru = <span class="number">0</span>;</span><br><span class="line">	OVS_CB(skb)-&gt;cutlen = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">/*判断是否属于同一个网络空间；可参考 openstack 网络架构 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dev_net(skb-&gt;dev) != ovs_dp_get_net(vport-&gt;dp))) &#123;</span><br><span class="line">		u32 mark;</span><br><span class="line"></span><br><span class="line">		mark = skb-&gt;mark;</span><br><span class="line">		skb_scrub_packet(skb, <span class="literal">true</span>);</span><br><span class="line">		skb-&gt;mark = mark;</span><br><span class="line">		tun_info = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*初始化ovs内部协议号*/</span></span><br><span class="line">	ovs_skb_init_inner_protocol(skb);</span><br><span class="line">	skb_clear_ovs_gso_cb(skb);</span><br><span class="line">	<span class="comment">/*此函数会解析skb内容，并给key中字段赋值*/</span></span><br><span class="line">    <span class="comment">/*注意 input_vport-&gt;port_no 为`ovs-dpctl show`显示的port number*/</span></span><br><span class="line">	error = ovs_flow_key_extract(tun_info, skb, &amp;key);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//内核匹配流表路径，没有则上送。</span></span><br><span class="line">	ovs_dp_process_packet(skb, &amp;key);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ovs_dp_process_packet</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ovs_dp_process_packet</span><span class="params">(struct sk_buff *skb, struct sw_flow_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">p</span> =</span> OVS_CB(skb)-&gt;input_vport;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">datapath</span> *<span class="title">dp</span> =</span> p-&gt;dp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow</span> *<span class="title">flow</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sw_flow_actions</span> *<span class="title">sf_acts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dp_stats_percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line">	u64 *stats_counter;</span><br><span class="line">	u32 n_mask_hit;</span><br><span class="line"></span><br><span class="line">	stats = this_cpu_ptr(dp-&gt;stats_percpu);</span><br><span class="line">	<span class="comment">/*根据key找flow表，没有的话进行upcall；</span></span><br><span class="line"><span class="comment">	此处找的是内核流表，可用`ovs-dpctl dump-flows [dp]`查看。</span></span><br><span class="line"><span class="comment">	本文暂不对这些功能函数进行具体分析*/</span></span><br><span class="line">	flow = ovs_flow_tbl_lookup_stats(&amp;dp-&gt;table, key, skb_get_hash(skb),</span><br><span class="line">					 &amp;n_mask_hit);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!flow)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dp_upcall_info</span> <span class="title">upcall</span>;</span></span><br><span class="line">		<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(&amp;upcall, <span class="number">0</span>, <span class="keyword">sizeof</span>(upcall));</span><br><span class="line">		upcall.cmd = OVS_PACKET_CMD_MISS;</span><br><span class="line">		upcall.portid = ovs_vport_find_upcall_portid(p, skb);</span><br><span class="line">		upcall.mru = OVS_CB(skb)-&gt;mru;</span><br><span class="line">		error = ovs_dp_upcall(dp, skb, key, &amp;upcall, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(error))</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			consume_skb(skb);</span><br><span class="line">		stats_counter = &amp;stats-&gt;n_missed;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*flow填充到skb私有数据，并执行action*/</span></span><br><span class="line">	ovs_flow_stats_update(flow, key-&gt;tp.flags, skb);</span><br><span class="line">	sf_acts = rcu_dereference(flow-&gt;sf_acts);</span><br><span class="line">	ovs_execute_actions(dp, skb, sf_acts, key);</span><br><span class="line"></span><br><span class="line">	stats_counter = &amp;stats-&gt;n_hit;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Update datapath statistics. */</span></span><br><span class="line">	u64_stats_update_begin(&amp;stats-&gt;syncp);</span><br><span class="line">	(*stats_counter)++;</span><br><span class="line">	stats-&gt;n_mask_hit += n_mask_hit;</span><br><span class="line">	u64_stats_update_end(&amp;stats-&gt;syncp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ovs_execute_actions</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute a list of actions against &#x27;skb&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ovs_execute_actions</span><span class="params">(struct datapath *dp, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> struct sw_flow_actions *acts,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct sw_flow_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err, level;</span><br><span class="line">	<span class="comment">/*单个CPU同时处理（准确的说，应该是排队，可能进程调度）4条报文*/</span></span><br><span class="line">	level = __this_cpu_inc_return(exec_actions_level);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(level &gt; OVS_RECURSION_LIMIT)) &#123;</span><br><span class="line">		net_crit_ratelimited(<span class="string">&quot;ovs: recursion limit reached on datapath %s, probable configuration error\n&quot;</span>,</span><br><span class="line">				     ovs_dp_name(dp));</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		err = -ENETDOWN;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行action</span></span><br><span class="line">	err = do_execute_actions(dp, skb, key,</span><br><span class="line">				 acts-&gt;actions, acts-&gt;actions_len);</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Execute a list of actions against &#x27;skb&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execute_actions</span><span class="params">(struct datapath *dp, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct sw_flow_key *key,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">const</span> struct nlattr *attr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">a</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (a = attr, rem = len; rem &gt; <span class="number">0</span>;</span><br><span class="line">	     a = nla_next(a, &amp;rem)) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*获取action type；nla*定义在内核 netlink.h文件中*/</span></span><br><span class="line">		<span class="keyword">switch</span> (nla_type(a)) &#123;</span><br><span class="line">        <span class="comment">/*从某接口转发*/</span></span><br><span class="line">		<span class="keyword">case</span> OVS_ACTION_ATTR_OUTPUT: &#123;</span><br><span class="line">            <span class="comment">//获取 out_port</span></span><br><span class="line">			<span class="keyword">int</span> port = nla_get_u32(a);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">clone</span>;</span></span><br><span class="line">			<span class="comment">/* 每个输出操作都需要一个单独的&#x27;skb&#x27;克隆，如果输出操作是最后一个操作，则可以避免克隆。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (nla_is_last(a, rem)) &#123;</span><br><span class="line">				do_output(dp, skb, port, key);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			clone = skb_clone(skb, GFP_ATOMIC);</span><br><span class="line">			<span class="keyword">if</span> (clone)</span><br><span class="line">				do_output(dp, clone, port, key);</span><br><span class="line">			OVS_CB(skb)-&gt;cutlen = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//其他actions 这里不详细介绍</span></span><br><span class="line">        …………</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	consume_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do_output</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_output</span><span class="params">(struct datapath *dp, struct sk_buff *skb, <span class="keyword">int</span> out_port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vport</span> *<span class="title">vport</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	vport = ovs_vport_rcu(dp, out_port);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!vport)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*vport是flow找到的out_port的vport,因此，此处会调用vport的send函数*/</span></span><br><span class="line">	ovs_vport_send(vport, skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="发包处理"><a href="#发包处理" class="headerlink" title="发包处理"></a>发包处理</h4><p>接口初始化注册的发包函数为’dev_queue_xmit’。</p><h3 id="internal接口"><a href="#internal接口" class="headerlink" title="internal接口"></a>internal接口</h3><h4 id="收包处理-1"><a href="#收包处理-1" class="headerlink" title="收包处理"></a>收包处理</h4><p>internal接口报文一般会从system类型接口传入，从system接口收包处理过程继续，internal类型接口定义的send函数为’internal_dev_recv’。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">netdev_tx_t</span> <span class="title">internal_dev_recv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> skb-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">stats</span>;</span></span><br><span class="line">	<span class="comment">/*接口没有管理UP，直接丢包*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(netdev-&gt;flags &amp; IFF_UP))) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		netdev-&gt;stats.rx_dropped++;</span><br><span class="line">		<span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*初始化dst计数*/</span></span><br><span class="line">	skb_dst_drop(skb);</span><br><span class="line">  	<span class="comment">/*更改某些数据（接口或会话）使用计数*/</span></span><br><span class="line">	nf_reset(skb);</span><br><span class="line">	secpath_reset(skb);</span><br><span class="line">	<span class="comment">/*更改skb接入类型、协议*/</span></span><br><span class="line">	skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, netdev);</span><br><span class="line">	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);</span><br><span class="line"></span><br><span class="line">	stats = this_cpu_ptr(netdev-&gt;tstats);</span><br><span class="line">	u64_stats_update_begin(&amp;stats-&gt;syncp);</span><br><span class="line">	stats-&gt;rx_packets++;</span><br><span class="line">	stats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">	u64_stats_update_end(&amp;stats-&gt;syncp);</span><br><span class="line">	<span class="comment">/*此函数以前的文章分析过，此处不在重复*/</span></span><br><span class="line">	netif_rx(skb);</span><br><span class="line">	<span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发包处理-1"><a href="#发包处理-1" class="headerlink" title="发包处理"></a>发包处理</h4><p>netif_rx函数重新进入了本机协议栈的处理，而internal类型的接口没有设置’rx_handler’，因此进入正常协议栈流程，最后会进入正常转发流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_queue_xmit -&gt; dev_hard_start_xmit -&gt; ops-&gt;ndo_start_xmit(skb, dev);</span><br></pre></td></tr></table></figure><p>而internal在接口创建的时候定义了 ndo_start_xmit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct vport *<span class="title">internal_dev_create</span><span class="params">(<span class="keyword">const</span> struct vport_parms *parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">	vport-&gt;dev = alloc_netdev(<span class="keyword">sizeof</span>(struct internal_dev),</span><br><span class="line">				  parms-&gt;name, NET_NAME_USER, do_setup);</span><br><span class="line">	<span class="keyword">if</span> (!vport-&gt;dev) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> error_free_vport;</span><br><span class="line">	&#125;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">internal_dev_netdev_ops</span> =</span> &#123;</span><br><span class="line">	.ndo_open = internal_dev_open,</span><br><span class="line">	.ndo_stop = internal_dev_stop,</span><br><span class="line">	.ndo_start_xmit = internal_dev_xmit,</span><br><span class="line">	.ndo_set_mac_address = eth_mac_addr,</span><br><span class="line">	.ndo_change_mtu = internal_dev_change_mtu,</span><br><span class="line">	.ndo_get_stats64 = internal_get_stats,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_IFF_PHONY_HEADROOM</span></span><br><span class="line">	.ndo_set_rx_headroom = internal_set_rx_headroom,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_setup</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">	netdev-&gt;netdev_ops = &amp;internal_dev_netdev_ops;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续走读函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">internal_dev_xmit</span><span class="params">(struct sk_buff *skb, struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">  	<span class="comment">/*函数前面已经解析*/</span></span><br><span class="line">	ovs_vport_receive(internal_dev_priv(netdev)-&gt;vport, skb);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">  	……</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vxlan接口"><a href="#vxlan接口" class="headerlink" title="vxlan接口"></a>vxlan接口</h3><p>vxlan接口的 收包处理(netdev_frame_hook) 和 发包处理(vxlan_xmit)，在以前的文章已经分析过。</p><h2 id="优秀资料"><a href="#优秀资料" class="headerlink" title="优秀资料"></a>优秀资料</h2><p><a target="_blank" rel="noopener" href="http://ry0117.com/2016/12/25/OVS%E4%B8%AD%E7%AB%AF%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B/">OVS中端口数据包收发流程</a></p><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/popsuper1982/p/5848879.html">Openvswitch原理与代码分析(1)：总体架构</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/ovs-patch/" rel="tag"># ovs-patch</a> <a href="/tags/ovs-internal/" rel="tag"># ovs-internal</a> <a href="/tags/ovs-system/" rel="tag"># ovs-system</a> <a href="/tags/ovs-vxlan/" rel="tag"># ovs-vxlan</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E5%86%85%E6%A0%B8/Linux%E5%AF%B9vxlan%E7%9A%84%E6%94%AF%E6%8C%81.html" rel="prev" title="Linux对vxlan的支持"><i class="fa fa-chevron-left"></i> Linux对vxlan的支持</a></div><div class="post-nav-item"> <a href="/%E6%9D%82%E8%B0%88/%E7%BD%91%E7%BB%9CRPS-RFS-GSO-GRO%E7%AD%89%E5%8A%9F%E8%83%BD%E9%87%8A%E4%B9%89.html" rel="next" title="网络RPS/RFS/GSO/GRO等功能释义">网络RPS/RFS/GSO/GRO等功能释义<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "Openvswitch/OVS数据收发流程解析.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>