<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="Tips:系统环境为 Ubuntu 16.04，centos系统在namespace支持方面有些问题。 Namespace(命名空间)是一种纯软件方式的资源隔离方案，是Linux Container的基础，也是Docker实现的基础之一。"><meta property="og:type" content="article"><meta property="og:title" content="Linux Namespace简介"><meta property="og:url" content="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-Namespace%E7%AE%80%E4%BB%8B.html"><meta property="og:site_name" content="工作日志"><meta property="og:description" content="Tips:系统环境为 Ubuntu 16.04，centos系统在namespace支持方面有些问题。 Namespace(命名空间)是一种纯软件方式的资源隔离方案，是Linux Container的基础，也是Docker实现的基础之一。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://chengqian90.com/images/Linux-Namespace/PID-Namespace.png"><meta property="og:image" content="http://chengqian90.com/images/Linux-Namespace/mount%E5%90%84%E7%B1%BB%E6%8C%82%E8%BD%BD%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><meta property="article:published_time" content="2017-12-11T07:30:14.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="namespace"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://chengqian90.com/images/Linux-Namespace/PID-Namespace.png"><link rel="canonical" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-Namespace%E7%AE%80%E4%BB%8B.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>Linux Namespace简介 | 工作日志</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="工作日志" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">工作日志</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8namespace%E7%9A%84API"><span class="nav-number">1.</span> <span class="nav-text">调用namespace的API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CLONE"><span class="nav-number">1.1.</span> <span class="nav-text">CLONE()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROC%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">PROC文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETNS"><span class="nav-number">1.3.</span> <span class="nav-text">SETNS()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNSHARE"><span class="nav-number">1.4.</span> <span class="nav-text">UNSHARE()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTS-namespace"><span class="nav-number">2.</span> <span class="nav-text">UTS namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC-namespace"><span class="nav-number">3.</span> <span class="nav-text">IPC namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PID-namespace"><span class="nav-number">4.</span> <span class="nav-text">PID namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mount-namespaces"><span class="nav-number">5.</span> <span class="nav-text">Mount namespaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-namespace"><span class="nav-number">6.</span> <span class="nav-text">Network namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-namespaces"><span class="nav-number">7.</span> <span class="nav-text">User namespaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">Linux源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-creds"><span class="nav-number">8.1.</span> <span class="nav-text">copy_creds</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-namespaces"><span class="nav-number">8.2.</span> <span class="nav-text">copy_namespaces</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-mnt-ns"><span class="nav-number">8.2.1.</span> <span class="nav-text">copy_mnt_ns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-utsname"><span class="nav-number">8.2.2.</span> <span class="nav-text">copy_utsname</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-ipcs"><span class="nav-number">8.2.3.</span> <span class="nav-text">copy_ipcs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-pid-ns"><span class="nav-number">8.2.4.</span> <span class="nav-text">copy_pid_ns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-net-ns"><span class="nav-number">8.2.5.</span> <span class="nav-text">copy_net_ns</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">95</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-Namespace%E7%AE%80%E4%BB%8B.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="工作日志"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Linux Namespace简介</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-12-11 15:30:14" itemprop="dateCreated datePublished" datetime="2017-12-11T15:30:14+08:00">2017-12-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a></span></span><span id="/Linux%E5%86%85%E6%A0%B8/Linux-Namespace%E7%AE%80%E4%BB%8B.html" class="post-meta-item leancloud_visitors" data-flag-title="Linux Namespace简介" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>29k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>26 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Tips:系统环境为 Ubuntu 16.04，centos系统在namespace支持方面有些问题。</p><p>Namespace(命名空间)是一种纯软件方式的资源隔离方案，是Linux Container的基础，也是Docker实现的基础之一。</p><span id="more"></span><p>Linux内核中提供了6种namespace隔离的系统调用，由带有CLONE_NEW*标志的clone()所创建。这些标志如下表所示：</p><table><thead><tr><th>Namespace</th><th>系统调用参数</th><th>值</th><th>隔离内容</th></tr></thead><tbody><tr><td>Mount</td><td>CLONE_NEWNS</td><td>0x00020000</td><td>挂载点（文件系统）。 mount namespace是第一个namespace且当时没有人想到会将这套机制扩展到其它的子系统， 等它成了API， 由于兼容性问题，也不能改名了。</td></tr><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>0x04000000</td><td>主机名与域名。 影响setdomainname()、sethostname()这类接口。</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>0x08000000</td><td>信号量、消息队列和共享内存等进程间通信机制。</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>0x10000000</td><td>用户和用户组。</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>0x20000000</td><td>进程编号。</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>0x40000000</td><td>网络设备、网络栈、端口等。</td></tr></tbody></table><p>Linux内核实现namespace的主要目的就是为了实现轻量级虚拟化（容器）服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，仿佛自己置身于一个独立的系统环境中，以此达到独立和隔离的目的。</p><h2 id="调用namespace的API"><a href="#调用namespace的API" class="headerlink" title="调用namespace的API"></a>调用namespace的API</h2><p>namespace的API包括clone()、setns()以及unshare()，还有/proc下的部分文件。为了确定隔离的到底是哪种namespace，在使用这些API时，通常需要指定以下六个常数的一个或多个，通过’|’（位或）操作来实现。</p><h3 id="CLONE"><a href="#CLONE" class="headerlink" title="CLONE()"></a>CLONE()</h3><p>clone()在内核实现函数为do_fork()，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数child_func传入子进程运行的程序主函数。</li><li>参数child_stack传入子进程使用的栈空间。</li><li>参数flags表示使用哪些CLONE_*标志位。</li><li>参数args则可用于传入用户参数。</li></ul><p>在内核实现函数为do_fork()，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br></pre></td></tr></table></figure><p>‘clone_flags’ 即可赋值为上面提到的标志。</p><h3 id="PROC文件"><a href="#PROC文件" class="headerlink" title="PROC文件"></a>PROC文件</h3><p>从3.8版本的内核开始，用户就可以在<code>/proc/[pid]/ns</code>文件下看到指向不同namespace号的文件，效果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -al /proc/$$/ns 	&lt;&lt;-- $$ 表示当前进程的PID</span></span><br><span class="line">total 0</span><br><span class="line">dr-x--x--x 2 root root 0 Dec 11 16:39 .</span><br><span class="line">dr-xr-xr-x 9 root root 0 Dec 11 16:22 ..</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Dec 11 16:39 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure><p>其下面的文件依次表示每个namespace, 例如user就表示user namespace。所有文件均为符号链接, 链接指向$namespace:[$namespace-inode-number]，前半部份为namespace的名称，后半部份的数字表示这个namespace的inode number。因此，如果两个进程指向的namespace inode number相同，就说明他们在同一个namespace下，否则则在不同namespace里面。</p><p>该链接指向的文件比较特殊，它不能直接访问，事实上指向的文件存放在被称为”nsfs”的文件系统中，该文件系统用户不可见。可以用stat()看到指向文件的inode信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">stat</span> -L /proc/$$/ns/net</span></span><br><span class="line">  File: ‘/proc/927/ns/net’</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 1024   regular empty file</span><br><span class="line">Device: 3h/3d   Inode: 4026531956  Links: 1</span><br><span class="line">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-12-11 16:51:16.531134197 +0800</span><br><span class="line">Modify: 2017-12-11 16:51:16.531134197 +0800</span><br><span class="line">Change: 2017-12-11 16:51:16.531134197 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><h3 id="SETNS"><a href="#SETNS" class="headerlink" title="SETNS()"></a>SETNS()</h3><p>加入一个已经存在的namespace中以通过setns() 系统调用来完成。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setns</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nstype)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fd表示我们要加入的namespace的文件描述符。</span></span><br><span class="line"><span class="comment">nstype让调用者可以去检查fd指向的namespace类型是否符合我们实际的要求。如果填0表示不检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>util-linux包里提供了nsenter命令，其提供了一种方式将新创建的进程运行在指定的namespace里面，它的实现很简单，就是通过命令行指定要进入的namespace的file，然后利用setns()指当前的进程放到指定的namespace里面，再clone()运行指定的执行文件。我们可以用strace来看看它的运行情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> strace nsenter -t 27242 -i -m -n -p -u /bin/bash</span></span><br><span class="line">execve(&quot;/usr/bin/nsenter&quot;, [&quot;nsenter&quot;, &quot;-t&quot;, &quot;27242&quot;, &quot;-i&quot;, &quot;-m&quot;, &quot;-n&quot;, &quot;-p&quot;, &quot;-u&quot;, &quot;/bin/bash&quot;], [/* 21 vars */]) = 0</span><br><span class="line">…………</span><br><span class="line">…………</span><br><span class="line">pen(&quot;/proc/27242/ns/ipc&quot;, O_RDONLY)    = 3</span><br><span class="line">open(&quot;/proc/27242/ns/uts&quot;, O_RDONLY)    = 4</span><br><span class="line">open(&quot;/proc/27242/ns/net&quot;, O_RDONLY)    = 5</span><br><span class="line">open(&quot;/proc/27242/ns/pid&quot;, O_RDONLY)    = 6</span><br><span class="line">open(&quot;/proc/27242/ns/mnt&quot;, O_RDONLY)    = 7</span><br><span class="line">setns(3, CLONE_NEWIPC)                  = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">setns(4, CLONE_NEWUTS)                  = 0</span><br><span class="line">close(4)                                = 0</span><br><span class="line">setns(5, CLONE_NEWNET)                  = 0</span><br><span class="line">close(5)                                = 0</span><br><span class="line">setns(6, CLONE_NEWPID)                  = 0</span><br><span class="line">close(6)                                = 0</span><br><span class="line">setns(7, CLONE_NEWNS)                   = 0</span><br><span class="line">close(7)                                = 0</span><br><span class="line">clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f4deb1faad0) = 4968</span><br></pre></td></tr></table></figure><p>nsenter先获得target进程(-t参数指定)所在的namespace的文件, 然后再调用setns()将当前所在的进程加入到对应的namespace里面, 最后再clone()运行我们指定的二进制文件。</p><h3 id="UNSHARE"><a href="#UNSHARE" class="headerlink" title="UNSHARE()"></a>UNSHARE()</h3><p>unshare()系统调用用于将当前进程和所在的namespace分离并且加入到新创建的namespace之中。unshare()运行在原先的进程上，不需要启动一个新进程，使用方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unshare</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>Linux中自带的unshare命令，就是通过unshare()系统调用实现的。</p><h2 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h2><p>UTS namespace提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。</p><p>编译并运行以下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# gcc uts.c ; ./a.out</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@ubuntu:~# </span><br><span class="line">root@ubuntu:~# exit</span><br><span class="line">exit</span><br><span class="line">Parent - container stopped!</span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>加入UTS隔离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span>	</span><br><span class="line">	sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span>	</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="comment">/*启用CLONE_NEWUTS Namespace隔离 */</span></span><br><span class="line"><span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>); </span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# gcc uts.c ; ./a.out</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@container:~# hostname</span><br><span class="line">container</span><br><span class="line">root@container:~# exit</span><br><span class="line">exit</span><br><span class="line">Parent - container stopped!</span><br></pre></td></tr></table></figure><p>不加CLONE_NEWUTS参数运行上述代码，发现主机名也变了，输入exit以后主机名也会变回来，似乎没什么区别。实际上不加CLONE_NEWUTS参数进行隔离而使用sethostname已经把宿主机的主机名改掉了。你看到exit退出后还原只是因为bash只在刚登录的时候读取一次UTS，当你重新登陆或者使用uname命令进行查看时，就会发现产生了变化。</p><h2 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h2><p>进程间通信采用的方法包括常见的信号量、消息队列和共享内存。对不在原namespace中的进程来说，之间的通信，实际上是具有相同’PID namespace’中的进程间通信，因此需要一个唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。</p><p>修改上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//[...]</span></span><br></pre></td></tr></table></figure><p>在shell中使用’ipcmk -Q’命令创建一个message queue，并使用’ipcs -q’查看已经开启的message queue。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ipcmk -Q</span><br><span class="line">Message queue id: 0</span><br><span class="line">root@ubuntu:~# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0x875028f6 0          root       644        0            0           </span><br></pre></td></tr></table></figure><p>编译并运行修改后的程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# gcc uts.c ; ./a.out </span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@container:~# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line"></span><br><span class="line">root@container:~# exit</span><br><span class="line">exit</span><br><span class="line">Parent - container stopped!</span><br></pre></td></tr></table></figure><p>上面的结果显示中可以发现，已经找不到原先声明的message queue，实现了IPC的隔离。</p><h2 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h2><p><img src="/images/Linux-Namespace/PID-Namespace.png" alt="PID Namespace"></p><p>PID namespace隔离非常实用，它对进程PID重新标号，即两个不同namespace下的进程可以有同一个PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。它创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个等级体系。所属的父节点可以看到子节点中的进程，并可以通过信号量等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。由此产生如下结论。</p><ul><li>每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。</li><li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li><li>如果你在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。</li><li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li></ul><p>修改上文的代码，加入PID namespace的标识位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="keyword">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE,</span><br><span class="line">          CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, <span class="literal">NULL</span>); </span><br><span class="line"><span class="comment">//[...]</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo $$ </span><br><span class="line">894</span><br><span class="line">root@ubuntu:~# gcc uts.c ; ./a.out ;</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">root@container:~# echo $$							&lt;&lt;&lt;--- shell 程序的PID已经改变</span><br><span class="line">1</span><br><span class="line">root@container:~# exit</span><br><span class="line">exit</span><br><span class="line">Parent - container stopped!</span><br></pre></td></tr></table></figure><p>在子进程的shell中执行了<code>ps aux</code>/<code>top</code>之类的命令，发现还是可以看到所有父进程的PID，那是因为还没有对文件系统进行隔离，<code>ps</code>/<code>top</code>之类的命令调用的是真实系统下的<code>/proc</code>文件内容，看到的自然是所有的进程。</p><p>此外，与其他的namespace不同的是，为了实现一个稳定安全的隔离空间（例如，容器），PID namespace还需要进行一些额外的工作才能确保其中的进程运行顺利。</p><ul><li><p>PID NAMESPACE中的INIT进程</p><p>当我们新建一个PID namespace时，默认启动的进程PID为1。在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。它作为所有进程的父进程，维护一张进程表，不断检查进程的状态，一旦有某个子进程因为程序错误成为了“孤儿”进程，init就会负责回收资源并结束这个子进程。所以在实现的容器中，启动的第一个进程也需要实现类似init的功能，维护所有后续启动进程的运行状态。</p><p>PID namespace维护这样一个树状结构，非常有利于系统的资源监控与回收。</p></li><li><p>信号量与INIT进程</p><p>PID namespace中的init进程如此特殊，自然内核也为它赋予了特权——信号量屏蔽。如果init中没有处理某个信号量的代码逻辑，那么与init在同一个PID namespace下的进程（即使有超级权限）发送给它的该信号量都会被屏蔽。这个功能的主要作用是防止init进程被误杀。</p><p>父节点中的进程发送的信号量，如果不是SIGKILL（销毁进程）或SIGSTOP（暂停进程）也会被忽略。但如果发送SIGKILL或SIGSTOP，子节点的init会强制执行（无法通过代码捕捉进行特殊处理），也就是说父节点中的进程有权终止子节点中的进程。</p><p>一旦init进程被销毁，同一PID namespace中的其他进程也会随之接收到SIGKILL信号量而被销毁。理论上，该PID namespace自然也就不复存在了。但是如果/proc/[pid]/ns/pid处于被挂载或者打开状态，namespace就会被保留下来。然而，保留下来的namespace无法通过setns()或者fork()创建进程，所以实际上并没有什么作用。</p></li><li><p>挂载PROC文件系统</p><p>如果你在新的PID namespace中使用ps命令查看，看到的还是所有的进程，因为与PID直接相关的/proc文件系统（procfs）没有挂载到与原/proc不同的位置。所以如果你只想看到PID namespace本身应该看到的进程，需要重新挂载/proc，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Changed Name:~# mount -t proc proc /proc</span><br><span class="line">root@Changed Name:~# ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 115388  2024 pts/0    S    19:49   0:00 /bin/bash</span><br><span class="line">root        13  0.0  0.0 151064  1800 pts/0    R+   19:49   0:00 ps aux</span><br></pre></td></tr></table></figure><p>可以看到实际的PID namespace就只有两个进程在运行。</p><p><strong>注意</strong>：因为此时我们没有进行mount namespace的隔离，所以这一步操作实际上已经影响了 root namespace的文件系统，当你退出新建的PID namespace以后再执行<code>ps a</code>就会发现出错，再次执行<code>mount -t proc proc /proc</code>可以修复错误。</p></li><li><p>UNSHARE()和SETNS()</p><p>unshare()允许用户在原有进程中建立namespace进行隔离。但是创建了PID namespace后，原先unshare()调用者进程并不进入新的PID namespace，接下来创建的子进程才会进入新的namespace，这个子进程也就随之成为新namespace中的init进程。</p><p>类似的，调用setns()创建新PID namespace时，调用者进程也不进入新的PID namespace，而是随后创建的子进程进入。</p><p>这样设计是因为调用getpid()函数得到的PID是根据调用者所在的PID namespace而决定返回哪个PID，进入新的PID namespace会导致PID产生变化。而对用户态的程序和库函数来说，他们都认为进程的PID是一个常量，PID的变化会引起这些进程崩溃。</p><p><strong>换句话说，一旦程序进程创建以后，那么它的PID namespace的关系就确定下来了，进程不会变更他们对应的PID namespace。</strong></p></li></ul><h2 id="Mount-namespaces"><a href="#Mount-namespaces" class="headerlink" title="Mount namespaces"></a>Mount namespaces</h2><p>Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是CLONE_NEWNS。隔离后，不同mount namespace中的文件结构发生变化也互不影响。可以通过/proc/[pid]/mounts查看到所有挂载在当前namespace中的文件系统，还可以通过/proc/[pid]/mountstats看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等等。</p><p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新namespace中的所有mount操作都只影响自身的文件系统，而对外界不会产生任何影响。这样做非常严格地实现了隔离，但是某些情况可能并不适用。比如父节点namespace中的进程挂载了一张CD-ROM，这时子节点namespace拷贝的目录结构就无法自动挂载上这张CD-ROM，因为这种操作会影响到父节点的文件系统。</p><p>2006 年引入的挂载传播（mount propagation）解决了这个问题，挂载传播定义了挂载对象（mount object）之间的关系，系统用这些关系决定任何挂载对象中的挂载事件如何传播到其他挂载对象参考自：<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/library/l-mount-namespaces/%E3%80%82">http://www.ibm.com/developerworks/library/l-mount-namespaces/。</a> 所谓传播事件，是指由一个挂载对象的状态变化导致的其它挂载对象的挂载与解除挂载动作的事件。</p><ul><li>共享关系（share relationship）。如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。</li><li>从属关系（slave relationship）。如果两个挂载对象形成从属关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反过来不行；在这种关系中，从属对象是事件的接收者。</li></ul><p>一个挂载状态可能为如下的其中一种：</p><ul><li>共享挂载（shared）</li><li>从属挂载（slave）</li><li>共享/从属挂载（shared and slave）</li><li>私有挂载（private）</li><li>不可绑定挂载（unbindable）</li></ul><p>传播事件的挂载对象称为共享挂载（shared mount）；接收传播事件的挂载对象称为从属挂载（slave mount）。既不传播也不接收传播事件的挂载对象称为私有挂载（private mount）。另一种特殊的挂载对象称为不可绑定的挂载（unbindable mount），它们与私有挂载相似，但是不允许执行绑定挂载，即创建mount namespace时这块文件对象不可被复制。</p><p><img src="/images/Linux-Namespace/mount%E5%90%84%E7%B1%BB%E6%8C%82%E8%BD%BD%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="mount各类挂载状态示意图"></p><p>共享挂载的应用场景非常明显，就是为了文件数据的共享所必须存在的一种挂载方式；从属挂载更大的意义在于某些“只读”场景；私有挂载其实就是纯粹的隔离，作为一个独立的个体而存在；不可绑定挂载则有助于防止没有必要的文件拷贝，如某个用户数据目录，当根目录被递归式的复制时，用户目录无论从隐私还是实际用途考虑都需要有一个不可被复制的选项。</p><p>默认情况下，所有挂载都是私有的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*设置为共享挂载。从共享挂载克隆的挂载对象也是共享的挂载；它们相互传播挂载事件。*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount --make-shared &lt;mount-object&gt;</span></span><br><span class="line">/*设置为从属挂载。从从属挂载克隆的挂载对象也是从属的挂载，它也从属于原来的从属挂载的主挂载对象。*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount --make-slave &lt;shared-mount-object&gt;</span></span><br><span class="line">/*将一个从属挂载对象设置为共享/从属挂载，可以执行如下命令或者将其移动到一个共享挂载对象下。*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount --make-shared &lt;slave-mount-object&gt;</span></span><br><span class="line">/*把修改过的挂载对象重新标记为私有的。*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount --make-private &lt;mount-object&gt;</span></span><br><span class="line">/*将挂载对象标记为不可绑定的。*/</span><br><span class="line"><span class="meta">#</span><span class="bash"> mount --make-unbindable &lt;mount-object&gt;</span></span><br></pre></td></tr></table></figure><p>这些设置都可以递归式地应用到所有子目录中，可搜索到相关的命令进行深入。</p><p>修改上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//[...]</span></span></span><br><span class="line"><span class="function">  <span class="title">system</span><span class="params">(<span class="string">&quot;mount -t proc proc /proc&quot;</span>)</span></span>;</span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="keyword">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE, </span><br><span class="line">                      CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//[...]</span></span><br></pre></td></tr></table></figure><p>在子namespace中，能看到挂载，而在父空间中无挂载。在父空间执行’mount -t proc proc /proc’即可恢复。</p><h2 id="Network-namespace"><a href="#Network-namespace" class="headerlink" title="Network namespace"></a>Network namespace</h2><p>Network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、端口（socket）等等。一个物理的网络设备最多存在在一个network namespace中，你可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace间创建通道，以此达到通信的目的。</p><p>一般情况下，物理网络设备都分配在最初的root namespace中。但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。</p><p>为了使新创建的namespace与外部进行网络通信，经典做法就是创建一个veth pair，一端放置在新的namespace中，一端放在另一个namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。</p><p>对network namespace的使用其实就是在创建的时候添加<code>CLONE_NEWNET</code>标识位。可以通过命令行工具<code>ip</code>创建network namespace。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns add &lt;network namespace name&gt;	// 创建net namespace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns [list]							// 显示当前所有net namespace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns delete &lt;network namespace name&gt;	// 删除net namespace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> &lt;network namespace name&gt; &lt;<span class="built_in">command</span>&gt;	// 在net namespace中执行命令</span></span><br><span class="line">当然，你也可以进入net namespace</span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> &lt;network namespace name&gt; bash</span></span><br><span class="line">之后可以在其中执行命令</span><br></pre></td></tr></table></figure><p>下面开始执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns add test_ns</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> test_ns ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p>当<code>ip</code>命令工具创建一个network namespace时，会默认创建一个回环设备（loopback interface：<code>lo</code>），并在<code>/var/run/netns</code>目录下绑定一个挂载点，这就保证了就算network namespace中没有进程在运行也不会被释放，也给系统管理员对新创建的network namespace进行配置提供了充足的时间。</p><p>在新创建的namespace中，lo接口状态是’DOWN’的，因此，第一个任务应该是把它启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> test_ns ip link <span class="built_in">set</span> dev lo up</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> test_ns ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> veth1 netns test_ns</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> test_ns ifconfig veth1 10.1.1.1/24 up</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ifconfig veth0 10.1.1.2/24 up</span></span><br></pre></td></tr></table></figure><p>通过ping命令进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ping 10.1.1.1</span></span><br><span class="line">PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.048 ms</span><br><span class="line">……</span><br><span class="line">[root@pro4-node ~]# ip netns exec test_ns ping 10.1.1.2</span><br><span class="line">PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.040 ms</span><br><span class="line">………</span><br></pre></td></tr></table></figure><p>通信正常。</p><p>net namespace实现了在同一设备内部虚拟出多个网络设备，极大利用了现有设备性能。</p><h2 id="User-namespaces"><a href="#User-namespaces" class="headerlink" title="User namespaces"></a>User namespaces</h2><p>User namespace主要隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/keyctl.2.html">key</a>（指密钥）以及<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/capabilities.7.html">特殊权限</a>。说得通俗一点，一个普通用户的进程通过<code>clone()</code>创建的新进程在新user namespace中可以拥有不同的用户和用户组。</p><p>User namespace是目前的六个namespace中最后一个支持的，并且直到Linux内核3.8版本的时候还未完全实现（还有部分文件系统不支持）。因为user namespace实际上并不算完全成熟，很多发行版担心安全问题，在编译内核的时候并未开启<code>USER_NS</code>。所以在进行接下来的代码实验时，请确保你系统的Linux内核版本高于3.8并且内核编译时开启了<code>USER_NS</code>。</p><p>Linux中，特权用户的user ID就是0，演示的最终我们将看到user ID非0的进程启动user namespace后user ID可以变为0。使用user namespace的方法跟别的namespace相同，即调用<code>clone()</code>或<code>unshare()</code>时加入<code>CLONE_NEWUSER</code>标识位。为了看到用户<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/capabilities.7.html">权限(Capabilities)</a>，可能还需要安装一下<code>libcap-dev</code>包。</p><p>头文件以调用<code>Capabilities</code>包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/capability.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在子进程函数中加入<code>geteuid()</code>和<code>getegid()</code>得到namespace内部的user ID，其次通过<code>cap_get_proc()</code>得到当前进程的用户拥有的权限，并通过<code>cap_to_text（）</code>输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">cap_t</span> caps;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;eUID = %ld;  eGID = %ld;  &quot;</span>,</span><br><span class="line">                        (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid());</span><br><span class="line">        caps = cap_get_proc();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;capabilities: %s\n&quot;</span>, cap_to_text(caps, <span class="literal">NULL</span>));</span><br><span class="line">        execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数的<code>clone()</code>调用中加入<code>CLONE_NEWUSER</code> 标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="keyword">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE, CLONE_NEWUSER | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//[...]</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当前的user id 和 group id</span></span><br><span class="line">stack@ubuntu:~$ id</span><br><span class="line">uid=1000(stack) gid=1000(stack) groups=1000(stack)</span><br><span class="line"><span class="meta">#</span><span class="bash">非root 用户</span></span><br><span class="line">stack@ubuntu:~$ ./uts </span><br><span class="line">程序开始: </span><br><span class="line">在子进程中!</span><br><span class="line">eUID = 65534;  eGID = 65534;  capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep</span><br><span class="line">nobody@ubuntu:~$ </span><br></pre></td></tr></table></figure><ul><li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样这个init进程就可以完成所有必要的初始化工作，而不会因权限不足而出现错误。</li><li>namespace内部看到的UID和GID已经与外部不同了，默认显示为65534，表示尚未与外部namespace用户映射。需要对user namespace内部的这个初始user和其外部namespace某个用户建立映射，这样可以保证当涉及到一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号量或操作某个文件）。同样用户组也要建立映射。</li><li>还有一点虽然不能从输出中看出来，但是值得注意。用户在新namespace中有全部权限，但是在创建它的父namespace中不含任何权限。就算调用和创建它的进程有全部权限也是如此。所以哪怕是root用户调用了clone()在user namespace中创建出的新用户在外部也没有任何权限。</li><li>user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace以及零个或多个子节点user namespace，这一点与PID namespace非常相似。</li></ul><p>接下来我们就要进行用户绑定（映射）操作，通过在<code>/proc/[pid]/uid_map</code>和<code>/proc/[pid]/gid_map</code>两个文件中写入对应的绑定信息可以实现这一点，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID-inside-ns   ID-outside-ns   length</span><br></pre></td></tr></table></figure><p>写这两个文件需要注意以下几点。</p><ul><li>这两个文件只允许由拥有该user namespace中<code>CAP_SETUID</code>和<code>CAP_SETGID</code>权限的进程<strong>写入一次，但可以一次写多条，并且最多只能5条，不允许修改。</strong></li><li>写入的进程必须是该user namespace的父namespace或者子namespace。</li><li>第一个字段<code>ID-inside-ns</code>表示新建的user namespace中对应的user/group ID，第二个字段<code>ID-outside-ns</code>表示namespace外部映射的user/group ID。最后一个字段表示映射范围，通常填1，表示只映射一个，如果填大于1的值，则按顺序建立一一映射。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_map</span><span class="params">(<span class="keyword">char</span>* file, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    FILE* mapfd = fopen(file, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mapfd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file [%s] error.\n&quot;</span>,file);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(mapfd, <span class="string">&quot;%d %d %d&quot;</span>, inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在子进程中!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待父进程通知后再往下执行（进程间的同步） */</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> gid=getgid(), uid=getuid();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序开始: \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">  pipe(pipefd);</span><br><span class="line">  <span class="keyword">int</span> child_pid = clone(child_main, child_stack+STACK_SIZE, CLONE_NEWUSER | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  set_uid_map(child_pid, <span class="number">0</span>, uid, <span class="number">1</span>);</span><br><span class="line">  set_gid_map(child_pid, <span class="number">0</span>, gid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通知子进程 */</span></span><br><span class="line">  close(pipefd[<span class="number">1</span>]);</span><br><span class="line">  waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;已退出\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行后即可看到user已经变成了<code>root</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack@ubuntu:~$ gcc userns.c -Wall -lcap -o userns &amp;&amp; ./userns</span><br><span class="line">程序开始: </span><br><span class="line">Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000</span><br><span class="line">在子进程中!</span><br><span class="line">eUID = 0;  eGID = 65534, UID=0, GID=65534</span><br><span class="line">root@ubuntu:~# id</span><br><span class="line">uid=0(root) gid=65534(nogroup) groups=65534(nogroup)</span><br><span class="line">root@ubuntu:~# </span><br></pre></td></tr></table></figure><p>gid一直没有变过来，调试发现文件已经创建且写入函数返回值正确，这个问题有时间再调试吧。</p><p>至此，关于几个namespace的介绍已简单完成。</p><h2 id="Linux源码分析"><a href="#Linux源码分析" class="headerlink" title="Linux源码分析"></a>Linux源码分析</h2><p>基于kernel 3.10.105分析。</p><p>以上的实例大多基于<code>clone</code>来创建新的namespace，因此对namespace的分析基本就是分析<code>clone</code>函数有关namespace的部分。内核中<code>clone</code>实际也是调用的<code>do_fork</code>。</p><p>直接进入<code>copy_process</code>分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct pid *pid,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	……</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">	p = dup_task_struct(current);</span><br><span class="line">  	……</span><br><span class="line">    <span class="comment">/*CLONE_NEWUSER 相关*/</span></span><br><span class="line">	retval = copy_creds(p, clone_flags);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">	……</span><br><span class="line">    <span class="comment">/*另外5个 namespace flag*/</span></span><br><span class="line">	retval = copy_namespaces(clone_flags, p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy-creds"><a href="#copy-creds" class="headerlink" title="copy_creds"></a>copy_creds</h3><p><code>copy_creds</code>的作用是复制或创建凭证信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_creds</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	……</span><br><span class="line">    <span class="comment">/*以current为模块，创建新的cred*/</span></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWUSER) &#123;</span><br><span class="line">		ret = create_user_ns(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error_put;</span><br><span class="line">	&#125;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_user_ns</span><span class="params">(struct cred *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*parent_ns 为父进程的user namespace(一路copy)*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span>, *<span class="title">parent_ns</span> =</span> <span class="keyword">new</span>-&gt;user_ns;</span><br><span class="line">	<span class="keyword">kuid_t</span> owner = <span class="keyword">new</span>-&gt;euid;</span><br><span class="line">	<span class="keyword">kgid_t</span> group = <span class="keyword">new</span>-&gt;egid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent_ns-&gt;level &gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">return</span> -EUSERS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*判断当前进程文件系统和命名空间的 挂载点、根目录项对象是否相同。相同返回0*/</span></span><br><span class="line">	<span class="keyword">if</span> (current_chrooted())</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	<span class="comment">/*创建者需要在父用户名空间中进行映射，否则我们将无法合理地告知创建user_namespace的用户空间。*/</span></span><br><span class="line">	<span class="keyword">if</span> (!kuid_has_mapping(parent_ns, owner) ||</span><br><span class="line">	    !kgid_has_mapping(parent_ns, group))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">  	<span class="comment">/*slab层快速获取user namespace空间*/</span></span><br><span class="line">	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ns)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/*分配INODE number*/</span></span><br><span class="line">	ret = proc_alloc_inum(&amp;ns-&gt;proc_inum);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		kmem_cache_free(user_ns_cachep, ns);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*初始化ns数据*/</span></span><br><span class="line">	atomic_set(&amp;ns-&gt;count, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* Leave the new-&gt;user_ns reference with the new user namespace. */</span></span><br><span class="line">	ns-&gt;parent = parent_ns;</span><br><span class="line">	ns-&gt;level = parent_ns-&gt;level + <span class="number">1</span>;</span><br><span class="line">	ns-&gt;owner = owner;</span><br><span class="line">	ns-&gt;group = group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */</span></span><br><span class="line">	mutex_lock(&amp;userns_state_mutex);</span><br><span class="line">	ns-&gt;flags = parent_ns-&gt;flags;</span><br><span class="line">	mutex_unlock(&amp;userns_state_mutex);</span><br><span class="line">	<span class="comment">/*使用与init相同的功能*/</span></span><br><span class="line">	set_cred_user_ns(<span class="keyword">new</span>, ns);</span><br><span class="line">	<span class="comment">/*更新挂载规则*/</span></span><br><span class="line">	update_mnt_policy(ns);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy-namespaces"><a href="#copy-namespaces" class="headerlink" title="copy_namespaces"></a>copy_namespaces</h3><p>核心结构<code>nsproxy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> 	     *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_namespaces</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">old_ns</span> =</span> tsk-&gt;nsproxy;</span><br><span class="line">  	<span class="comment">/*获取任务的客观上下文。</span></span><br><span class="line"><span class="comment">  	task_struct 中有两个上下文(context)：</span></span><br><span class="line"><span class="comment">  		real_cred，客观上下文，当其他一些任务试图影响这个部分的时候，就会使用这些部分。</span></span><br><span class="line"><span class="comment">  		cred，主观上下文，一般在任务作用于另一个对象时使用，是文件，任务，键或其他。</span></span><br><span class="line"><span class="comment">  	通常，这两个指针相同。具体细节可参考 struct cred结构(include/linux/cred.h)*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span> =</span> task_cred_xxx(tsk, user_ns);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">new_ns</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!old_ns)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*inc计数*/</span></span><br><span class="line">	get_nsproxy(old_ns);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |</span><br><span class="line">				CLONE_NEWPID | CLONE_NEWNET)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(user_ns, CAP_SYS_ADMIN)) &#123;</span><br><span class="line">		err = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_NEWIPC，旧的IPC namespace中的信号量无法访问；</span></span><br><span class="line"><span class="comment">	   但是，CLONE_SYSVSEM 会共享父级信号量。 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; CLONE_NEWIPC) &amp;&amp; (flags &amp; CLONE_SYSVSEM)) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*为进程创建新的相关namespace*/</span></span><br><span class="line">	new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_ns);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	tsk-&gt;nsproxy = new_ns;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	put_nsproxy(old_ns);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*nsproxy 结构主要分配函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct nsproxy *<span class="title">create_new_namespaces</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct task_struct *tsk, struct user_namespace *user_ns,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct fs_struct *new_fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">new_nsp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="comment">/*从slab层分配空间*/</span></span><br><span class="line">	new_nsp = create_nsproxy();</span><br><span class="line">	<span class="keyword">if</span> (!new_nsp)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">/*MNT namespace 拷贝（分配、初始化）*/</span></span><br><span class="line">	new_nsp-&gt;mnt_ns = copy_mnt_ns(flags, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsp-&gt;mnt_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_nsp-&gt;mnt_ns);</span><br><span class="line">		<span class="keyword">goto</span> out_ns;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*UTS namespace 拷贝（分配、初始化）*/</span></span><br><span class="line">	new_nsp-&gt;uts_ns = copy_utsname(flags, user_ns, tsk-&gt;nsproxy-&gt;uts_ns);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsp-&gt;uts_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_nsp-&gt;uts_ns);</span><br><span class="line">		<span class="keyword">goto</span> out_uts;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*IPC namespace 拷贝（分配、初始化）*/</span></span><br><span class="line">	new_nsp-&gt;ipc_ns = copy_ipcs(flags, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsp-&gt;ipc_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_nsp-&gt;ipc_ns);</span><br><span class="line">		<span class="keyword">goto</span> out_ipc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*PID namespace 拷贝（分配、初始化）*/</span></span><br><span class="line">	new_nsp-&gt;pid_ns = copy_pid_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsp-&gt;pid_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_nsp-&gt;pid_ns);</span><br><span class="line">		<span class="keyword">goto</span> out_pid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*NET namespace 拷贝（分配、初始化）*/</span></span><br><span class="line">	new_nsp-&gt;net_ns = copy_net_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;net_ns);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsp-&gt;net_ns)) &#123;</span><br><span class="line">		err = PTR_ERR(new_nsp-&gt;net_ns);</span><br><span class="line">		<span class="keyword">goto</span> out_net;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_nsp;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-mnt-ns"><a href="#copy-mnt-ns" class="headerlink" title="copy_mnt_ns"></a>copy_mnt_ns</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct mnt_namespace *<span class="title">copy_mnt_ns</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct mnt_namespace *ns,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct user_namespace *user_ns, struct fs_struct *new_fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(!ns);</span><br><span class="line">  	<span class="comment">/*原子增计数*/</span></span><br><span class="line">	get_mnt_ns(ns);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWNS))</span><br><span class="line">		<span class="keyword">return</span> ns;</span><br><span class="line"></span><br><span class="line">	new_ns = dup_mnt_ns(ns, user_ns, new_fs);</span><br><span class="line">	<span class="comment">/*原子减计数*/</span></span><br><span class="line">	put_mnt_ns(ns);</span><br><span class="line">	<span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*分配一个新的名称空间结构，并使用从传入的任务结构的名称空间复制的内容填充它。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mnt_namespace *<span class="title">dup_mnt_ns</span><span class="params">(struct mnt_namespace *mnt_ns,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct user_namespace *user_ns, struct fs_struct *fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">rootmnt</span> =</span> <span class="literal">NULL</span>, *pwdmnt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">old</span> =</span> mnt_ns-&gt;root;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="keyword">int</span> copy_flags;</span><br><span class="line">	<span class="comment">/*分配新的mnt_namespace并进行初始化*/</span></span><br><span class="line">	new_ns = alloc_mnt_ns(user_ns);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_ns))</span><br><span class="line">		<span class="keyword">return</span> new_ns;</span><br><span class="line">	<span class="comment">/*加锁读写信号量namespace_sem*/</span></span><br><span class="line">	namespace_lock();</span><br><span class="line">	<span class="comment">/* 复制mnt树形拓扑 */</span></span><br><span class="line">	copy_flags = CL_COPY_ALL | CL_EXPIRE;</span><br><span class="line">	<span class="keyword">if</span> (user_ns != mnt_ns-&gt;user_ns)</span><br><span class="line">		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;</span><br><span class="line">  	<span class="comment">/*主要函数，暂不分析。TBD*/</span></span><br><span class="line">	<span class="keyword">new</span> = copy_tree(old, old-&gt;mnt.mnt_root, copy_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="keyword">new</span>)) &#123;</span><br><span class="line">		namespace_unlock();</span><br><span class="line">		free_mnt_ns(new_ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_CAST(<span class="keyword">new</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	new_ns-&gt;root = <span class="keyword">new</span>;</span><br><span class="line">	br_write_lock(&amp;vfsmount_lock);</span><br><span class="line">	list_add_tail(&amp;new_ns-&gt;<span class="built_in">list</span>, &amp;<span class="keyword">new</span>-&gt;mnt_list);</span><br><span class="line">	br_write_unlock(&amp;vfsmount_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*切换tsk-&gt; fs - &gt; *元素并将新的vfsmount标记为属于新的命名空间。 </span></span><br><span class="line"><span class="comment">	我们已经获得了私有的fs_struct，所以不需要tsk-&gt; fs-&gt; lock。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p = old;</span><br><span class="line">	q = <span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		q-&gt;mnt_ns = new_ns;</span><br><span class="line">		<span class="keyword">if</span> (fs) &#123;</span><br><span class="line">			<span class="keyword">if</span> (&amp;p-&gt;mnt == fs-&gt;root.mnt) &#123;</span><br><span class="line">				fs-&gt;root.mnt = mntget(&amp;q-&gt;mnt);</span><br><span class="line">				rootmnt = &amp;p-&gt;mnt;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (&amp;p-&gt;mnt == fs-&gt;pwd.mnt) &#123;</span><br><span class="line">				fs-&gt;pwd.mnt = mntget(&amp;q-&gt;mnt);</span><br><span class="line">				pwdmnt = &amp;p-&gt;mnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = next_mnt(p, old);</span><br><span class="line">		q = next_mnt(q, <span class="keyword">new</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	namespace_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rootmnt)</span><br><span class="line">		mntput(rootmnt);</span><br><span class="line">	<span class="keyword">if</span> (pwdmnt)</span><br><span class="line">		mntput(pwdmnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-utsname"><a href="#copy-utsname" class="headerlink" title="copy_utsname"></a>copy_utsname</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct uts_namespace *<span class="title">copy_utsname</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct user_namespace *user_ns, struct uts_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(!old_ns);</span><br><span class="line">	get_uts_ns(old_ns);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWUTS))</span><br><span class="line">		<span class="keyword">return</span> old_ns;</span><br><span class="line"></span><br><span class="line">	new_ns = clone_uts_ns(user_ns, old_ns);</span><br><span class="line"></span><br><span class="line">	put_uts_ns(old_ns);</span><br><span class="line">	<span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct uts_namespace *<span class="title">clone_uts_ns</span><span class="params">(struct user_namespace *user_ns,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct uts_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="comment">/*分配空间*/</span></span><br><span class="line">	ns = create_uts_ns();</span><br><span class="line">	<span class="keyword">if</span> (!ns)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">/*分配新的inode number*/</span></span><br><span class="line">	err = proc_alloc_inum(&amp;ns-&gt;proc_inum);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		kfree(ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;ns-&gt;name, &amp;old_ns-&gt;name, <span class="keyword">sizeof</span>(ns-&gt;name));</span><br><span class="line">	ns-&gt;user_ns = get_user_ns(user_ns);</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-ipcs"><a href="#copy-ipcs" class="headerlink" title="copy_ipcs"></a>copy_ipcs</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ipc_namespace *<span class="title">copy_ipcs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct user_namespace *user_ns, struct ipc_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWIPC))</span><br><span class="line">		<span class="keyword">return</span> get_ipc_ns(ns);</span><br><span class="line">	<span class="keyword">return</span> create_ipc_ns(user_ns, ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ipc_namespace *<span class="title">create_ipc_ns</span><span class="params">(struct user_namespace *user_ns,</span></span></span><br><span class="line"><span class="params"><span class="function">					   struct ipc_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	ns = kmalloc(<span class="keyword">sizeof</span>(struct ipc_namespace), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ns == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	err = proc_alloc_inum(&amp;ns-&gt;proc_inum);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		kfree(ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;ns-&gt;count, <span class="number">1</span>);</span><br><span class="line">  	<span class="comment">/*消息队列初始化*/</span></span><br><span class="line">	err = mq_init_ns(ns);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		proc_free_inum(ns-&gt;proc_inum);</span><br><span class="line">		kfree(ns);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line">	atomic_inc(&amp;nr_ipc_ns);</span><br><span class="line">	<span class="comment">/*信号量初始化*/</span></span><br><span class="line">	sem_init_ns(ns);</span><br><span class="line">  	<span class="comment">/*信号初始化？TBD*/</span></span><br><span class="line">	msg_init_ns(ns);</span><br><span class="line">  	<span class="comment">/*共享内存初始化*/</span></span><br><span class="line">	shm_init_ns(ns);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*IPC 创建通知*/</span></span><br><span class="line">	ipcns_notify(IPCNS_CREATED);</span><br><span class="line">	register_ipcns_notifier(ns);</span><br><span class="line"></span><br><span class="line">	ns-&gt;user_ns = get_user_ns(user_ns);</span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-pid-ns"><a href="#copy-pid-ns" class="headerlink" title="copy_pid_ns"></a>copy_pid_ns</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pid_namespace *<span class="title">copy_pid_ns</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct user_namespace *user_ns, struct pid_namespace *old_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWPID))</span><br><span class="line">		<span class="keyword">return</span> get_pid_ns(old_ns);</span><br><span class="line">  	<span class="comment">/*当前pid namespace不是old_ns（之前copy的current），可能已经发生了进程切换*/</span></span><br><span class="line">	<span class="keyword">if</span> (task_active_pid_ns(current) != old_ns)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	<span class="keyword">return</span> create_pid_namespace(user_ns, old_ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pid_namespace *<span class="title">create_pid_namespace</span><span class="params">(struct user_namespace *user_ns,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct pid_namespace *parent_pid_ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level = parent_pid_ns-&gt;level + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (level &gt; MAX_PID_NS_LEVEL) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	ns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ns == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ns-&gt;pidmap[<span class="number">0</span>].page = kzalloc(PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ns-&gt;pidmap[<span class="number">0</span>].page)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	ns-&gt;pid_cachep = create_pid_cachep(level + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ns-&gt;pid_cachep == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_map;</span><br><span class="line"></span><br><span class="line">	err = proc_alloc_inum(&amp;ns-&gt;proc_inum);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_free_map;</span><br><span class="line"></span><br><span class="line">	kref_init(&amp;ns-&gt;kref);</span><br><span class="line">	ns-&gt;level = level;</span><br><span class="line">	ns-&gt;parent = get_pid_ns(parent_pid_ns);</span><br><span class="line">	ns-&gt;user_ns = get_user_ns(user_ns);</span><br><span class="line">	ns-&gt;nr_hashed = PIDNS_HASH_ADDING;</span><br><span class="line">	INIT_WORK(&amp;ns-&gt;proc_work, proc_cleanup_work);</span><br><span class="line"></span><br><span class="line">	set_bit(<span class="number">0</span>, ns-&gt;pidmap[<span class="number">0</span>].page);</span><br><span class="line">	atomic_set(&amp;ns-&gt;pidmap[<span class="number">0</span>].nr_free, BITS_PER_PAGE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; PIDMAP_ENTRIES; i++)</span><br><span class="line">		atomic_set(&amp;ns-&gt;pidmap[i].nr_free, BITS_PER_PAGE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line"></span><br><span class="line">out_free_map:</span><br><span class="line">	kfree(ns-&gt;pidmap[<span class="number">0</span>].page);</span><br><span class="line">out_free:</span><br><span class="line">	kmem_cache_free(pid_ns_cachep, ns);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-net-ns"><a href="#copy-net-ns" class="headerlink" title="copy_net_ns"></a>copy_net_ns</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net *<span class="title">copy_net_ns</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct user_namespace *user_ns, struct net *old_net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; CLONE_NEWNET))</span><br><span class="line">		<span class="keyword">return</span> get_net(old_net);</span><br><span class="line">	<span class="comment">/*分配新的net结构*/</span></span><br><span class="line">	net = net_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!net)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	get_user_ns(user_ns);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;net_mutex);</span><br><span class="line">	rv = setup_net(net, user_ns);</span><br><span class="line">	<span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">		rtnl_lock();</span><br><span class="line">		list_add_tail_rcu(&amp;net-&gt;<span class="built_in">list</span>, &amp;net_namespace_list);</span><br><span class="line">		rtnl_unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;net_mutex);</span><br><span class="line">	<span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		put_user_ns(user_ns);</span><br><span class="line">		net_drop_ns(net);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(rv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.sel.zju.edu.cn/?p=556">DOCKER背后的内核知识——NAMESPACE资源隔离</a></p><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/sdulibh/article/details/51698653">Linux Kernel Namespace实现: namespace API介绍</a></p><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009732550">Linux Namespace和Cgroup</a></p><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">DOCKER基础技术：LINUX NAMESPACE（上）</a></p><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a></p><p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/113530/how-to-find-out-namespace-of-a-particular-process">how to find out namespace of a particular process?</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/namespace/" rel="tag"># namespace</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html" rel="prev" title="Linux 内核同步方式及原理"><i class="fa fa-chevron-left"></i> Linux 内核同步方式及原理</a></div><div class="post-nav-item"> <a href="/Openstack/openstack%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%A5%97%E8%99%9A%E6%8B%9F%E5%8C%96.html" rel="next" title="OpenStack中的嵌套虚拟化">OpenStack中的嵌套虚拟化<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "Linux内核/Linux-Namespace简介.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>