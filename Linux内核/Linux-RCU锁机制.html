<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="引言本文基于kernel 3.10.105对RCU源码进行分析。 RCU(Read-Copy-Update)，顾名思义就是读-拷贝-修改。"><meta property="og:type" content="article"><meta property="og:title" content="Linux RCU锁机制"><meta property="og:url" content="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-RCU%E9%94%81%E6%9C%BA%E5%88%B6.html"><meta property="og:site_name" content="工作日志"><meta property="og:description" content="引言本文基于kernel 3.10.105对RCU源码进行分析。 RCU(Read-Copy-Update)，顾名思义就是读-拷贝-修改。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://chengqian90.com/images/LinuxRCU%E9%94%81%E6%9C%BA%E5%88%B6/synchronize_rcu.png"><meta property="article:published_time" content="2017-12-04T10:11:53.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="RCU"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://chengqian90.com/images/LinuxRCU%E9%94%81%E6%9C%BA%E5%88%B6/synchronize_rcu.png"><link rel="canonical" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-RCU%E9%94%81%E6%9C%BA%E5%88%B6.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>Linux RCU锁机制 | 工作日志</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="工作日志" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">工作日志</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">实现机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83API"><span class="nav-number">4.</span> <span class="nav-text">核心API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rcu-read-lock"><span class="nav-number">4.1.</span> <span class="nav-text">rcu_read_lock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rcu-read-unlock"><span class="nav-number">4.2.</span> <span class="nav-text">rcu_read_unlock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rcu-assign-pointer"><span class="nav-number">4.3.</span> <span class="nav-text">rcu_assign_pointer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rcu-dereference"><span class="nav-number">4.4.</span> <span class="nav-text">rcu_dereference()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronize-rcu-call-rcu"><span class="nav-number">4.5.</span> <span class="nav-text">synchronize_rcu() &#x2F; call_rcu()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-rcu-gp"><span class="nav-number">4.5.1.</span> <span class="nav-text">wait_rcu_gp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wakeme-after-rcu"><span class="nav-number">4.5.2.</span> <span class="nav-text">wakeme_after_rcu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-rcu"><span class="nav-number">4.5.3.</span> <span class="nav-text">call_rcu</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">优秀资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">95</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-RCU%E9%94%81%E6%9C%BA%E5%88%B6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="工作日志"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Linux RCU锁机制</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-12-04 18:11:53" itemprop="dateCreated datePublished" datetime="2017-12-04T18:11:53+08:00">2017-12-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a></span></span><span id="/Linux%E5%86%85%E6%A0%B8/Linux-RCU%E9%94%81%E6%9C%BA%E5%88%B6.html" class="post-meta-item leancloud_visitors" data-flag-title="Linux RCU锁机制" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.7k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文基于kernel 3.10.105对RCU源码进行分析。</p><p>RCU(Read-Copy-Update)，顾名思义就是读-拷贝-修改。</p><span id="more"></span><p>RCU背后的基本思想是将破坏性操作分为两部分，一部分是防止任何人看到数据项被销毁，另一部分是实际销毁。这两个部分之间必须有一个“宽限期”，并且“宽限期”必须足够长，以至于<strong>任何访问被删除项目的读者都已经放弃了他们的引用</strong>。例如，从链接列表中删除一个RCU将首先从列表中删除该项目，等待宽限期过去，然后释放该元素。</p><p>在kernel中，rcu有tiny rcu和tree rcu两种实现，tiny rcu更加简洁，通常用在小型嵌入式系统中，tree rcu则被广泛使用在了server, desktop以及android系统中。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RCU实际上是一种改进的rwlock，读者几乎没有什么同步开销，它不需要锁，不使用原子指令，因此不会导致锁竞争，内存延迟以及流水线停滞。不需要锁也使得使用更容易，因为死锁问题就不需要考虑了。</p><ul><li>写者的同步开销比较大，它需要<strong>延迟数据结构的释放，复制被修改的数据结构</strong>，它也必须<strong>使用某种锁机制同步并行的其它写者的修改操作</strong>。</li><li>读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改的时机。</li><li>有一个专门的<strong>垃圾收集器</strong>来探测读者的信号，一旦所有的读者都已经发送信号告知它们都不在使用被RCU保护的数据结构，垃圾收集器就<strong>调用回调函数</strong>完成最后的数据释放或修改操作。</li></ul><p>RCU与rwlock的不同之处是：它既允许多个读者同时访问被保护的数据，又允许多个读者和多个写者同时访问被保护的数据（注意：是否可以有多个写者并行访问取决于写者之间使用的同步机制），读者没有任何同步开销，而写者的同步开销则取决于使用的写者间同步机制。但RCU不能替代rwlock，因为如果写比较多时，对读者的性能提高不能弥补写者导致的损失。</p><p><strong>读者</strong>在访问被RCU保护的共享数据期间<strong>不能被阻塞</strong>，这是RCU机制得以实现的一个基本前提，也就说当读者在引用被RCU保护的共享数据期间，读者所在的CPU不能发生上下文切换，spinlock和rwlock都需要这样的前提。</p><p>写者在访问被RCU保护的共享数据时不需要和读者竞争任何锁，只有在有多于一个写者的情况下需要获得某种锁以与其他写者同步。写者修改数据前首先<strong>拷贝一个被修改元素的副本，然后在副本上进行修改，修改完毕后它向垃圾回收器注册一个回调函数以便在适当的时机执行真正的修改操作</strong>。等待适当时机的这一时期称为宽限期（grace period），而CPU发生了上下文切换称为经历一个quiescent state，<strong>grace period就是所有CPU都经历一次quiescent state所需要的等待的时间</strong>。垃圾收集器就是在grace period之后调用写者注册的回调函数来完成真正的数据修改或数据释放操作的。</p><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>对于读者，RCU 仅需要抢占失效，因此获得读锁和释放读锁分别定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>变种为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rcu_read_lock_bh</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rcu_read_unlock_bh</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个变种只在修改是通过 <code>call_rcu_bh</code>进行的情况下使用，因为 <code>call_rcu_bh</code>将把 softirq 的执行完毕也认为是一个 quiescent state，因此如果修改是通过 <code>call_rcu_bh</code> 进行的，在进程上下文的读端临界区必须使用这一变种。</p><p>每一个 CPU 维护两个数据结构 <code>rcu_sched_data</code>，<code>rcu_bh_data</code>，它们用于<strong>保存</strong>回调函数。函数<code>call_rcu</code>和函数<code>call_rcu_bh</code>用于<strong>注册</strong>回调函数，前者把回调函数注册到<code>rcu_sched_data</code>，而后者则把回调函数注册到<code>rcu_bh_data</code>，在每一个数据结构上，回调函数被组成一个链表，先注册的排在前头，后注册的排在末尾。</p><p>时钟中断处理函数（<code>update_process_times</code>）调用函数<code>rcu_check_callbacks</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rcu_check_callbacks</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">int</span> user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	check_cpu_stalls();</span><br><span class="line">	<span class="keyword">if</span> (user || rcu_is_cpu_rrupt_from_idle())</span><br><span class="line">		rcu_sched_qs(cpu);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!in_softirq())</span><br><span class="line">		rcu_bh_qs(cpu);</span><br><span class="line">	rcu_preempt_check_callbacks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>rcu_check_callbacks</code>首先检查该CPU是否经历了一个quiescent state，如果(或)：</p><ul><li>当前进程运行在用户态；</li><li>当前进程为idle且当前不处在运行softirq状态，也不处在运行IRQ处理函数的状态；</li></ul><p>那么，该CPU已经经历了一个quiescent state，因此通过调用函数<code>rcu_sched_qs</code>和<code>rcu_bh_qs</code>标记该CPU的数据结构<code>rcu_sched_data</code>和<code>rcu_bh_data</code>的标记字段<code>passed_quiesc</code>，以记录该CPU已经经历一个quiescent state。</p><p>否则，如果当前不处在运行softirq状态，那么，只标记该CPU的数据结构<code>rcu_bh_data</code>的标记字段<code>passed_quiesc</code>，以记录该CPU已经经历一个quiescent state。注意，该标记只对rcu_bh_data有效。</p><p>然后，函数rcu_check_callbacks将调用开启<code>RCU_SOFTIRQ</code>。</p><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>API还有许多其他的成员，其余的都可以用这五个来表示，但是大多数的实现都是用call_rcu()回调API来表示synchronize_rcu()。</p><h3 id="rcu-read-lock"><a href="#rcu-read-lock" class="headerlink" title="rcu_read_lock()"></a>rcu_read_lock()</h3><p>读者在读取由RCU保护的共享数据时使用该函数标记它进入读端临界区。</p><h3 id="rcu-read-unlock"><a href="#rcu-read-unlock" class="headerlink" title="rcu_read_unlock()"></a>rcu_read_unlock()</h3><p>该函数与rcu_read_lock配对使用，用以标记读者退出读端临界区。夹在这两个函数之间的代码区称为”读端临界区”(read-side critical section)。读端临界区可以嵌套。</p><h3 id="rcu-assign-pointer"><a href="#rcu-assign-pointer" class="headerlink" title="rcu_assign_pointer()"></a>rcu_assign_pointer()</h3><p>将指定的值分配给受RCU保护的指针，确保任何并发的RCU读取器都能看到任何先前的初始化。（<strong>赋值</strong>）</p><p>将内存屏障插入到需要它们的体系结构中（其中大部分都是这样），并且还防止编译器在指针分配后重新排序初始化结构的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_assign_pointer(p, v) \</span></span><br><span class="line"><span class="meta">	__rcu_assign_pointer((p), (v), __rcu)</span></span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rcu_assign_pointer(p, v, space) \</span></span><br><span class="line"><span class="meta">	do &#123; \</span></span><br><span class="line"><span class="meta">		smp_wmb(); \</span></span><br><span class="line"><span class="meta">		(p) = (typeof(*v) __force space *)(v); \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>在一些特殊情况下，可以使用RCU_INIT_POINTER()而不是rcu_assign_pointer()。 由于RCU_INIT_POINTER()不限制CPU或编译器，因此RCU_INIT_POINTER()速度更快。</p><p>但是，当你应该使用rcu_assign_pointer()而使用了RCU_INIT_POINTER()时，是一件非常糟糕的事情，它会导致无法诊断内存损坏。</p><h3 id="rcu-dereference"><a href="#rcu-dereference" class="headerlink" title="rcu_dereference()"></a>rcu_dereference()</h3><p>获取RCU保护的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_dereference(p) rcu_dereference_check(p, 0)</span></span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="comment">//c 为解除引用的条件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_dereference_check(p, c) \</span></span><br><span class="line"><span class="meta">	__rcu_dereference_check((p), rcu_read_lock_held() || (c), __rcu)</span></span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rcu_dereference_check(p, c, space) \</span></span><br><span class="line"><span class="meta">	(&#123; \</span></span><br><span class="line"><span class="meta">		typeof(*p) *_________p1 = (typeof(*p)*__force )ACCESS_ONCE(p); \</span></span><br><span class="line"><span class="meta">		rcu_lockdep_assert(c, <span class="meta-string">&quot;suspicious rcu_dereference_check()&quot;</span> \</span></span><br><span class="line"><span class="meta">				      <span class="meta-string">&quot; usage&quot;</span>); \</span></span><br><span class="line"><span class="meta">		rcu_dereference_sparse(p, space); \</span></span><br><span class="line"><span class="meta">		smp_read_barrier_depends(); \</span></span><br><span class="line"><span class="meta">		((typeof(*p) __force __kernel *)(_________p1)); \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="synchronize-rcu-call-rcu"><a href="#synchronize-rcu-call-rcu" class="headerlink" title="synchronize_rcu() / call_rcu()"></a>synchronize_rcu() / call_rcu()</h3><p>synchronize_rcu()在RCU中是一个<strong>最核心</strong>的函数,它用来等待之前的读者全部退出。</p><p>在完整的宽限期结束后，即在所有当前正在执行的RCU读取端临界区完成之后，控制权会在一段时间后返回给调用者。</p><p>但是，请注意，从synchronize_rcu()返回时，调用者可能会同时执行新的RCU读取端临界区，这些区在synchronize_rcu()正在等待时开始。 RCU读取端临界区由rcu_read_lock()和rcu_read_unlock()定界，并且可以嵌套。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">    <span class="comment">// start_kernel()-&gt;rest_init()-&gt;rcu_scheduler_starting()</span></span><br><span class="line">	<span class="keyword">if</span> (!rcu_scheduler_active)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// rcupdate.c </span></span><br><span class="line">    <span class="comment">// module_param(rcu_expedited, int, 0);</span></span><br><span class="line">	<span class="keyword">if</span> (rcu_expedited)</span><br><span class="line">		synchronize_rcu_expedited();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		wait_rcu_gp(call_rcu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RCU_BOOST</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本思想是调用synchronize_sched_expedited()将所有任务推送到 -&gt;blkd_tasks列表并等待这个列表排空。 </span></span><br><span class="line"><span class="comment">这会在所有CPU上消耗大量时间，并且对实时工作负载不利，因此不建议用于任何类型的常见代码。</span></span><br><span class="line"><span class="comment">实际上，如果您在循环中使用synchronize_rcu_expedited()，请重构您的代码以批量更新，然后改为使用一个synchronize_rcu()。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请注意，在保持CPU热插拔通知程序获取的任何锁定的同时调用此函数是非法的。 </span></span><br><span class="line"><span class="comment">从CPU-hotplug通知器调用此函数也是非法的。 不遵守这些限制将导致死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu_expedited</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span> *<span class="title">rnp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_state</span> *<span class="title">rsp</span> =</span> &amp;rcu_preempt_state;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> snap;</span><br><span class="line">	<span class="keyword">int</span> trycount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	smp_mb(); <span class="comment">/* Caller&#x27;s modifications seen first by other CPUs. */</span></span><br><span class="line">	snap = ACCESS_ONCE(sync_rcu_preempt_exp_count) + <span class="number">1</span>;</span><br><span class="line">	smp_mb(); <span class="comment">/* Above access cannot bleed into critical section. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 阻止CPU热插拔操作。</span></span><br><span class="line"><span class="comment">     这意味着找到一个rcu_node结构的任务的CPU热插拔操作将会知道阻塞这个加速宽限期的所有任务已经处于提升过程中。 这简化了将任务从叶子移动到根rcu_node结构的过程。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	get_online_cpus();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取锁定，如果锁定采集失败太多，则回退到synchronize_rcu()。</span></span><br><span class="line"><span class="comment">    当然，如果有人对我们加快宽限期，就离开。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (!mutex_trylock(&amp;sync_rcu_preempt_exp_mutex)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ULONG_CMP_LT(snap,</span><br><span class="line">		    ACCESS_ONCE(sync_rcu_preempt_exp_count))) &#123;</span><br><span class="line">			put_online_cpus();</span><br><span class="line">			<span class="keyword">goto</span> mb_ret; <span class="comment">/* Others did our work for us. */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (trycount++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">			udelay(trycount * num_online_cpus());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			put_online_cpus();</span><br><span class="line">			wait_rcu_gp(call_rcu);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ULONG_CMP_LT(snap, ACCESS_ONCE(sync_rcu_preempt_exp_count))) &#123;</span><br><span class="line">		put_online_cpus();</span><br><span class="line">		<span class="keyword">goto</span> unlock_mb_ret; <span class="comment">/* Others did our work for us. */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 强制所有RCU readers 进入 -&gt; blkd_tasks列表 */</span></span><br><span class="line">	synchronize_sched_expedited();</span><br><span class="line">	<span class="comment">/* 初始化所有非叶rcu_node结构的expmask */</span></span><br><span class="line">	rcu_for_each_nonleaf_node_breadth_first(rsp, rnp) &#123;</span><br><span class="line">		raw_spin_lock_irqsave(&amp;rnp-&gt;lock, flags);</span><br><span class="line">		rnp-&gt;expmask = rnp-&gt;qsmaskinit;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对 blkd_tasks列表的当前状态进行快照 */</span></span><br><span class="line">	rcu_for_each_leaf_node(rsp, rnp)</span><br><span class="line">		sync_rcu_preempt_exp_init(rsp, rnp);</span><br><span class="line">	<span class="keyword">if</span> (NUM_RCU_NODES &gt; <span class="number">1</span>)</span><br><span class="line">		sync_rcu_preempt_exp_init(rsp, rcu_get_root(rsp));</span><br><span class="line"></span><br><span class="line">	put_online_cpus();</span><br><span class="line">	<span class="comment">/* 等待快照 blkd_tasks列表消失. */</span></span><br><span class="line">	rnp = rcu_get_root(rsp);</span><br><span class="line">	wait_event(sync_rcu_preempt_exp_wq,</span><br><span class="line">		   sync_rcu_preempt_exp_done(rnp));</span><br><span class="line">	<span class="comment">/* Clean up and exit. */</span></span><br><span class="line">	smp_mb(); <span class="comment">/* 确保在计数器增量前看到加速的GP */</span></span><br><span class="line">	ACCESS_ONCE(sync_rcu_preempt_exp_count)++;</span><br><span class="line">unlock_mb_ret:</span><br><span class="line">	mutex_unlock(&amp;sync_rcu_preempt_exp_mutex);</span><br><span class="line">mb_ret:</span><br><span class="line">	smp_mb(); <span class="comment">/* 确保宽限期后的后续行动 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu_expedited</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	synchronize_sched_expedited();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>函数<code>synchronize_sched_expedited</code>此处先不分析。开始分析<code>wait_rcu_gp</code>。</p><h4 id="wait-rcu-gp"><a href="#wait-rcu-gp" class="headerlink" title="wait_rcu_gp"></a>wait_rcu_gp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_synchronize</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">completion</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_rcu_gp</span><span class="params">(<span class="keyword">call_rcu_func_t</span> crf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_synchronize</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="comment">/*debug相关*/</span></span><br><span class="line">	init_rcu_head_on_stack(&amp;rcu.head);</span><br><span class="line">    <span class="comment">/*初始化完成变量。完成变量的操作可参考之前的文章*/</span></span><br><span class="line">	init_completion(&amp;rcu.completion);</span><br><span class="line">	<span class="comment">/* Will wake me after RCU finished. */</span></span><br><span class="line">	crf(&amp;rcu.head, wakeme_after_rcu);</span><br><span class="line">	<span class="comment">/* Wait for it. */</span></span><br><span class="line">	wait_for_completion(&amp;rcu.completion);</span><br><span class="line">	destroy_rcu_head_on_stack(&amp;rcu.head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以重要步骤为 <code>crf(&amp;rcu.head, wakeme_after_rcu);</code>，分别进行分析。</p><h4 id="wakeme-after-rcu"><a href="#wakeme-after-rcu" class="headerlink" title="wakeme_after_rcu"></a>wakeme_after_rcu</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*此函数是对完成变量进行唤醒操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wakeme_after_rcu</span><span class="params">(struct rcu_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_synchronize</span> *<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu = container_of(head, struct rcu_synchronize, head);</span><br><span class="line">	complete(&amp;rcu-&gt;completion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="call-rcu"><a href="#call-rcu" class="headerlink" title="call_rcu"></a>call_rcu</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_rcu</span><span class="params">(struct rcu_head *head, <span class="keyword">void</span> (*func)(struct rcu_head *rcu))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__call_rcu(head, func, &amp;rcu_preempt_state, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将参数传入的回调函数fun赋值给一个struct rcu_head变量，</span></span><br><span class="line"><span class="comment">再将这个struct rcu_head加在了per_cpu变量rcu_data的nxttail 链表上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__call_rcu(struct rcu_head *head, <span class="keyword">void</span> (*func)(struct rcu_head *rcu),</span><br><span class="line">	   struct rcu_state *rsp, <span class="keyword">int</span> cpu, <span class="keyword">bool</span> lazy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_data</span> *<span class="title">rdp</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE((<span class="keyword">unsigned</span> <span class="keyword">long</span>)head &amp; <span class="number">0x3</span>); <span class="comment">/* Misaligned rcu_head! */</span></span><br><span class="line">	debug_rcu_head_queue(head);</span><br><span class="line">	head-&gt;func = func;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	rdp = this_cpu_ptr(rsp-&gt;rda);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add the callback to our list. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rdp-&gt;nxttail[RCU_NEXT_TAIL] == <span class="literal">NULL</span>) || cpu != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> offline;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cpu != <span class="number">-1</span>)</span><br><span class="line">			rdp = per_cpu_ptr(rsp-&gt;rda, cpu);</span><br><span class="line">		offline = !__call_rcu_nocb(rdp, head, lazy);</span><br><span class="line">		WARN_ON_ONCE(offline);</span><br><span class="line">		<span class="comment">/* _call_rcu() is illegal on offline CPU; leak the callback. */</span></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ACCESS_ONCE(rdp-&gt;qlen)++;</span><br><span class="line">	<span class="keyword">if</span> (lazy)</span><br><span class="line">		rdp-&gt;qlen_lazy++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rcu_idle_count_callbacks_posted();</span><br><span class="line">	smp_mb();  <span class="comment">/* Count before adding callback for rcu_barrier(). */</span></span><br><span class="line">	*rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;</span><br><span class="line">	rdp-&gt;nxttail[RCU_NEXT_TAIL] = &amp;head-&gt;next;</span><br><span class="line">	…………</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上所述，<code>synchronize_rcu</code>的调用关系图如下：</p><p><img src="/images/LinuxRCU%E9%94%81%E6%9C%BA%E5%88%B6/synchronize_rcu.png" alt="synchronize_rcu"></p><p>之前说，只需要判断所有的CPU都进过了一次上下文切换，就说明所有读者已经退出了。为什么这么说呢？要彻底弄清楚这个问题，我们得从RCU的初始化说起。</p><h2 id="优秀资料"><a href="#优秀资料" class="headerlink" title="优秀资料"></a>优秀资料</h2><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/106856/">深入理解 RCU 实现</a></p><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/kernel_synchronization/223.html">RCU synchronize原理分析</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/RCU/" rel="tag"># RCU</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E5%86%85%E6%A0%B8/Cache%E5%92%8CBuffer%E7%9A%84%E5%8C%BA%E5%88%AB.html" rel="prev" title="Cache和Buffer的区别"><i class="fa fa-chevron-left"></i> Cache和Buffer的区别</a></div><div class="post-nav-item"> <a href="/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html" rel="next" title="Linux 内核同步方式及原理">Linux 内核同步方式及原理<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "Linux内核/Linux-RCU锁机制.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>