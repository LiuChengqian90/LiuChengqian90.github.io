<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="基于 kernel 3.10.105 分析。"><meta property="og:type" content="article"><meta property="og:title" content="NAPI&#x2F;非NAPI收包分析"><meta property="og:url" content="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90.html"><meta property="og:site_name" content="工作日志"><meta property="og:description" content="基于 kernel 3.10.105 分析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://chengqian90.com/images/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90/ixgb_desc_ring.png"><meta property="article:published_time" content="2018-01-07T13:48:00.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="NAPI"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://chengqian90.com/images/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90/ixgb_desc_ring.png"><link rel="canonical" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>NAPI/非NAPI收包分析 | 工作日志</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="工作日志" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">工作日志</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#softnet-data"><span class="nav-number">1.</span> <span class="nav-text">softnet_data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9ENAPI"><span class="nav-number">2.</span> <span class="nav-text">非NAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vortex-rx"><span class="nav-number">2.1.</span> <span class="nav-text">vortex_rx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netif-rx"><span class="nav-number">2.2.</span> <span class="nav-text">netif_rx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-backlog"><span class="nav-number">2.3.</span> <span class="nav-text">process_backlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NAPI"><span class="nav-number">3.</span> <span class="nav-text">NAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#net-device%E5%86%85%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">net_device内相关结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-netdev-ops"><span class="nav-number">3.2.</span> <span class="nav-text">ixgb_netdev_ops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-open"><span class="nav-number">3.3.</span> <span class="nav-text">ixgb_open</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ixgb-setup-rx-resources"><span class="nav-number">3.3.1.</span> <span class="nav-text">ixgb_setup_rx_resources</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-up"><span class="nav-number">3.4.</span> <span class="nav-text">ixgb_up</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-intr"><span class="nav-number">3.5.</span> <span class="nav-text">ixgb_intr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#napi-schedule"><span class="nav-number">3.6.</span> <span class="nav-text">__napi_schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#net-rx-action"><span class="nav-number">3.7.</span> <span class="nav-text">net_rx_action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-clean"><span class="nav-number">3.8.</span> <span class="nav-text">ixgb_clean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ixgb-clean-rx-irq"><span class="nav-number">3.9.</span> <span class="nav-text">ixgb_clean_rx_irq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">3.10.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">95</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">150</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="工作日志"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> NAPI/非NAPI收包分析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-01-07 21:48:00" itemprop="dateCreated datePublished" datetime="2018-01-07T21:48:00+08:00">2018-01-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a></span></span><span id="/Linux%E5%86%85%E6%A0%B8/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90.html" class="post-meta-item leancloud_visitors" data-flag-title="NAPI/非NAPI收包分析" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>16k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>基于 kernel 3.10.105 分析。</p><span id="more"></span><h2 id="softnet-data"><a href="#softnet-data" class="headerlink" title="softnet_data"></a>softnet_data</h2><p>每个CPU都有队列，用来接收进来的帧。因为每个CPU都有其数据结构用来处理入口和出口流量，因此，不同CPU之间没必要使用上锁机制。此队列的数据结构softnet_data定义在<code>include/linux/netdevice.h</code>中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> &#123;</span>  	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span>		*<span class="title">output_queue</span>;</span>			<span class="comment">/*出口规则队列*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span>		**<span class="title">output_queue_tailp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">poll_list</span>;</span>				<span class="comment">/*双向列表，其中是设备有数据要传输*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">completion_queue</span>;</span>		<span class="comment">/*缓冲区列表，其中的缓冲已成功传输，因此可以释放掉*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">process_queue</span>;</span>			<span class="comment">/*要处理的包(skb)*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* stats */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		processed;				<span class="comment">/*已处理的包(skb)*/</span></span><br><span class="line">  	<span class="comment">/*如果`ksoftirq`进程在cpu-time启动之前无法处理网络设备环形缓冲区中所有可用的数据包，则会更新`time_squeeze`*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		time_squeeze;			</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu_collision;			<span class="comment">/*发送数据时，发包队列被其他CPU占用则更新此字段*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		received_rps;			<span class="comment">/*RPS收到的包*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span>	*<span class="title">rps_ipi_list</span>;</span>			<span class="comment">/*本地RPS队列*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">call_single_data</span>	<span class="title">csd</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">  	<span class="comment">/*下一个要处理的 data，和rps_ipi_list 主要应用于rps_ipi_queued函数 和 	net_rps_action_and_irq_enable 函数。*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span>	*<span class="title">rps_ipi_next</span>;</span>			</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;					<span class="comment">/*字段所属cpu*/</span></span><br><span class="line">  	<span class="comment">/*RPS队列头尾计数*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		input_queue_head;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		input_queue_tail;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		dropped;				<span class="comment">/*丢包计数*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">input_pkt_queue</span>;</span>		<span class="comment">/*保存进来的帧*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span>	<span class="title">backlog</span>;</span>				<span class="comment">/*虚拟的NAPI设备*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化在文件<code>net/core/dev.c</code>的函数<code>net_dev_init</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	……</span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;per_cpu(softnet_data, i);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(sd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sd));</span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">		sd-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">		INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">		sd-&gt;output_queue = <span class="literal">NULL</span>;</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line">      	<span class="comment">/*RPS相关*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;csd.flags = <span class="number">0</span>;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">		sd-&gt;backlog.gro_list = <span class="literal">NULL</span>;</span><br><span class="line">		sd-&gt;backlog.gro_count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非NAPI"><a href="#非NAPI" class="headerlink" title="非NAPI"></a>非NAPI</h2><p>以<code>vortex_rx</code>为例。</p><p><code>vortex_interrupt</code>为中断处理函数，收包调用<code>vortex_rx</code>。</p><h3 id="vortex-rx"><a href="#vortex-rx" class="headerlink" title="vortex_rx"></a>vortex_rx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vortex_rx</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vortex_private</span> *<span class="title">vp</span> =</span> netdev_priv(dev);</span><br><span class="line">	<span class="keyword">void</span> __iomem *ioaddr = vp-&gt;ioaddr;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">short</span> rx_status;</span><br><span class="line">		……</span><br><span class="line">			<span class="comment">/* The packet length: up to 4.5K!. */</span></span><br><span class="line">			<span class="keyword">int</span> pkt_len = rx_status &amp; <span class="number">0x1fff</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">			<span class="comment">/*skb空间分配*/</span></span><br><span class="line">			skb = netdev_alloc_skb(dev, pkt_len + <span class="number">5</span>);</span><br><span class="line">			……</span><br><span class="line">              	……</span><br><span class="line">				skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">				netif_rx(skb);</span><br><span class="line">				dev-&gt;stats.rx_packets++;</span><br><span class="line">          ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="netif-rx"><a href="#netif-rx" class="headerlink" title="netif_rx"></a>netif_rx</h3><p>非NAPI处理报文上半部函数为<code>netif_rx</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netif_rx</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> (netpoll_rx(skb))</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	<span class="comment">/*检查时间戳*/</span></span><br><span class="line">	net_timestamp_check(netdev_tstamp_prequeue, skb);</span><br><span class="line">	trace_netif_rx(skb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">	<span class="keyword">if</span> (static_key_false(&amp;rps_needed)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rps_dev_flow</span> <span class="title">voidflow</span>, *<span class="title">rflow</span> =</span> &amp;voidflow;</span><br><span class="line">		<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">		preempt_disable();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span><br><span class="line">		<span class="keyword">if</span> (cpu &lt; <span class="number">0</span>)</span><br><span class="line">			cpu = smp_processor_id();</span><br><span class="line">		ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		preempt_enable();</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> qtail;</span><br><span class="line">      	<span class="comment">/*入队*/</span></span><br><span class="line">      	<span class="comment">/*get_cpu 禁止抢占--返回当前cpu id*/</span></span><br><span class="line">		ret = enqueue_to_backlog(skb, get_cpu(), &amp;qtail);</span><br><span class="line">		put_cpu();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enqueue_to_backlog</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> cpu,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">int</span> *qtail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	sd = &amp;per_cpu(softnet_data, cpu);</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	rps_lock(sd);</span><br><span class="line">  	<span class="comment">/*空间充足*/</span></span><br><span class="line">	<span class="keyword">if</span> (skb_queue_len(&amp;sd-&gt;input_pkt_queue) &lt;= netdev_max_backlog) &#123;</span><br><span class="line">      	<span class="comment">/*不为0，说明设备已得到调度，skb入队*/</span></span><br><span class="line">		<span class="keyword">if</span> (skb_queue_len(&amp;sd-&gt;input_pkt_queue)) &#123;</span><br><span class="line">enqueue:</span><br><span class="line">			__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);</span><br><span class="line">			input_queue_tail_incr_save(sd, qtail);</span><br><span class="line">			rps_unlock(sd);</span><br><span class="line">			local_irq_restore(flags);</span><br><span class="line">			<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*本CPU默认的NAPI加入要处理的poll_list队列；</span></span><br><span class="line"><span class="comment">		之后触发软中断，但是由于处于硬中断中，所以软中断暂时失效，所以继续 enqueue</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!rps_ipi_queued(sd))</span><br><span class="line">				____napi_schedule(sd, &amp;sd-&gt;backlog);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> enqueue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sd-&gt;dropped++;</span><br><span class="line">	rps_unlock(sd);</span><br><span class="line"></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;skb-&gt;dev-&gt;rx_dropped);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下半部处理函数 <code>net_rx_action</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">			work = n-&gt;poll(n, weight);</span><br><span class="line">			trace_napi_poll(n);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><p>会调用CPU默认处理函数<code>process_backlog</code>。</p><h3 id="process-backlog"><a href="#process-backlog" class="headerlink" title="process_backlog"></a>process_backlog</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*quota为本次要处理的包个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process_backlog</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> quota)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> work = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> container_of(napi, struct softnet_data, backlog);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">	<span class="comment">/* Check if we have pending ipi, its better to send them now,</span></span><br><span class="line"><span class="comment">	 * not waiting net_rx_action() end.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sd-&gt;rps_ipi_list) &#123;</span><br><span class="line">		local_irq_disable();</span><br><span class="line">		net_rps_action_and_irq_enable(sd);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  	<span class="comment">/*weight_p 为全局变量，默认为64*/</span></span><br><span class="line">	napi-&gt;weight = weight_p;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">  	<span class="comment">/*已处理的小于请求处理，则继续循环*/</span></span><br><span class="line">	<span class="keyword">while</span> (work &lt; quota) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> qlen;</span><br><span class="line">		<span class="comment">/*处理队列不为空，则继续；第一次为空*/</span></span><br><span class="line">         <span class="comment">/*数据包到来时首先填充input_pkt_queue，而在处理时从process_queue中取，</span></span><br><span class="line"><span class="comment">         因此首次处理process_queue必定为空。</span></span><br><span class="line"><span class="comment">         如果input_pkt_queue不为空，则把其中的数据包迁移到process_queue中，然后继续处理，减少锁冲突。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) &#123;</span><br><span class="line">			rcu_read_lock();</span><br><span class="line">			local_irq_enable();</span><br><span class="line">          	<span class="comment">/*每个包循环上送协议栈*/</span></span><br><span class="line">			__netif_receive_skb(skb);</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			local_irq_disable();</span><br><span class="line">          	<span class="comment">/*增加处理head计数*/</span></span><br><span class="line">			input_queue_head_incr(sd);</span><br><span class="line">			<span class="keyword">if</span> (++work &gt;= quota) &#123;</span><br><span class="line">				local_irq_enable();</span><br><span class="line">				<span class="keyword">return</span> work;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*获取接收队列包数量并将其插入process_queue队列*/</span></span><br><span class="line">		rps_lock(sd);</span><br><span class="line">		qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		<span class="keyword">if</span> (qlen)</span><br><span class="line">			skb_queue_splice_tail_init(&amp;sd-&gt;input_pkt_queue,</span><br><span class="line">						   &amp;sd-&gt;process_queue);</span><br><span class="line">		<span class="comment">/*为真说明本次处理肯定能处理完成，因此直接del队列即可*/</span></span><br><span class="line">		<span class="keyword">if</span> (qlen &lt; quota - work) &#123;</span><br><span class="line">			list_del(&amp;napi-&gt;poll_list);</span><br><span class="line">			napi-&gt;state = <span class="number">0</span>;</span><br><span class="line">			quota = work + qlen;</span><br><span class="line">		&#125;</span><br><span class="line">		rps_unlock(sd);</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>非NAPI是一次中断一次上送，流量突增时，则中断增多，CPU处理时间变少。</p><h2 id="NAPI"><a href="#NAPI" class="headerlink" title="NAPI"></a>NAPI</h2><p>NAPI混合了中断事件和轮询，而不使用纯粹的中断事件驱动模型。如果接收到新帧时，内核还没完成处理前几个帧的工作，驱动程序就没必要产生其他中断事件：让内核一直处理设备输入队列中的数据会比较简单（该设备中断功能关闭），然后当队列为空时，再重新开启中断功能。</p><h3 id="net-device内相关结构"><a href="#net-device内相关结构" class="headerlink" title="net_device内相关结构"></a>net_device内相关结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">napi_list</span>;</span></span><br></pre></td></tr></table></figure><p>初始化函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_netdev_mqs</span><span class="params">(<span class="keyword">int</span> sizeof_priv, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">void</span> (*setup)(struct net_device *),</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> txqs, <span class="keyword">unsigned</span> <span class="keyword">int</span> rxqs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  INIT_LIST_HEAD(&amp;dev-&gt;napi_list);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>netif_napi_add</code>中更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">netif_napi_add</span><span class="params">(struct net_device *dev, struct napi_struct *napi,</span></span></span><br><span class="line"><span class="params"><span class="function">		    <span class="keyword">int</span> (*poll)(struct napi_struct *, <span class="keyword">int</span>), <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*初始化napi信息*/</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;napi-&gt;poll_list);</span><br><span class="line">	napi-&gt;gro_count = <span class="number">0</span>;</span><br><span class="line">	napi-&gt;gro_list = <span class="literal">NULL</span>;</span><br><span class="line">	napi-&gt;skb = <span class="literal">NULL</span>;</span><br><span class="line">  	<span class="comment">/*poll为napi处理函数，一般由驱动而定*/</span></span><br><span class="line">	napi-&gt;poll = poll;</span><br><span class="line">	<span class="keyword">if</span> (weight &gt; NAPI_POLL_WEIGHT)</span><br><span class="line">		pr_err_once(<span class="string">&quot;netif_napi_add() called with weight %d on device %s\n&quot;</span>,</span><br><span class="line">			    weight, dev-&gt;name);</span><br><span class="line">  	<span class="comment">/*处理包数量*/</span></span><br><span class="line">	napi-&gt;weight = weight;</span><br><span class="line">  	<span class="comment">/*dev_list 插入 dev-&gt;napi_list链表*/</span></span><br><span class="line">	list_add(&amp;napi-&gt;dev_list, &amp;dev-&gt;napi_list);</span><br><span class="line">	napi-&gt;dev = dev;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETPOLL</span></span><br><span class="line">	spin_lock_init(&amp;napi-&gt;poll_lock);</span><br><span class="line">	napi-&gt;poll_owner = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_bit(NAPI_STATE_SCHED, &amp;napi-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而<code>netif_napi_add</code>一般在驱动函数中调用，这里以<code>ixgb</code>为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设备初始化例程*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">    <span class="comment">/*net_device结构分配*/</span></span><br><span class="line">	netdev = alloc_etherdev(<span class="keyword">sizeof</span>(struct ixgb_adapter));</span><br><span class="line">  	<span class="comment">/*adapter为设备私有数据（适配器）*/</span></span><br><span class="line">  	netdev-&gt;netdev_ops = &amp;ixgb_netdev_ops;</span><br><span class="line">	ixgb_set_ethtool_ops(netdev);</span><br><span class="line">	netdev-&gt;watchdog_timeo = <span class="number">5</span> * HZ;</span><br><span class="line">	adapter = netdev_priv(netdev);</span><br><span class="line">  	……</span><br><span class="line">    <span class="comment">/*adapter-&gt;napi 初始化并加入设备napi_list链表*/</span></span><br><span class="line">    <span class="comment">/*weight 为 64*/</span></span><br><span class="line">	netif_napi_add(netdev, &amp;adapter-&gt;napi, ixgb_clean, <span class="number">64</span>);</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ixgb-netdev-ops"><a href="#ixgb-netdev-ops" class="headerlink" title="ixgb_netdev_ops"></a>ixgb_netdev_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">ixgb_netdev_ops</span> =</span> &#123;</span><br><span class="line">	.ndo_open 		= ixgb_open,</span><br><span class="line">	.ndo_stop		= ixgb_close,</span><br><span class="line">	.ndo_start_xmit		= ixgb_xmit_frame,</span><br><span class="line">	.ndo_get_stats		= ixgb_get_stats,</span><br><span class="line">	.ndo_set_rx_mode	= ixgb_set_multi,</span><br><span class="line">	.ndo_validate_addr	= eth_validate_addr,</span><br><span class="line">	.ndo_set_mac_address	= ixgb_set_mac,</span><br><span class="line">	.ndo_change_mtu		= ixgb_change_mtu,</span><br><span class="line">	.ndo_tx_timeout		= ixgb_tx_timeout,</span><br><span class="line">	.ndo_vlan_rx_add_vid	= ixgb_vlan_rx_add_vid,</span><br><span class="line">	.ndo_vlan_rx_kill_vid	= ixgb_vlan_rx_kill_vid,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line">	.ndo_poll_controller	= ixgb_netpoll,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	.ndo_fix_features       = ixgb_fix_features,</span><br><span class="line">	.ndo_set_features       = ixgb_set_features,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，驱动open函数为 <code>ixgb_open</code>。</p><h3 id="ixgb-open"><a href="#ixgb-open" class="headerlink" title="ixgb_open"></a>ixgb_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此函数在设备active时调用(系统 IFF_UP标志)；</span></span><br><span class="line"><span class="comment">分配发送和接收资源；</span></span><br><span class="line"><span class="comment">分配中断号；</span></span><br><span class="line"><span class="comment">设置watchdog timer等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_open</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_adapter</span> *<span class="title">adapter</span> =</span> netdev_priv(netdev);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	err = ixgb_setup_tx_resources(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_tx;</span><br><span class="line">	netif_carrier_off(netdev);</span><br><span class="line">	err = ixgb_setup_rx_resources(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_rx;</span><br><span class="line"></span><br><span class="line">	err = ixgb_up(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_up;</span><br><span class="line">	netif_start_queue(netdev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ixgb-setup-rx-resources"><a href="#ixgb-setup-rx-resources" class="headerlink" title="ixgb_setup_rx_resources"></a>ixgb_setup_rx_resources</h4><p>函数<code>ixgb_setup_rx_resources</code>是为收包分配资源的函数。</p><p>主要数据结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*封装一个指向套接字缓冲区的指针，所以一个DMA句柄可以和缓冲区一起存储*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ixgb_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">dma_addr_t</span> dma;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> time_stamp;</span><br><span class="line">	u16 length;</span><br><span class="line">	u16 next_to_watch;</span><br><span class="line">	u16 mapped_as_page;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ixgb_desc_ring</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *desc;							<span class="comment">/* 指向描述符ring的指针 */</span></span><br><span class="line">	<span class="keyword">dma_addr_t</span> dma;						<span class="comment">/* 描述符环的物理地址；dna_addr_t 32位系统为u32 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;					<span class="comment">/* 描述符ring的长度，以字节为单位 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;					<span class="comment">/* ring之后描述符的数量 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> next_to_use;			<span class="comment">/* 下一个关联缓冲区的描述符 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> next_to_clean;			<span class="comment">/* 下一个要处理的描述符，需要检查DD状态位 */</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_buffer</span> *<span class="title">buffer_info</span>;</span>	<span class="comment">/* 缓冲区信息结构数组 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*单个接收描述符的布局。 控制器假定这个结构被打包成16个字节，对大多数编译器来说这是一个安全的假设。 </span></span><br><span class="line"><span class="comment">但是，一些编译器可能会在字段之间插入填充，在这种情况下，必须以某种特定于编译器的方式打包结构。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ixgb_rx_desc</span> &#123;</span></span><br><span class="line">	__le64 buff_addr;</span><br><span class="line">	__le16 length;</span><br><span class="line">	__le16 reserved;</span><br><span class="line">	u8 status;</span><br><span class="line">	u8 errors;</span><br><span class="line">	__le16 special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_setup_rx_resources</span><span class="params">(struct ixgb_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_desc_ring</span> *<span class="title">rxdr</span> =</span> &amp;adapter-&gt;rx_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> =</span> adapter-&gt;pdev;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">/*一次缓存的buffer个数*/</span></span><br><span class="line">	size = <span class="keyword">sizeof</span>(struct ixgb_buffer) * rxdr-&gt;count;</span><br><span class="line">  	<span class="comment">/*vzalloc 虚拟连续，物理可以不连续*/</span></span><br><span class="line">	rxdr-&gt;buffer_info = vzalloc(size);</span><br><span class="line">	<span class="keyword">if</span> (!rxdr-&gt;buffer_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/*ixgb_rx_desc 描述符分配，4K对齐*/</span></span><br><span class="line">	rxdr-&gt;size = rxdr-&gt;count * <span class="keyword">sizeof</span>(struct ixgb_rx_desc);</span><br><span class="line">	rxdr-&gt;size = ALIGN(rxdr-&gt;size, <span class="number">4096</span>);</span><br><span class="line">  	<span class="comment">/*desc为分配的虚拟地址，rxdr-&gt;size为大小，而rxdr-&gt;dma为其物理地址！*/</span></span><br><span class="line">	rxdr-&gt;desc = dma_alloc_coherent(&amp;pdev-&gt;dev, rxdr-&gt;size, &amp;rxdr-&gt;dma,</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rxdr-&gt;desc) &#123;</span><br><span class="line">		vfree(rxdr-&gt;buffer_info);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="built_in">memset</span>(rxdr-&gt;desc, <span class="number">0</span>, rxdr-&gt;size);</span><br><span class="line">	rxdr-&gt;next_to_clean = <span class="number">0</span>;</span><br><span class="line">	rxdr-&gt;next_to_use = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成之后的内存如下：</p><p><img src="/images/NAPI-%E9%9D%9ENAPI%E6%94%B6%E5%8C%85%E5%88%86%E6%9E%90/ixgb_desc_ring.png" alt="ixgb_desc_ring"></p><p>在<code>ixgb_alloc_rx_buffers</code>中完成skb到DMA的流式映射。</p><p><code>ixgb_setup_tx_resources</code>与<code>ixgb_setup_tx_resources</code>类似。</p><h3 id="ixgb-up"><a href="#ixgb-up" class="headerlink" title="ixgb_up"></a>ixgb_up</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_up</span><span class="params">(struct ixgb_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> adapter-&gt;netdev;</span><br><span class="line">	<span class="keyword">int</span> err, irq_flags = IRQF_SHARED;</span><br><span class="line">  	<span class="comment">/*驱动层最大MTU为 netdev-&gt;mut(一般为1500) + 14(二层头)+ 4 (vlan)*/</span></span><br><span class="line">	<span class="keyword">int</span> max_frame = netdev-&gt;mtu + ENET_HEADER_SIZE + ENET_FCS_LENGTH;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_hw</span> *<span class="title">hw</span> =</span> &amp;adapter-&gt;hw;</span><br><span class="line">  	……</span><br><span class="line">  	<span class="comment">/*分配中断号，flags为SHARED*/</span></span><br><span class="line">	err = request_irq(adapter-&gt;pdev-&gt;irq, ixgb_intr, irq_flags,</span><br><span class="line">	                  netdev-&gt;name, netdev);</span><br><span class="line">  	……</span><br><span class="line">    <span class="comment">/*开启设备；</span></span><br><span class="line"><span class="comment">    使能NAPI；</span></span><br><span class="line"><span class="comment">    使能中断*/</span></span><br><span class="line">	clear_bit(__IXGB_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line">	napi_enable(&amp;adapter-&gt;napi);</span><br><span class="line">	ixgb_irq_enable(adapter);</span><br><span class="line">	netif_wake_queue(netdev);</span><br><span class="line">	mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ixgb-intr"><a href="#ixgb-intr" class="headerlink" title="ixgb_intr"></a>ixgb_intr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_intr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_adapter</span> *<span class="title">adapter</span> =</span> netdev_priv(netdev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_hw</span> *<span class="title">hw</span> =</span> &amp;adapter-&gt;hw;</span><br><span class="line">	u32 icr = IXGB_READ_REG(hw, ICR);</span><br><span class="line">	……</span><br><span class="line">    <span class="comment">/*判断NAPI是否使能*/</span></span><br><span class="line">	<span class="keyword">if</span> (napi_schedule_prep(&amp;adapter-&gt;napi)) &#123;</span><br><span class="line">		<span class="comment">/*禁中断并处理NAPI*/</span></span><br><span class="line">		IXGB_WRITE_REG(&amp;adapter-&gt;hw, IMC, ~<span class="number">0</span>);</span><br><span class="line">		__napi_schedule(&amp;adapter-&gt;napi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="napi-schedule"><a href="#napi-schedule" class="headerlink" title="__napi_schedule"></a>__napi_schedule</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __napi_schedule(struct napi_struct *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	____napi_schedule(&amp;__get_cpu_var(softnet_data), n);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> ____napi_schedule(struct softnet_data *sd,</span><br><span class="line">				     struct napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*设备的poll_list加入到CPU的链表中并触发软中断*/</span></span><br><span class="line">	list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">	__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="net-rx-action"><a href="#net-rx-action" class="headerlink" title="net_rx_action"></a>net_rx_action</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;__get_cpu_var(softnet_data);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> time_limit = jiffies + <span class="number">2</span>;</span><br><span class="line">  	<span class="comment">/*netdev_budget 默认值为 300*/</span></span><br><span class="line">	<span class="keyword">int</span> budget = netdev_budget;</span><br><span class="line">	<span class="keyword">void</span> *have;</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line">		<span class="keyword">int</span> work, weight;</span><br><span class="line">		<span class="comment">/* 窗口耗尽 或 时间过长则重新触发软中断 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> || time_after_eq(jiffies, time_limit)))</span><br><span class="line">			<span class="keyword">goto</span> softnet_break;</span><br><span class="line"></span><br><span class="line">		local_irq_enable();</span><br><span class="line">		<span class="comment">/*中断启用，此访问依然安全，</span></span><br><span class="line"><span class="comment">		  因为中断只能新条目加入此列表尾部，且只有在 -&gt;poll中才能删除条目</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">      	<span class="comment">/*获取第一个poll_list*/</span></span><br><span class="line">		n = list_first_entry(&amp;sd-&gt;poll_list, struct napi_struct, poll_list);</span><br><span class="line">		have = netpoll_poll_lock(n);</span><br><span class="line">		weight = n-&gt;weight;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* NAPI_STATE_SCHED测试是为了避免与netpoll的poll_napi()竞争。*/</span></span><br><span class="line">		work = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">          	<span class="comment">/*调用处理函数，继续以ixgb为例分析*/</span></span><br><span class="line">			work = n-&gt;poll(n, weight);</span><br><span class="line">			trace_napi_poll(n);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		WARN_ON_ONCE(work &gt; weight);</span><br><span class="line">		budget -= work;</span><br><span class="line">		local_irq_disable();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*已处理的与预期相符则表示包太多；</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(work == weight)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(napi_disable_pending(n))) &#123;</span><br><span class="line">				local_irq_enable();</span><br><span class="line">				napi_complete(n);</span><br><span class="line">				local_irq_disable();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">/*有gro则开始flush gro的包*/</span></span><br><span class="line">				<span class="keyword">if</span> (n-&gt;gro_list) &#123;</span><br><span class="line">					<span class="comment">/*If HZ &lt; 1000, flush all packets.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					local_irq_enable();</span><br><span class="line">					napi_gro_flush(n, HZ &gt;= <span class="number">1000</span>);</span><br><span class="line">					local_irq_disable();</span><br><span class="line">				&#125;</span><br><span class="line">				list_move_tail(&amp;n-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		netpoll_poll_unlock(have);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	net_rps_action_and_irq_enable(sd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_DMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There may not be any more sk_buffs coming right now, so push</span></span><br><span class="line"><span class="comment">	 * any pending DMA copies to hardware</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dma_issue_pending_all();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">softnet_break:</span><br><span class="line">	sd-&gt;time_squeeze++;</span><br><span class="line">	__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ixgb-clean"><a href="#ixgb-clean" class="headerlink" title="ixgb_clean"></a>ixgb_clean</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_clean</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_adapter</span> *<span class="title">adapter</span> =</span> container_of(napi, struct ixgb_adapter, napi);</span><br><span class="line">	<span class="keyword">int</span> work_done = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*传输完成后回收资源*/</span></span><br><span class="line">	ixgb_clean_tx_irq(adapter);</span><br><span class="line">  	<span class="comment">/*向网络堆栈发送收到的数据*/</span></span><br><span class="line">	ixgb_clean_rx_irq(adapter, &amp;work_done, budget);</span><br><span class="line">	<span class="comment">/* 说明包已经处理完，则退出napi模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line">		napi_complete(napi);</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(__IXGB_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">          	<span class="comment">/*开启中断，驱动继续收包*/</span></span><br><span class="line">			ixgb_irq_enable(adapter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ixgb-clean-rx-irq"><a href="#ixgb-clean-rx-irq" class="headerlink" title="ixgb_clean_rx_irq"></a>ixgb_clean_rx_irq</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">ixgb_clean_rx_irq</span><span class="params">(struct ixgb_adapter *adapter, <span class="keyword">int</span> *work_done, <span class="keyword">int</span> work_to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_desc_ring</span> *<span class="title">rx_ring</span> =</span> &amp;adapter-&gt;rx_ring;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> =</span> adapter-&gt;netdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> =</span> adapter-&gt;pdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_rx_desc</span> *<span class="title">rx_desc</span>, *<span class="title">next_rxd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ixgb_buffer</span> *<span class="title">buffer_info</span>, *<span class="title">next_buffer</span>, *<span class="title">next2_buffer</span>;</span></span><br><span class="line">	u32 length;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">int</span> cleaned_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> cleaned = <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">/*从上次处理的点开始处理，默认为0*/</span></span><br><span class="line">	i = rx_ring-&gt;next_to_clean;</span><br><span class="line">	rx_desc = IXGB_RX_DESC(*rx_ring, i);</span><br><span class="line">	buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line">	<span class="comment">/*描述符状态为IXGB_RX_DESC_STATUS_DD时处理，此状态含义还不清楚*/</span></span><br><span class="line">	<span class="keyword">while</span> (rx_desc-&gt;status &amp; IXGB_RX_DESC_STATUS_DD) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">		u8 status;</span><br><span class="line">		<span class="comment">/*已处理的包大于指定处理的包则break*/</span></span><br><span class="line">		<span class="keyword">if</span> (*work_done &gt;= work_to_do)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		(*work_done)++;</span><br><span class="line">		rmb();	<span class="comment">/* read descriptor and rx_buffer_info after status DD */</span></span><br><span class="line">      	<span class="comment">/*status、skb取到临时变量*/</span></span><br><span class="line">		status = rx_desc-&gt;status;</span><br><span class="line">		skb = buffer_info-&gt;skb;</span><br><span class="line">		buffer_info-&gt;skb = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">/*prefetch预热内存，下次读取时比较容易命中*/</span></span><br><span class="line">		prefetch(skb-&gt;data - NET_IP_ALIGN);</span><br><span class="line">		<span class="comment">/*下次要处理的包到ring的尾则reset*/</span></span><br><span class="line">		<span class="keyword">if</span> (++i == rx_ring-&gt;count)</span><br><span class="line">			i = <span class="number">0</span>;</span><br><span class="line">		next_rxd = IXGB_RX_DESC(*rx_ring, i);</span><br><span class="line">		prefetch(next_rxd);</span><br><span class="line">		<span class="comment">/*多预热一次？*/</span></span><br><span class="line">		j = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (j == rx_ring-&gt;count)</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		next2_buffer = &amp;rx_ring-&gt;buffer_info[j];</span><br><span class="line">		prefetch(next2_buffer);</span><br><span class="line"></span><br><span class="line">		next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">		cleaned = <span class="literal">true</span>;</span><br><span class="line">		cleaned_count++;</span><br><span class="line">		<span class="comment">/*skb已取出，则unmap DMA*/</span></span><br><span class="line">		dma_unmap_single(&amp;pdev-&gt;dev,</span><br><span class="line">				 buffer_info-&gt;dma,</span><br><span class="line">				 buffer_info-&gt;length,</span><br><span class="line">				 DMA_FROM_DEVICE);</span><br><span class="line">		buffer_info-&gt;dma = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		length = le16_to_cpu(rx_desc-&gt;length);</span><br><span class="line">		rx_desc-&gt;length = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*skb消耗了多个缓冲区*/</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!(status &amp; IXGB_RX_DESC_STATUS_EOP))) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;Receive packet consumed multiple buffers length&lt;%x&gt;\n&quot;</span>,</span><br><span class="line">				 length);</span><br><span class="line">			dev_kfree_skb_irq(skb);</span><br><span class="line">			<span class="keyword">goto</span> rxdesc_done;</span><br><span class="line">		&#125;</span><br><span class="line">		……</span><br><span class="line">        <span class="comment">/*函数作用不太理解--组包？TBD*/</span></span><br><span class="line">		ixgb_check_copybreak(netdev, buffer_info, length, &amp;skb);</span><br><span class="line">		<span class="comment">/* Good Receive */</span></span><br><span class="line">		skb_put(skb, length);</span><br><span class="line">		<span class="comment">/* Receive Checksum Offload */</span></span><br><span class="line">		ixgb_rx_checksum(adapter, rx_desc, skb);</span><br><span class="line">		<span class="comment">/*更新协议、vlan然后上送协议栈*/</span></span><br><span class="line">		skb-&gt;protocol = eth_type_trans(skb, netdev);</span><br><span class="line">		<span class="keyword">if</span> (status &amp; IXGB_RX_DESC_STATUS_VP)</span><br><span class="line">			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),</span><br><span class="line">				       le16_to_cpu(rx_desc-&gt;special));</span><br><span class="line"></span><br><span class="line">		netif_receive_skb(skb);</span><br><span class="line">      	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>NAPI 是中断时利用__napi_schedule 将设备poll_list加到cpu的处理链表，之后唤醒下半部，下半部继续调用驱动层的处理函数poll，其中一次处理多个skb，而非传统的一个skb进行一次中断。达到了网络性能的提升。</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/NAPI/" rel="tag"># NAPI</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%9D%82%E8%B0%88/%E7%BD%91%E7%BB%9CRPS-RFS-GSO-GRO%E7%AD%89%E5%8A%9F%E8%83%BD%E9%87%8A%E4%B9%89.html" rel="prev" title="网络RPS/RFS/GSO/GRO等功能释义"><i class="fa fa-chevron-left"></i> 网络RPS/RFS/GSO/GRO等功能释义</a></div><div class="post-nav-item"> <a href="/Linux%E5%86%85%E6%A0%B8/Linux-Netpoll%E6%B5%85%E6%9E%90.html" rel="next" title="Linux Netpoll浅析">Linux Netpoll浅析<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "Linux内核/NAPI-非NAPI收包分析.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>