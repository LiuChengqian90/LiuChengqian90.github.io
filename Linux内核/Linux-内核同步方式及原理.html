<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="本文基于 linux kernel 3.10.105。 原子操作原子操作是其他同步方法的基石。原子操作，可以保证指令以原子的方式执行——执行过程不被打断。"><meta property="og:type" content="article"><meta property="og:title" content="Linux 内核同步方式及原理"><meta property="og:url" content="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html"><meta property="og:site_name" content="小刘的杂货铺"><meta property="og:description" content="本文基于 linux kernel 3.10.105。 原子操作原子操作是其他同步方法的基石。原子操作，可以保证指令以原子的方式执行——执行过程不被打断。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2017-12-04T10:32:14.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="锁"><meta property="article:tag" content="完成变量"><meta property="article:tag" content="信号量"><meta property="article:tag" content="互斥体"><meta property="article:tag" content="顺序锁"><meta property="article:tag" content="内核屏障"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>Linux 内核同步方式及原理 | 小刘的杂货铺</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="小刘的杂货铺" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">小刘的杂货铺</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">原子整数操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic-add"><span class="nav-number">1.1.1.</span> <span class="nav-text">atomic_add</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic-sub-and-test"><span class="nav-number">1.1.2.</span> <span class="nav-text">atomic_sub_and_test</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic-add-return"><span class="nav-number">1.1.3.</span> <span class="nav-text">atomic_add_return</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">原子位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set-bit"><span class="nav-number">1.2.1.</span> <span class="nav-text">set_bit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#test-and-set-bit"><span class="nav-number">1.2.2.</span> <span class="nav-text">test_and_set_bit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spin-lock-init"><span class="nav-number">2.1.1.</span> <span class="nav-text">spin_lock_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spin-lock"><span class="nav-number">2.1.2.</span> <span class="nav-text">spin_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spin-lock-bh"><span class="nav-number">2.1.3.</span> <span class="nav-text">spin_lock_bh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spin-lock-irq"><span class="nav-number">2.1.4.</span> <span class="nav-text">spin_lock_irq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spin-lock-irqsave"><span class="nav-number">2.1.5.</span> <span class="nav-text">spin_lock_irqsave</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="nav-number">2.2.</span> <span class="nav-text">自旋锁和下半部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">读写自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rwlock-init"><span class="nav-number">2.3.1.</span> <span class="nav-text">rwlock_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-lock"><span class="nav-number">2.3.2.</span> <span class="nav-text">read_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-lock"><span class="nav-number">2.3.3.</span> <span class="nav-text">write_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-lock-bh"><span class="nav-number">2.3.4.</span> <span class="nav-text">read_lock_bh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-lock-bh"><span class="nav-number">2.3.5.</span> <span class="nav-text">write_lock_bh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-lock-irq"><span class="nav-number">2.3.6.</span> <span class="nav-text">read_lock_irq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-lock-irq"><span class="nav-number">2.3.7.</span> <span class="nav-text">write_lock_irq</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sema-init"><span class="nav-number">3.1.</span> <span class="nav-text">sema_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#down"><span class="nav-number">3.2.</span> <span class="nav-text">down</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#up"><span class="nav-number">3.3.</span> <span class="nav-text">up</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.4.</span> <span class="nav-text">读写信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#init-rwsem"><span class="nav-number">3.4.1.</span> <span class="nav-text">init_rwsem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#down-read"><span class="nav-number">3.4.2.</span> <span class="nav-text">down_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#up-write"><span class="nav-number">3.4.3.</span> <span class="nav-text">up_write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#down-write"><span class="nav-number">3.4.4.</span> <span class="nav-text">down_write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#up-read"><span class="nav-number">3.4.5.</span> <span class="nav-text">up_read</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="nav-number">4.</span> <span class="nav-text">互斥体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex-init"><span class="nav-number">4.1.</span> <span class="nav-text">mutex_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex-lock"><span class="nav-number">4.2.</span> <span class="nav-text">mutex_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex-unlock"><span class="nav-number">4.3.</span> <span class="nav-text">mutex_unlock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E5%8F%98%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">完成变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#init-completion"><span class="nav-number">5.1.</span> <span class="nav-text">init_completion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-for-completion"><span class="nav-number">5.2.</span> <span class="nav-text">wait_for_completion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#complete"><span class="nav-number">5.3.</span> <span class="nav-text">complete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8%E9%94%81%EF%BC%88BKL%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">大内核锁（BKL）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">顺序锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-DEFINE-SEQLOCK"><span class="nav-number">7.1.</span> <span class="nav-text">初始化 DEFINE_SEQLOCK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-seqlock"><span class="nav-number">7.2.</span> <span class="nav-text">write_seqlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-sequnlock"><span class="nav-number">7.3.</span> <span class="nav-text">write_sequnlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-seqbegin"><span class="nav-number">7.4.</span> <span class="nav-text">read_seqbegin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-seqretry"><span class="nav-number">7.5.</span> <span class="nav-text">read_seqretry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E6%8A%A2%E5%8D%A0"><span class="nav-number">8.</span> <span class="nav-text">禁止抢占</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%B1%8F%E9%9A%9C"><span class="nav-number">9.</span> <span class="nav-text">顺序和屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">86</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">133</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小刘的杂货铺"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Linux 内核同步方式及原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-12-04 18:32:14" itemprop="dateCreated datePublished" datetime="2017-12-04T18:32:14+08:00">2017-12-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a></span></span><span id="/Linux%E5%86%85%E6%A0%B8/Linux-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86.html" class="post-meta-item leancloud_visitors" data-flag-title="Linux 内核同步方式及原理" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>49k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>44 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文基于 linux kernel 3.10.105。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是其他同步方法的基石。原子操作，可以保证指令以原子的方式执行——执行过程不被打断。</p><span id="more"></span><p>内核提供了两组原子操作接口——一组针对整数，一组针对单独的位。在Linux支持的所有体系结构上都实现了这两组接口。</p><h3 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h3><p>针对整数的原子操作只能对atomic_t类型的数据进行处理。引入特殊数据类型，主要是出于以下原因：</p><ul><li>让原子函数只接收atomic_t类型的操作数，可以确保原子操作只与这种特殊类型数据一起使用。同时，这也保证了该类型的数据不会被传递给任何非原子函数。</li><li>使用atomic_t类型确保编译器不对相应的值进行访问优化——这点使得原子操作最终接收到正确的内存地址，而不只是一个别名（关于这一点，之前atomic_t定义是 volatile int counter，利用volatile读写时从内存取值。而现在定义只是 int counter，是在外部进行操作时指定volatile）。</li></ul><p>最后，在不同体系结构上实现原子操作的时候，使用atomic_t可以屏蔽其间的差异。atomic_t类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tips：</span><br><span class="line">由于历史原因，Linux支持的所有机器上atomic_t只能使用该类型数据的高24位，这个限制是因为SPARC体系结构上，Sparc32缺少“比较和交换”类型的指令，因此它使用低8位作为自旋锁以保证SMP安全。不过现在，32位的Sparc已经被转移到了“自旋锁散列表”的方案中，允许完整的32位计数器被实现。</span><br><span class="line">本质上，自旋锁阵列基于被操作的atomic_t的地址被索引，并且该锁保护原子操作。 Parisc使用相同的方案。</span><br></pre></td></tr></table></figure><p>使用原子整形操作需要的声明都在&lt;asm/atomic.h&gt;中。</p><p>原子整数操作最常见的用途就是实现计数器。原子操作通常是内联函数，往往是通过内联汇编指令来实现。如果某个函数本来就是原子的，那么它往往被定义成一个宏。 例如，在大部分体系结构上，读取一个字本身就是一种原子操作，也就是说，在对有个字进行写入操作期间不可能完成对该字的读取。所以，atomic_read()只需返回atomic_t类型的整数值就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tips：</span><br><span class="line">32/64位CPU是指CPU一次能够处理32/64位数据或指令。</span><br><span class="line">字 ：CPU进行数据处理时，一次存取、加工和传送的数据长度称为字（word）。一个字通常由一个或多个（一般是字节的整数位）字节构成。</span><br><span class="line">字长：一个字的长度。CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * atomic_read - read atomic variable</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically reads the value of @v.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">atomic_read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (*(<span class="keyword">volatile</span> <span class="keyword">int</span> *)&amp;(v)-&gt;counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析几个函数的实现（x86架构）：</p><h4 id="atomic-add"><a href="#atomic-add" class="headerlink" title="atomic_add"></a>atomic_add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX_HERE \</span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;.section .smp_locks,\&quot;a\&quot;\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;.balign 4\n&quot;</span>			\</span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;.long 671f - .\n&quot;</span> <span class="comment">/* offset */</span>	\</span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;.previous\n&quot;</span>			\</span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;671:&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX LOCK_PREFIX_HERE <span class="meta-string">&quot;\n\tlock; &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;addl %1,%0&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;ir&quot;</span> (i))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>可翻译为 ： </span><br><span class="line"></span><br><span class="line">.section .smp_locks,<span class="string">&quot;a&quot;</span></span><br><span class="line">.balign <span class="number">4</span></span><br><span class="line">.<span class="keyword">long</span> <span class="number">671f</span> - .</span><br><span class="line">.previous</span><br><span class="line"><span class="number">671</span>:</span><br><span class="line">	lock;</span><br><span class="line">	addl %<span class="number">1</span>,%<span class="number">0</span> : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) : <span class="string">&quot;ir&quot;</span> (i)</span><br></pre></td></tr></table></figure><p>两步分析</p><ol><li><p>LOCK_PREFIX</p><p>参考 <a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs-2.29/as/index.html">GNU Assembler (GAS)手册</a> ，如果连接失效，可点击 <a target="_blank" rel="noopener" href="https://sourceware.org/binutils/">此处</a>，Documentation 部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.section name [, <span class="string">&quot;flags&quot;</span>[, @type[,flag_specific_arguments]]]</span><br><span class="line">使用.section指令将以下代码组装到名为name的节中。</span><br><span class="line">flag <span class="string">&quot;a&quot;</span> 表示 section is allocatable。</span><br><span class="line">此指令会替代当前的section（.text）。</span><br><span class="line"></span><br><span class="line">可以查看内核代码，以确定 smp_locks 的作用。简单来说是在单处理器中将锁变为空操作。</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.balign 4		将当前section的位数计数器加到4字节对齐。</span><br><span class="line">.long 671f - .	.long（等于.int）是一个指令，告诉汇编程序在这里汇编一个32位的数量。当遇到的数据看起来不像任何已知的指令时，反汇编器通常发出这些数据。通常情况下，当存在一个文字池时就是这样，因为那些不包含机器码和数据的反汇编程序会打印它们包含的数据。.long指令对于.bss节无效。</span><br><span class="line">.previous		指令继续处理上一节。</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock指令：多处理器环境中，<span class="string">&quot;LOCK#&quot;</span>信号确保了处理器在信号有效时独占使用任何共享存储器。在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上下面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 <span class="string">&quot;LOCK#&quot;</span>信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</span><br><span class="line"></span><br><span class="line">LOCK前缀只能作为以下指令的前缀：</span><br><span class="line">ADD，ADC，AND，BTC，BTR，BTS，CMPXCHG，CMPXCH8B，CMPXCHG16B，DEC，INC，NEG，NOT，OR，SBB，SUB，XOR，XADD和XCHG。</span><br><span class="line"></span><br><span class="line">如果LOCK前缀与其中一个一起使用这些指令和源操作数是内存操作数，未定义的操作码异常（<span class="string">&quot;#UD&quot;</span>）可能产生。如果LOCK前缀不与任何指令一起使用，也会产生未定义的操作码异常。</span><br><span class="line"></span><br><span class="line">注意：XCHG 和 XADD (以及所有以 &#x27;X&#x27; 开头的指令)都能够保证在多处理器系统下的原子操作，它们总会宣告一个 <span class="string">&quot;LOCK#&quot;</span> 信号，而不管有没有 LOCK 前缀。</span><br></pre></td></tr></table></figure><p>在X86平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU上有一根引线#HLOCK pin连到北桥，如果汇编语言的程序中在一条指令前面加上前缀“LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p></li><li><p>addl指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addl %<span class="number">1</span>,%<span class="number">0</span> : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) : <span class="string">&quot;ir&quot;</span> (i)</span><br></pre></td></tr></table></figure><p>addl指令含义为 将目的操作数和源操作数求和，并将值写到目的操作数。</p><p><strong>DOS/Windows 下的汇编语言，是 Intel 风格的。但在 Unix 和 Linux 系统中，更多采用的还是 AT&amp;T 格式。</strong></p><p><strong>AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边。</strong></p><p>GCC中asm格式为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">asm [volatile] ( AssemblerTemplate </span><br><span class="line">                 : OutputOperands </span><br><span class="line">                 [ : InputOperands</span><br><span class="line">                 [ : Clobbers ] ])</span><br><span class="line"></span><br><span class="line">asm [volatile] goto ( AssemblerTemplate </span><br><span class="line">                      : </span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br><span class="line"></span><br><span class="line">OutputOperands（输出约束）必须以“=”（覆盖现有值的变量）或“+”（读写时）开始。</span><br><span class="line">在前缀之后，必须有一个或多个附加约束来描述值所在的位置。常见的约束条件包括“r”表示寄存器，“m”表示内存。当列出多个可能的位置（例如，“= rm”）时，编译器将根据当前上下文选择最有效的位置。</span><br><span class="line"></span><br><span class="line">InputOperands（输入约束）不能以&#x27;=&#x27;或&#x27;+&#x27;开头。当列出多个可能位置（例如，“irm”）时，编译器将根据当前上下文选择最有效的位置。</span><br></pre></td></tr></table></figure><p>%0、%1可以简单的理解为将 OutputOperands和InputOperands按顺序排列。<br>“+m” 表示由内存中读取或直接写入内存。<br>“i” 立即整型操作数。<br>“r” 表示数据可以从寄存器读取或写入到寄存器。</p><p>因此，代码中的语句就比较好理解了。</p></li></ol><p>atomic_sub 与 atomic_add 类似。</p><h4 id="atomic-sub-and-test"><a href="#atomic-sub-and-test" class="headerlink" title="atomic_sub_and_test"></a>atomic_sub_and_test</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">atomic_sub_and_test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %2,%0; sete %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter), <span class="string">&quot;=qm&quot;</span> (c)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subl i, v-&gt;counter; sete c</span><br><span class="line">v-&gt;counter -= i; 结果为<span class="number">0</span>则设置c。</span><br><span class="line"><span class="string">&#x27;q&#x27;</span>的约束和<span class="string">&#x27;r&#x27;</span>相同。<span class="string">&#x27;memory&#x27;</span> clobber 告诉编译器，汇编代码对输入和输出操作数（例如，访问输入参数之一指向的内存）以外的项目执行内存读取或写入操作。</span><br></pre></td></tr></table></figure><h4 id="atomic-add-return"><a href="#atomic-add-return" class="headerlink" title="atomic_add_return"></a>atomic_add_return</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">atomic_add_return</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_M386</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(boot_cpu_data.x86 &lt;= <span class="number">3</span>))</span><br><span class="line">		<span class="keyword">goto</span> no_xadd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Modern 486+ processor */</span></span><br><span class="line">	__i = i;</span><br><span class="line">  <span class="comment">/* xaddl i, v-&gt;counter</span></span><br><span class="line"><span class="comment">     i 与 v-&gt;counter 进行交换，之后 v-&gt;counter += i</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;xaddl %0, %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;+r&quot;</span> (i), <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> i + __i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_M386</span></span><br><span class="line">no_xadd: <span class="comment">/* Legacy 386 processor */</span></span><br><span class="line">  	<span class="comment">/*无 xaddl指令 则利用中断实现</span></span><br><span class="line"><span class="comment">  	  中断函数实现之后在分析  todo</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	raw_local_irq_save(flags);</span><br><span class="line">	__i = atomic_read(v);</span><br><span class="line">	atomic_set(v, i + __i);</span><br><span class="line">	raw_local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> i + __i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h3><p>内核也提供了一组针对位这一级数据进行操作的函数，定义在&lt;asm/bitops.h&gt;中。位操作函数是对普通的内存地址进行操作的，参数是一个指针和一个位号，第0位是给定地址的最低有效位。</p><h4 id="set-bit"><a href="#set-bit" class="headerlink" title="set_bit"></a>set_bit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &lt; 1)</span></span><br><span class="line"><span class="comment">/* Technically wrong, but this avoids compilation errors on some gcc</span></span><br><span class="line"><span class="comment">   versions. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITOP_ADDR(x) <span class="meta-string">&quot;=m&quot;</span> (*(volatile long *) (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITOP_ADDR(x) <span class="meta-string">&quot;+m&quot;</span> (*(volatile long *) (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_IMMEDIATE(nr)		(__builtin_constant_p(nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONST_MASK_ADDR(nr, addr)	BITOP_ADDR((void *)(addr) + ((nr)&gt;&gt;3))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONST_MASK(nr)			(1 &lt;&lt; ((nr) &amp; 7))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">set_bit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (IS_IMMEDIATE(nr)) &#123;</span><br><span class="line">		<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;orb %1,%0&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">			: CONST_MASK_ADDR(nr, addr)</span></span></span><br><span class="line"><span class="params"><span class="function">			: <span class="string">&quot;iq&quot;</span> ((u8)CONST_MASK(nr))</span></span></span><br><span class="line"><span class="params"><span class="function">			: <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="keyword">volatile</span>(LOCK_PREFIX <span class="string">&quot;bts %1,%0&quot;</span></span><br><span class="line">			: BITOP_ADDR(addr) : <span class="string">&quot;Ir&quot;</span> (nr) : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>GCC内置函数__builtin_constant_p用来检测值是否为常量。</li><li>BITOP_ADDR 是将传入的指针进行截取，只保留需要操作的字节。</li><li>CONST_MASK_ADDR 可理解为将 addr 以字节进行划分，根据 nr 找到需要操作的字节。</li><li>CONST_MASK 字节偏移量。</li><li>‘orb’ 是 “位或”操作。’orb src, dest’，dest的第src位进行位或操作。</li><li>‘bts’ 是 ‘bit test and set’，’bts src, dest’，将所选位（dest 的 src位）的值写入CF寄存器，然后将所选位 置1。</li><li>约束符’I’表示值1到8的范围。可参考<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">此处</a>。</li></ol><p><strong>clear_bit 与 set_bit 类似，不过将’orb’ 变为 ‘andb’(位与)，将’bts’ 变为 ‘btr’(bit test and reset)。</strong></p><p><strong>change_bit 使用了 ‘xorb’(位异或)和’btc’(bit test and complement，select bit &lt;- not (select bit))。</strong></p><h4 id="test-and-set-bit"><a href="#test-and-set-bit" class="headerlink" title="test_and_set_bit"></a>test_and_set_bit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> oldbit;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;bts %2,%1\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;sbb %0,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (oldbit), ADDR : <span class="string">&quot;Ir&quot;</span> (nr) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> oldbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>‘bts’ 第一步就是将所选位的值写入 CF 寄存器。</li><li>‘sbb’ 含义为 （DEST ← (DEST – (SRC + CF));），源目相同时，仅是将CF寄存器的值写入目的操作数。</li></ol><p>其他原子位操作原理基本与这两种函数类似。</p><p>为方便起见内核还提供了一组与原子位操作对应的非原子位操作（无 ‘LOCK_PREFIX’ 锁操作）。非原子位操作函数名比原子位操作函数名前缀多两个下划线。如果已确定操作不需要原子性（已经用锁保护了自己的数据），那么这些非原子的操作可能会执行得更快些。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>Linux内核中最常见的锁是自旋锁（spin lock）。自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被己经持有(即所谓的争用)的自旋锁，那么该线程就会一直进行忙循环——旋转——等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。同一个锁可以用在多个位置。</p><p>一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋(特别浪费处理器时间)，这种行为是自旋锁的要点。所以自旋锁不应该被长时间持有。事实上，这点正是使用自旋锁的初衷：在短期间内进行轻量级加锁。还可以采取另外的方式来处理对锁的争用:让请求线程睡眠，直到锁重新可用时再唤醒它。这样处理器就不必循环等待，可以去执行其他代码。这也会带来一定的开销—这里有两次明显的上下文切换，被阻塞的线程要换出和换入，与实现自旋锁的少数几行代码相比，上下文切换当然有较多的代码。因此，持有自旋锁的时间最好小于完成两次上下文切换的耗时。当然我们大多数人都不会无聊到去测量上下文切换的耗时，所以我们让持有自旋锁的时间应尽可能的短就可以。</p><p>自旋锁的实现和体系结构密切相关，代码往往通过汇编实现。与体系结构相关的代码定义在文件&lt;asm/spinlock.h&gt;中，实际需要用到的接口定义在文件&lt;linux/spinlock.h&gt;中。</p><p>自旋锁在同一时刻只能被一个执行线程持有，因此一个时刻只能有一个线程位于临界区内，这就为多处理器机器提供了防止并发访问所需的保护机制。注意<strong>在单处理器机器上</strong>，编译的时候并不会加入自旋锁。它仅仅被当做一个设置内核抢占机制是否被启用的开关。如果禁止内核抢占，那么在编译时自旋锁会被完全剔除出内核。</p><p><strong>警告：自旋锁是不可递归的!</strong></p><p>内核实现的自旋锁是不可递归的，这点不同于自旋锁在其他操作系统中的实现。如果你试图得到一个你正持有的锁，你必须自旋，等待你自己释放这个锁。但你处于自旋忙等待中，所以你永远没有机会释放锁，于是你被自己锁死了。千万小心自旋锁!</p><p>自旋锁可以使用在中断处理程序中。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断(在当前处理器上的中断请求)，否则，中断处理程序就会打断正持有锁的内核代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者(在不同处理器上)最终释放锁。</p><p>调调试自旋锁 配置选项CONFIG_DEBUG_SPINLOCK为使用自旋锁的代码加入了许多调试检测手段。例如，激活了该选项，内核就会检查是否使用了未初始化的锁，是否在还没加锁的时候就要对锁执行开锁操作。在测试代码时，总是应该激活这个选项。如果需要进一步全程调试锁，还应该打开CONFIG_DEBUG_LOCK_ALLOC选项。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="spin-lock-init"><a href="#spin-lock-init" class="headerlink" title="spin_lock_init"></a>spin_lock_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock.h</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过返回rlock地址来检查传参是否是 spinlock_t *类型</span></span><br><span class="line"><span class="comment">如果不是的话，会有错误或告警</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">raw_spinlock_t</span> *<span class="title">spinlock_check</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;lock-&gt;rlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_lock_init(_lock)				\</span></span><br><span class="line"><span class="meta">do &#123;							\</span></span><br><span class="line"><span class="meta">	spinlock_check(_lock);				\</span></span><br><span class="line"><span class="meta">	raw_spin_lock_init(&amp;(_lock)-&gt;rlock);		\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock.h</span><br><span class="line"><span class="comment">/*开启自旋锁调试开关  todo*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">void</span> __raw_spin_lock_init(<span class="keyword">raw_spinlock_t</span> *lock, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">				   struct lock_class_key *key);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> raw_spin_lock_init(lock)				\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;			\</span></span><br><span class="line"><span class="meta">	__raw_spin_lock_init((lock), #lock, &amp;__key);		\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">// disable DEBUG</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> raw_spin_lock_init(lock)				\</span></span><br><span class="line"><span class="meta">	do &#123; *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock_types.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RAW_SPIN_LOCK_INITIALIZER(lockname)	\</span></span><br><span class="line"><span class="meta">	&#123;					\</span></span><br><span class="line"><span class="meta">	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\</span></span><br><span class="line"><span class="meta">	<span class="comment">/*todo*/</span></span></span><br><span class="line">	SPIN_DEBUG_INIT(lockname)		\</span><br><span class="line">	SPIN_DEP_MAP_INIT(lockname) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RAW_SPIN_LOCK_UNLOCKED(lockname)	\</span></span><br><span class="line"><span class="meta">	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*分析x86架构*/</span></span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock_types.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arch_spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> slock;</span><br><span class="line">&#125; <span class="keyword">arch_spinlock_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED	&#123; 0 &#125;</span></span><br></pre></td></tr></table></figure><p>x86架构，初始化自旋锁，就是对最内层的lock置0。</p><h4 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a>spin_lock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">include/linux/spinlock.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock)	_raw_spin_lock(lock)</span></span><br></pre></td></tr></table></figure><ul><li><p>单处理器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单处理器 UP</span></span><br><span class="line">include/linux/spinlock_api_up.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock(lock)			__LOCK(lock)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock_api_up.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_disable(); __acquire(lock); (void)(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当前线程preempt_count加1</span></span><br><span class="line"><span class="comment">barrier()为内存屏障，以保证数据 顺序性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_disable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">	inc_preempt_count(); \</span></span><br><span class="line"><span class="meta">	barrier(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sparse 的 GCC 扩展，利用 __context__ 来对代码进行检查，参数x 的引用计数 +1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">include/linux/compiler.h</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquire(x)	__context__(x,1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __release(x)	__context__(x,-1)</span></span><br></pre></td></tr></table></figure><p>单处理器时，并没有发生真正的锁定，所以内核唯一要做的就是<strong>保持抢占计数</strong>和irq标志，来抑制未使用的锁变量的编译器警告，并添加适当的检查器注释。</p></li><li><p>多处理器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多处理器 SMP</span></span><br><span class="line">kernel/spinlock.c</span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_lock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock_api_smp.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*禁止内核抢占，本CPU生效*/</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">  	<span class="comment">/*未定义锁调试时，函数为空。todo*/</span></span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);  	</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供锁的统计信息 todo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCK_STAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock)			\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (!try(_lock)) &#123;					\</span></span><br><span class="line"><span class="meta">		lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_);	\</span></span><br><span class="line"><span class="meta">		lock(_lock);					\</span></span><br><span class="line"><span class="meta">	&#125;							\</span></span><br><span class="line"><span class="meta">	lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_LOCK_STAT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock, try, lock) \</span></span><br><span class="line"><span class="meta">	lock(_lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_LOCK_STAT */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置了CONFIG_DEBUG_SPINLOCK, 引用文件 include/linux/spinlock.h 中的函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span> __<span class="title">acquires</span><span class="params">(lock)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不明白函数定义后加一个宏是什么意思？</span></span><br><span class="line"><span class="comment">todo</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span> __<span class="title">acquires</span><span class="params">(lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__acquire(lock);</span><br><span class="line">	arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock.h	<span class="comment">//选择x86架构分析</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">arch_spin_lock</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__ticket_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock.h</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CPU数量</span></span><br><span class="line"><span class="comment">32位环境中默认是 32</span></span><br><span class="line"><span class="comment">64位环境中默认是 5120</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NR_CPUS &lt; 256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICKET_SHIFT 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICKET_SHIFT 16</span></span><br></pre></td></tr></table></figure><ul><li><p>32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __ticket_spin_lock(<span class="keyword">arch_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">short</span> inc = <span class="number">0x0100</span>;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		LOCK_PREFIX <span class="string">&quot;xaddw %w0, %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;1:\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;cmpb %h0, %b0\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;je 2f\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;rep ; nop\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;movb %1, %b0\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="comment">/* don&#x27;t need lfence here, because loads are in-order */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;jmp 1b\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">&quot;2:&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		: <span class="string">&quot;+Q&quot;</span> (inc), <span class="string">&quot;+m&quot;</span> (lock-&gt;slock)</span></span></span><br><span class="line"><span class="params"><span class="function">		:</span></span></span><br><span class="line"><span class="params"><span class="function">		: <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>“xaddw %w0, %1\n”</p><p>‘xaddw ‘指令含义为 交换后求和，’xaddw SRC , DEST’—&gt;&gt;&gt; (TEMP ← SRC + DEST;SRC ← DEST;DEST ← TEMP;)，’%w0’ 在 GCC 编译器中表示 ax 寄存器，’%h0’ 代表 ax的高8位，即ah； ‘%b0’ 代表 ax的低8位，即al。</p><p>此时， ax寄存器中的值为 inc的值，即 0x0100。</p><p>那么，此句含义即为： xaddw %ax, lock-&gt;slock。操作之后，tmp = lock-&gt;slock + inc; inc = lock-&gt;slock;lock-&gt;slock = tmp;</p><p>锁初始化时，值为0。经过操作之后，lock-&gt;slock = 0x0100，%ax = 0。</p></li><li><p>‘1:’</p><p>定义一个标号。</p></li><li><p>“cmpb %h0, %b0\n\t”</p><p>‘cmpb’ 位比较。’cmpb %ah, %al’，由于 %ax为0，源目操作数相同。</p></li><li><p>“je 2f\n\t”</p><p>如果上一步比较结果为真（相同），则跳转到标号为’2’的地方，本段中’2’表示退出。</p></li><li><p>“rep ; nop\n\t”</p><p>此条指令与’pause’指令相同，用于不支持’pause’指令的汇编程序。在不支持超线程的处理器上，就像’nop’一样不做任何事，但在支持超线程的处理器上，它被用作向处理器提示正在执行spinloop以提高性能。</p></li><li><p>“movb %1, %b0\n\t”</p><p>‘movb SRC, DEST’—&gt;&gt;&gt; (DEST ← SRC)，此处为 %al ← lock-&gt;slock。</p></li><li><p>“jmp 1b\n”</p><p>跳到标志’1’。</p></li><li><p>“2:”</p><p>定义一个标号。</p></li></ol><p>此段含义简单概括为，将锁的值赋给 ax ，然后比较 ax 的高8位和低8位，相同则跳出（锁已经有了新值，其高位已加1，但是低位没变），不同则代表锁已经执行过加锁这一步，那么进入循环，循环中是将 内存中锁的值赋给 al，然后继续比较。为什么仅赋值低8位呢 ？因为 unlock 是 低位加1。</p><p>因此，可理解为，lock 高位加1，就是加锁，低位加1就是解锁。解锁之后不在分析。</p></li></ul></li></ul><ul><li><p>64位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __ticket_spin_lock(<span class="keyword">arch_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> inc = <span class="number">0x00010000</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;xaddl %0, %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;movzwl %w0, %2\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;shrl $16, %0\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;1:\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;cmpl %0, %2\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;je 2f\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;rep ; nop\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;movzwl %1, %2\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="comment">/* don&#x27;t need lfence here, because loads are in-order */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;jmp 1b\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;2:&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;+r&quot;</span> (inc), <span class="string">&quot;+m&quot;</span> (lock-&gt;slock), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span></span></span><br><span class="line"><span class="params"><span class="function">		     :</span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位与32位原理一样，不过<strong>32位是 高8位 和 低8位进行比较，而64位是 高16位 与 低16位 进行比较</strong>。下面仅仅说明几个指令的含义：</p><ol><li><p>“movzwl %w0, %2\n\t”</p><p>将 %w0 即 eax (64位) 的值赋值到 tmp，但是高16位用0填充，即 低16位赋给 tmp。</p></li><li><p> “shrl $16, %0\n\t”</p></li></ol><p> %0 逻辑右移 16位，即 %0 仅存 高16位。</p><p>之后流程和32位相同。</p></li></ul><h4 id="spin-lock-bh"><a href="#spin-lock-bh" class="headerlink" title="spin_lock_bh"></a>spin_lock_bh</h4><p>之后的函数直接分析SMP系统（x86）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock_bh(lock)		_raw_spin_lock_bh(lock)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_lock_bh(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel/spinlock.c</span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock_bh(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_lock_bh(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/spinlock_api_smp.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock_bh(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_bh_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BH 和 非BH区别主要是增加了 函数 “local_bh_disable” ，看一下其定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel/softirq.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__local_bh_disable((<span class="keyword">unsigned</span> <span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __local_bh_disable(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line">	add_preempt_count(SOFTIRQ_OFFSET);</span><br><span class="line">	barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>“__builtin_return_address” 接收一个称为 <code>level</code> 的参数。这个参数定义希望获取返回地址的调用堆栈级别。例如，如果指定 <code>level</code> 为 <code>0</code>，那么就是请求当前函数的返回地址。如果指定 <code>level</code> 为 <code>1</code>，那么就是请求进行调用的函数的返回地址，依此类推。使用 <code>__builtin_return_address</code>捕捉返回地址，以便在以后进行跟踪时使用这个地址。</li><li>preempt_count 加 本地软中断偏移(SOFTIRQ_OFFSET)，之后可用 宏 ‘softirq_count()’ 进行判断是否已禁用软中断。</li></ol><h4 id="spin-lock-irq"><a href="#spin-lock-irq" class="headerlink" title="spin_lock_irq"></a>spin_lock_irq</h4><p>irq 锁是禁止了硬中断。过程代码不在赘述，直接到最后 多的 “raw_local_irq_disable()”函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/include/<span class="keyword">asm</span>/irqflags.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raw_local_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	native_irq_disable();</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x86架构直接调用 “CLI” 指令。大多数情况下，”CLI”会清除EFLAGS寄存器中的IF标志，并且不会影响其他标志。 清除IF标志会导致处理器<strong>忽略</strong>可屏蔽的外部中断。</p><h4 id="spin-lock-irqsave"><a href="#spin-lock-irqsave" class="headerlink" title="spin_lock_irqsave"></a>spin_lock_irqsave</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_lock_irqsave(lock, flags)				\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	raw_spin_lock_irqsave(spinlock_check(lock), flags);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock_irqsave(lock, flags)			\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		typecheck(unsigned long, flags);	\</span></span><br><span class="line"><span class="meta">		flags = _raw_spin_lock_irqsave(lock);	\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/typecheck.h</span><br><span class="line"><span class="comment">/*检查x是否为type类型*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typecheck(type,x) \</span></span><br><span class="line"><span class="meta">(&#123;	type __dummy; \</span></span><br><span class="line"><span class="meta">	typeof(x) __dummy2; \</span></span><br><span class="line"><span class="meta">	(void)(&amp;__dummy == &amp;__dummy2); \</span></span><br><span class="line"><span class="meta">	1; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kernel/spinlock.c</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __lockfunc _raw_spin_lock_irqsave(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __raw_spin_lock_irqsave(lock);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">include/linux/spinlock_api_smp.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __raw_spin_lock_irqsave(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On lockdep we dont want the hand-coded irq-enable of</span></span><br><span class="line"><span class="comment">	 * do_raw_spin_lock_flags() code, because lockdep assumes</span></span><br><span class="line"><span class="comment">	 * that interrupts are not re-enabled during lock-acquire:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	do_raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅分析 宏’local_irq_save()’ 及 函数’do_raw_spin_lock_flags()’：</p><ul><li><p>local_irq_save</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include/linux/irqflags.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> local_irq_save(flags)			\</span></span><br><span class="line"><span class="meta">do &#123;						\</span></span><br><span class="line"><span class="meta">	typecheck(unsigned long, flags);	\</span></span><br><span class="line"><span class="meta">	raw_local_irq_save(flags);		\</span></span><br><span class="line"><span class="meta">	trace_hardirqs_off();			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/irqflags.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_local_irq_save(flags)			\</span></span><br><span class="line"><span class="meta">	do &#123; (flags) = __raw_local_irq_save(); &#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __raw_local_irq_save(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags = __raw_local_save_flags();</span><br><span class="line">	raw_local_irq_disable();</span><br><span class="line">	<span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __raw_local_save_flags(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_save_fl();</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">native_save_fl</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;# __raw_save_flags\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;pushf ; pop %0&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;=rm&quot;</span> (flags)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : </span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>“# __raw_save_flags\n\t”</p><p>注释。</p></li><li><p>“pushf”</p><p>将eflags寄存器的内容入栈。</p></li><li><p>“pop %0”</p><p>栈顶内容载入 目的操作数中，此处为 flags。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/include/<span class="keyword">asm</span>/irqflags.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raw_local_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	native_irq_disable();</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*CLI 指令前面已做介绍*/</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do_raw_spin_lock_flags</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_raw_spin_lock_flags</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> *flags)</span> __<span class="title">acquires</span><span class="params">(lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__acquire(lock);</span><br><span class="line">	arch_spin_lock_flags(&amp;lock-&gt;raw_lock, *flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">arch_spin_lock_flags</span><span class="params">(<span class="keyword">arch_spinlock_t</span> *lock,</span></span></span><br><span class="line"><span class="params"><span class="function">						  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	arch_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch_spin_lock() 之前已经分析过。</span><br></pre></td></tr></table></figure></li></ul><p>这些函数的对应函数都是其逆操作。</p><h3 id="自旋锁和下半部"><a href="#自旋锁和下半部" class="headerlink" title="自旋锁和下半部"></a>自旋锁和下半部</h3><p>由于下半部可以抢占进程上下文中的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行。同样，由于中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据，那么就必须在获取恰当的锁的同时还要禁止中断。</p><p><strong>同类的tasklet不可能同时运行</strong>，所以对于同类tasklet中的共享数据不需要保护。但是当数据被两个不同种类的tasklet共享时，就需要在访问下半部中的数据前先获得一个普通的自旋锁。这里不需要禁止下半部，因为在<strong>同一个处理器上绝不会有tasklet相互抢占的情况</strong>。</p><p>对于软中断，无论是否同种类型，如果数据被软中断共享，那么它必须得到锁的保护。这是因为，即使是<strong>同种类型的两个软中断也可以同时运行在一个系统的多个处理器上</strong>。但是，<strong>同一处理器上的一个软中断绝不会抢占另一个软中断</strong>，因此，根本投必要禁止下半部。</p><h3 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h3><p>有时候，锁的用途明确的分为读取和写入两个场景。当更新(写入)链表时，不能有其他代码井发地写链表或从链表中读取数据，写操作要求完全互斥。另一方面，当对其检索(读取)链表时，只要其他程序不对链表进行写操作就行了。<br>只要没有写操作，多个并发的读操作都是安全的。</p><p>当对某个数据结构的操作可以像这样被划分为读/写或者消费者/生产者两种类别时，类似读/写锁这样的机制就很有帮助了。为此，Linux内核提供了专门的读一写自旋锁。这种自旋锁为读和写分别提供了不同的锁。一个或多个读任务可以并发地持有读者锁;相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。有时把读/写锁叫做共享/排斥锁，或者并发/排斥锁，因为这种锁以共亨(对读者而言)和排斥(对写者而言)的形式获得使用。</p><p>下面开始分析原理。</p><h4 id="rwlock-init"><a href="#rwlock-init" class="headerlink" title="rwlock_init"></a>rwlock_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock.h</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> rwlock_init(lock)					\</span></span><br><span class="line"><span class="meta">	do &#123; *(lock) = __RW_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock_types.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RW_LOCK_UNLOCKED(lockname) \</span></span><br><span class="line"><span class="meta">	(rwlock_t)	&#123;	.raw_lock = __ARCH_RW_LOCK_UNLOCKED,	\</span></span><br><span class="line"><span class="meta">				RW_DEP_MAP_INIT(lockname) &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOCK_BIAS		 0x01000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ARCH_RW_LOCK_UNLOCKED		&#123; RW_LOCK_BIAS &#125;</span></span><br></pre></td></tr></table></figure><p>初始化结果为 将 ‘0x01000000’ 赋值给 raw_lock 。</p><h4 id="read-lock"><a href="#read-lock" class="headerlink" title="read_lock"></a>read_lock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock(lock)		_raw_read_lock(lock)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">include/linux/rwlock_api_smp.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_read_lock(lock) __raw_read_lock(lock)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_read_lock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire_read(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock.h</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> do_raw_read_lock(rwlock)	\</span></span><br><span class="line"><span class="meta">	do &#123;__acquire(lock); arch_read_lock(&amp;(rwlock)-&gt;raw_lock); &#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_read_lock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot; subl $1,(%0)\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;jns 1f\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;call __read_lock_failed\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;1:\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     ::LOCK_PTR_REG (rw) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>“ subl $1,(%0)\n\t”</p><p>目的操作数值减1。在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。</p></li><li><p>“jns 1f\n”</p><p>指令 JNS 表示 ：如果符号位 (SF)不为1，就跳转。</p></li><li><p>“call __read_lock_failed\n\t”</p><p>调用符号 ‘__read_lock_failed’，此符号定义在文件”arch/x86/lib/semaphore_32.S”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__read_lock_failed)</span><br><span class="line">	CFI_STARTPROC</span><br><span class="line">	FRAME</span><br><span class="line"><span class="number">2</span>: 	<span class="function">LOCK_PREFIX</span></span><br><span class="line"><span class="function">	<span class="title">incl</span>	<span class="params">(%eax)</span></span></span><br><span class="line"><span class="function">1:	rep</span>; nop</span><br><span class="line">	cmpl	$<span class="number">1</span>,(%eax)</span><br><span class="line">	js	<span class="number">1b</span></span><br><span class="line">	<span class="function">LOCK_PREFIX</span></span><br><span class="line"><span class="function">	<span class="title">decl</span>	<span class="params">(%eax)</span></span></span><br><span class="line"><span class="function">	js	2b</span></span><br><span class="line"><span class="function">	ENDFRAME</span></span><br><span class="line"><span class="function">	ret</span></span><br><span class="line"><span class="function">	CFI_ENDPROC</span></span><br><span class="line"><span class="function">	<span class="title">ENDPROC</span><span class="params">(__read_lock_failed)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/include/<span class="keyword">asm</span>/dwarf2.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFI_STARTPROC             .cfi_startproc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFI_ENDPROC               .cfi_endproc</span></span><br><span class="line"></span><br><span class="line">.cfi_startproc用于每个函数的开头，这些函数应该在.eh_frame中有一个入口。 它初始化一些内部数据结构。 用.cfi_endproc关闭函数。</span><br><span class="line"></span><br><span class="line">除非.cfi_startproc与参数<span class="string">&quot;simple&quot;</span>一起使用，否则它还会发出一些与体系结构有关的初始CFI指令。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">伪代码如下：</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">	incl (%eax); <span class="comment">// eax 代表 lock ，因为之前减1没有加锁成功,所以先恢复原值。</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span>(lock - <span class="number">1</span>  &lt; <span class="number">0</span>)	<span class="comment">// write lock 直接减去 0x01000000, 为0,也就是说 write locked则一直循环。</span></span><br><span class="line">      <span class="keyword">goto</span> <span class="number">1</span>;</span><br><span class="line">	decl lock;</span><br><span class="line">	<span class="keyword">if</span>(lock &lt; <span class="number">0</span>)	<span class="comment">// 如果小于0，则说明在decl 之前，又被write 把锁抢占了，那么从头开始</span></span><br><span class="line">      <span class="keyword">goto</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span>	</span><br></pre></td></tr></table></figure></li></ol><p>读锁是减1，值不为负则加锁成功，因此最多可同时有’0x01000000’个读锁，完全足够。但是按照底层代码分析，即使加了读锁，写数据也是有可能的，这就需要内核开发人员必须能够分清需要读还是写。</p><h4 id="write-lock"><a href="#write-lock" class="headerlink" title="write_lock"></a>write_lock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock(lock)	_raw_write_lock(lock)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">include/linux/rwlock_api_smp.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_write_lock(lock) __raw_write_lock(lock)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_write_lock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock.h</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> do_raw_write_lock(rwlock)	\</span></span><br><span class="line"><span class="meta">	do &#123;__acquire(lock); arch_write_lock(&amp;(rwlock)-&gt;raw_lock); &#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">arch/x86/include/<span class="keyword">asm</span>/spinlock.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_write_lock</span><span class="params">(<span class="keyword">arch_rwlock_t</span> *rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot; subl %1,(%0)\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;jz 1f\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;call __write_lock_failed\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;1:\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     ::LOCK_PTR_REG (rw), <span class="string">&quot;i&quot;</span> (RW_LOCK_BIAS) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">伪代码如下：</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != (rw-&gt;lock - <span class="number">0x01000000</span>))</span><br><span class="line">  call __write_lock_failed</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__write_lock_failed)</span><br><span class="line">	CFI_STARTPROC simple</span><br><span class="line">	FRAME</span><br><span class="line"><span class="number">2</span>: 	LOCK_PREFIX</span><br><span class="line">	addl	$ RW_LOCK_BIAS,(%eax)</span><br><span class="line"><span class="number">1</span>:	rep; nop</span><br><span class="line">	cmpl	$ RW_LOCK_BIAS,(%eax)</span><br><span class="line">	jne	<span class="number">1b</span></span><br><span class="line">	LOCK_PREFIX</span><br><span class="line">	subl	$ RW_LOCK_BIAS,(%eax)</span><br><span class="line">	jnz	<span class="number">2b</span></span><br><span class="line">	<span class="function">ENDFRAME</span></span><br><span class="line"><span class="function">	ret</span></span><br><span class="line"><span class="function">	CFI_ENDPROC</span></span><br><span class="line"><span class="function">	<span class="title">ENDPROC</span><span class="params">(__write_lock_failed)</span></span></span><br></pre></td></tr></table></figure><p>write_lock 伪代码和 read_lock 类似，可试着自己分析一下。</p><h4 id="read-lock-bh"><a href="#read-lock-bh" class="headerlink" title="read_lock_bh"></a>read_lock_bh</h4><p>直接上最后的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock_api_smp.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_read_lock_bh(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_bh_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire_read(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 ‘local_bh_disable()’ 和 宏 ‘do_raw_read_lock’ 为核心，上面已经分析过。</p><h4 id="write-lock-bh"><a href="#write-lock-bh" class="headerlink" title="write_lock_bh"></a>write_lock_bh</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/rwlock_api_smp.h</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_write_lock_bh(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_bh_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read-lock-irq"><a href="#read-lock-irq" class="headerlink" title="read_lock_irq"></a>read_lock_irq</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_read_lock_irq(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire_read(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-lock-irq"><a href="#write-lock-irq" class="headerlink" title="write_lock_irq"></a>write_lock_irq</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_write_lock_irq(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	rwlock_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用(已经被占用)的信号量时，信号且会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用(被释放)后，处于等待队列中的那个任务将被唤醒，并获得该信号量。</p><ul><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。</li><li>相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要一长。</li><li>由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。</li><li>可以在持有信号量时去睡眠(当然你也可能并不需要睡眠)，因为当其他进程试图获得同一信号量时不会因此而死锁(因为该进程也只是去睡眠而已，而你最终会继续执行的)。</li><li>在占用信号量的同时不能占用自旋锁。因为在你等待信号量时可能会睡眠，而在持有自旋锁时是不允许睡眠的。</li></ul><p>以上这些结论阐明了信号量和自旋锁在使用上的差异。</p><p>信号量可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量(usage count)或简单地叫数量(count)。通常情况下，信号量和自旋锁一样，在一个时刻仅允许有一个锁持有者。这时计数等于1，这样的信号量被称为二值信号量或互斥信号量(因为它强制进行互斥)。另一方面，初始化时也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号童(counting semaphone)，它允许在一个时刻至多有count个锁持有者。计数信号量不能用来进行强制互斥，因为它允许多个执行线程同时访问临界区。相反，这种信号量用来对特定代码加以限制，内核中使用它的机会不多。在使用信号量时，基本上用到的都是互斥信号量(计数等于1的信号量)。</p><p>信号量支持两个原子操作P()和V()，这两个名字来自荷兰语Proberen和Vershogen。前者叫做测试操作(字面意思是探查)，后者叫做增加操作。后来的系统把两种操作分别叫做down()和up()。</p><p>down()操作通过对信号量计数减1来请求获得一个信号量。如果结果是0或大于0，获得信号量锁，任务就可以进入临界区。如果结果是负数，任务会被放入等待队列，处理器执行其他任务。相反，当临界区中的操作完成后，up()操作用来释放信号量。如果在该信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。</p><p>下面开始看代码</p><h3 id="sema-init"><a href="#sema-init" class="headerlink" title="sema_init"></a>sema_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">include/linux/semaphore.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;			<span class="comment">//原始锁，保护下面的两个数据</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		count;			<span class="comment">//可用计数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span>		<span class="comment">//等待队列</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore *sem, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">  	<span class="comment">/*核心函数*/</span></span><br><span class="line">	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)				\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\</span></span><br><span class="line"><span class="meta">	.count		= n,						\</span></span><br><span class="line"><span class="meta">	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">__RAW_SPIN_LOCK_UNLOCKED	<span class="comment">//之前分析过，这个是 lock 的初始化。</span></span><br></pre></td></tr></table></figure><p>初始化仅仅是将结构体内的3个字段进行初始。</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">kernel/semaphore.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="comment">/*加irqsave锁，防止上下文切换并保护数据*/</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">  	<span class="comment">/*大于0说明还有可用计数，仅仅减计数即可；</span></span><br><span class="line"><span class="comment">  	likely-当条件成立时，可优化代码执行速度*/</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">		sem-&gt;count--;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__down(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	#define	MAX_SCHEDULE_TIMEOUT	LONG_MAX</span></span><br><span class="line"><span class="comment">  	#define LONG_MAX	((long)(~0UL&gt;&gt;1))</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> up;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sched __down_common(struct semaphore *sem, <span class="keyword">long</span> state,</span><br><span class="line">								<span class="keyword">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*task为当前进程描述符*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">	waiter.task = task;</span><br><span class="line">	waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">/*signal_pending_state分析见下面。*/</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(state, task))</span><br><span class="line">			<span class="keyword">goto</span> interrupted;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">goto</span> timed_out;</span><br><span class="line">      	<span class="comment">/*将当前任务设置为TASK_UNINTERRUPTIBLE状态*/</span></span><br><span class="line">		__set_task_state(task, state);</span><br><span class="line">      	<span class="comment">/*unlock之后进行进程切换*/</span></span><br><span class="line">		raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">		timeout = schedule_timeout(timeout);</span><br><span class="line">      	<span class="comment">/*切换回来后重新加锁</span></span><br><span class="line"><span class="comment">      	判断切换期间是否有信号量释放，没有则继续使任务睡眠*/</span></span><br><span class="line">		raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (waiter.up)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">signal_pending_state</span><span class="params">(<span class="keyword">long</span> state, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*函数正确返回：</span></span><br><span class="line"><span class="comment">  	1. 不为 (TASK_INTERRUPTIBLE | TASK_WAKEKILL)</span></span><br><span class="line"><span class="comment">  	2. TASK_INTERRUPTIBLE 时，没有 要处理的信号  ---&gt;&gt;&gt; 信号会打断状态</span></span><br><span class="line"><span class="comment">  	3. TASK_WAKEKILL 时，没有 未处理的 KILL 信号	---&gt;&gt;&gt; 信号会打断状态</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">  	<span class="comment">/*若设置状态为 TASK_INTERRUPTIBLE | TASK_WAKEKILL(仅响应致命信号) 则继续，否则退出*/</span></span><br><span class="line">	<span class="keyword">if</span> (!(state &amp; (TASK_INTERRUPTIBLE | TASK_WAKEKILL)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">/*如果有未处理的信号，则继续，否则退出*/</span></span><br><span class="line">	<span class="keyword">if</span> (!signal_pending(p))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">/*若 state为 TASK_INTERRUPTIBLE</span></span><br><span class="line"><span class="comment">  	或 存在未处理的KILL信号，则返回 true*/</span></span><br><span class="line">	<span class="keyword">return</span> (state &amp; TASK_INTERRUPTIBLE) || __fatal_signal_pending(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>down_interruptible、down_killable、down_trylock和down_timeout，这几个函数不在分析，内部函数都分析过，只是状态或timeout重设而已。</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">  	<span class="comment">/*等待队列为空，说明没有进程等待此信号量，则增计数即可*/</span></span><br><span class="line">	<span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">		sem-&gt;count++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__up(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*有进程等待此信号量，那么</span></span><br><span class="line"><span class="comment">  	1.从等待队列从找出第一个数据</span></span><br><span class="line"><span class="comment">  	2.从等待队列删除</span></span><br><span class="line"><span class="comment">  	3.将此队列up置为true--&gt;&gt;down 中的循环条件</span></span><br><span class="line"><span class="comment">  	4.唤醒函数*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">						struct semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">	list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">	waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">	wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><p>与自旋锁类似，信号量也可优化为读写信号量，直接开始分析代码：</p><h4 id="init-rwsem"><a href="#init-rwsem" class="headerlink" title="init_rwsem"></a>init_rwsem</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*此处定义了 两种结构体，根据是否开启RWSEM选项而用不同结构体及实现*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RWSEM_GENERIC_SPINLOCK <span class="comment">//专用锁</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rwsem-spinlock.h&gt;</span> <span class="comment">/* use a generic implementation */</span></span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	0 为初始状态</span></span><br><span class="line"><span class="comment">	&gt;0 表示有读者，数量为读者数量</span></span><br><span class="line"><span class="comment">	-1 表示有写者</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	__s32			activity;</span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		wait_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* All arch specific implementations share the same struct */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span>			count;</span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		wait_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_rwsem(sem)						\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;			\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">	__init_rwsem((sem), #sem, &amp;__key);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><ul><li><p>rwsem.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __init_rwsem(struct rw_semaphore *sem, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">		  struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we are not reinitializing a held semaphore:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	debug_check_no_locks_freed((<span class="keyword">void</span> *)sem, <span class="keyword">sizeof</span>(*sem));</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;dep_map, name, key, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	sem-&gt;count = RWSEM_UNLOCKED_VALUE;</span><br><span class="line">	raw_spin_lock_init(&amp;sem-&gt;wait_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;sem-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通信号量相同的初始化。</p></li><li><p>rwsem-spinlock.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __init_rwsem(struct rw_semaphore *sem, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">		  struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we are not reinitializing a held semaphore:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	debug_check_no_locks_freed((<span class="keyword">void</span> *)sem, <span class="keyword">sizeof</span>(*sem));</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;dep_map, name, key, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	sem-&gt;activity = <span class="number">0</span>;</span><br><span class="line">	raw_spin_lock_init(&amp;sem-&gt;wait_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;sem-&gt;wait_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="down-read"><a href="#down-read" class="headerlink" title="down_read"></a>down_read</h4><ul><li><p>x86架构 普通实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __down_read(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;# beginning down_read\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     LOCK_PREFIX _ASM_INC <span class="string">&quot;(%1)\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="comment">/* adds 0x00000001 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;  jns        1f\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;  call call_rwsem_down_read_failed\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;1:\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="string">&quot;# ending down_read\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;+m&quot;</span> (sem-&gt;count)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;a&quot;</span> (sem)</span></span></span><br><span class="line"><span class="params"><span class="function">		     : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自加 1，结果为正则退出，为负则 跳转到函数 ‘call_rwsem_down_read_failed’，请参考之前的查找方式自己查找其实现。</p></li><li><p>专用锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sched __down_read(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rwsem_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">	<span class="comment">/*初始化状态 或 仅有读者则 自加1 退出*/</span></span><br><span class="line">	<span class="keyword">if</span> (sem-&gt;activity &gt;= <span class="number">0</span> &amp;&amp; list_empty(&amp;sem-&gt;wait_list)) &#123;</span><br><span class="line">		<span class="comment">/* granted */</span></span><br><span class="line">		sem-&gt;activity++;</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*此处说明，有写者已经加锁*/</span></span><br><span class="line">  	<span class="comment">/*将任务设置为 TASK_UNINTERRUPTIBLE 状态*/</span></span><br><span class="line">	tsk = current;</span><br><span class="line">	set_task_state(tsk, TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化 waiter 并将其加入 读写信号量 链表*/</span></span><br><span class="line">	waiter.task = tsk;</span><br><span class="line">	waiter.type = RWSEM_WAITING_FOR_READ;</span><br><span class="line">  	<span class="comment">/*增加当前进程使用计数 usage*/</span></span><br><span class="line">	get_task_struct(tsk);</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*解锁之后继续等待*/</span></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*循环等锁，进程切换再次判断。</span></span><br><span class="line"><span class="comment">	waiter列表无任务则退出。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!waiter.task)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		schedule();</span><br><span class="line">		set_task_state(tsk, TASK_UNINTERRUPTIBLE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;state = TASK_RUNNING;</span><br><span class="line"> out:</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者无锁应该等写者解锁：up_write。之后分析专用文件。</p></li></ul><h4 id="up-write"><a href="#up-write" class="headerlink" title="up_write"></a>up_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rwsem_waiter_type</span> &#123;</span></span><br><span class="line">	RWSEM_WAITING_FOR_WRITE,</span><br><span class="line">	RWSEM_WAITING_FOR_READ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __up_write(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">	<span class="comment">/*写者解锁直接赋值为0 即可。若队列有等待进程则唤醒</span></span><br><span class="line"><span class="comment">	1 为是否唤醒 写者标志*/</span></span><br><span class="line">	sem-&gt;activity = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;sem-&gt;wait_list))</span><br><span class="line">		sem = __rwsem_do_wake(sem, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rwsem_do_wake</span>(<span class="keyword">struct</span> <span class="title">rw_semaphore</span> *<span class="title">sem</span>, <span class="title">int</span> <span class="title">wakewrite</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rwsem_waiter</span> *<span class="title">waiter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="keyword">int</span> woken;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*等待队列中获取一个等待者*/</span></span><br><span class="line">	waiter = list_entry(sem-&gt;wait_list.next, struct rwsem_waiter, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*写者独占锁，则唤醒即退出*/</span></span><br><span class="line">	<span class="keyword">if</span> (waiter-&gt;type == RWSEM_WAITING_FOR_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wakewrite)</span><br><span class="line">			wake_up_process(waiter-&gt;task);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*唤醒全部读者 或者 仅唤醒 等待的写者之前的读者</span></span><br><span class="line"><span class="comment">  	  这么做的原因是保证顺序性，防止在写者之后的读者读到旧的数据</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	woken = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span> =</span> waiter-&gt;<span class="built_in">list</span>.next;</span><br><span class="line"></span><br><span class="line">		list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">		tsk = waiter-&gt;task;</span><br><span class="line">      	<span class="comment">/*内存屏障，保证顺序性，防止 tsk为NULL*/</span></span><br><span class="line">		smp_mb();</span><br><span class="line">		waiter-&gt;task = <span class="literal">NULL</span>;</span><br><span class="line">		wake_up_process(tsk);</span><br><span class="line">      	<span class="comment">/*读的时候 get了一下*/</span></span><br><span class="line">		put_task_struct(tsk);</span><br><span class="line">		woken++;</span><br><span class="line">		<span class="keyword">if</span> (next == &amp;sem-&gt;wait_list)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		waiter = list_entry(next, struct rwsem_waiter, <span class="built_in">list</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (waiter-&gt;type != RWSEM_WAITING_FOR_WRITE);</span><br><span class="line">	<span class="comment">/*增加唤醒的读者数量*/</span></span><br><span class="line">	sem-&gt;activity += woken;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="down-write"><a href="#down-write" class="headerlink" title="down_write"></a>down_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sched __down_write(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	__down_write_nested(sem, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> __sched __down_write_nested(struct rw_semaphore *sem, <span class="keyword">int</span> subclass)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rwsem_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*先初始化一个结构体，不能放循环里*/</span></span><br><span class="line">	tsk = current;</span><br><span class="line">	waiter.task = tsk;</span><br><span class="line">	waiter.type = RWSEM_WAITING_FOR_WRITE;</span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*无人状态则加锁退出</span></span><br><span class="line"><span class="comment">		此循环进行等锁*/</span></span><br><span class="line">		<span class="keyword">if</span> (sem-&gt;activity == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		set_task_state(tsk, TASK_UNINTERRUPTIBLE);</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">		schedule();</span><br><span class="line">		raw_spin_lock_irqsave(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* got the lock */</span></span><br><span class="line">	sem-&gt;activity = <span class="number">-1</span>;</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="up-read"><a href="#up-read" class="headerlink" title="up_read"></a>up_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __up_read(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (--sem-&gt;activity == <span class="number">0</span> &amp;&amp; !list_empty(&amp;sem-&gt;wait_list))</span><br><span class="line">		sem = __rwsem_wake_one_writer(sem);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;wait_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="comment">/*读锁唤醒时，等待队列中肯定都是写进程*/</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> *</span></span><br><span class="line"><span class="class"> __<span class="title">rwsem_wake_one_writer</span>(<span class="keyword">struct</span> <span class="title">rw_semaphore</span> *<span class="title">sem</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">rwsem_waiter</span> *<span class="title">waiter</span>;</span></span><br><span class="line"> </span><br><span class="line"> 	waiter = list_entry(sem-&gt;wait_list.next, struct rwsem_waiter, <span class="built_in">list</span>);</span><br><span class="line"> 	wake_up_process(waiter-&gt;task);</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">return</span> sem;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>多数用户使用信号量只使用计数1，把它作为一个互斥的排它锁。信号量用户通用且没多少使用限制，这使得信号量适合用于那些较复杂的、未明情况下的互斥访问，比如内核于用户空间复杂的交互行为。</p><p>但这也意味着简单的锁定而使用信号量不方便，并且信号量也缺乏强制的规则来行使任何形式的自动调试，即便受限的调试也不可能。为了找到一个更简单的睡眠锁，内核开发者们引入了互斥体（mutex）。</p><p>mutex在内核中对应数据结构体mutex，其行为和使用计数为1的信号量类似，但操作接口更简单，实现也更高效，而且使用限制更强。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		wait_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)</span></span><br><span class="line">  	<span class="comment">/*多核架构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">	<span class="keyword">void</span>			*spin_mlock;	<span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> 		*name;</span><br><span class="line">	<span class="keyword">void</span>			*magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mutex-init"><a href="#mutex-init" class="headerlink" title="mutex_init"></a>mutex_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> mutex_init(mutex) \</span></span><br><span class="line"><span class="meta">do &#123;							\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;		\</span></span><br><span class="line"><span class="meta">	__mutex_init((mutex), #mutex, &amp;__key);		\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__mutex_init(struct mutex *lock, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*初始化字段*/</span></span><br><span class="line">	atomic_set(&amp;lock-&gt;count, <span class="number">1</span>);</span><br><span class="line">	spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line">	mutex_clear_owner(lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">	lock-&gt;spin_mlock = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock"></a>mutex_lock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*不知道为什么需要睡一下*/</span></span><br><span class="line">	might_sleep();</span><br><span class="line">	__mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">  	<span class="comment">/*设置进程owner*/</span></span><br><span class="line">	mutex_set_owner(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*__sched */</span></span><br><span class="line"><span class="comment">/*	Attach to any functions which should be ignored in wchan output. </span></span><br><span class="line"><span class="comment">    #define __sched         __attribute__((__section__(&quot;.sched.text&quot;)))</span></span><br><span class="line"><span class="comment">把带有__sched的函数放到.sched.text段。</span></span><br><span class="line"><span class="comment">kernel有个waiting channel，如果用户空间的进程睡眠了，可以查到是停在内核空间哪个函数中等待的：</span></span><br><span class="line"><span class="comment">    cat &quot;/proc/&lt;pid&gt;/wchan&quot;</span></span><br><span class="line"><span class="comment">显然，.sched.text段的代码是会被wchan忽略的，schedule这个函数是不会出现在wchan的结果中的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x86架构</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count 自减1，结果不为负（1--&gt;0）则退出；</span></span><br><span class="line"><span class="comment">否则，调用fail_fn函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __mutex_fastpath_lock(count, fail_fn)			\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	unsigned int dummy;					\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">	typecheck(atomic_t *, count);				\</span></span><br><span class="line"><span class="meta">	typecheck_fn(void (*)(atomic_t *), fail_fn);		\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">	asm volatile(LOCK_PREFIX <span class="meta-string">&quot;   decl (%%eax)\n&quot;</span>		\</span></span><br><span class="line"><span class="meta">		     <span class="meta-string">&quot;   jns 1f	\n&quot;</span>				\</span></span><br><span class="line"><span class="meta">		     <span class="meta-string">&quot;   call &quot;</span> #fail_fn <span class="meta-string">&quot;\n&quot;</span>			\</span></span><br><span class="line"><span class="meta">		     <span class="meta-string">&quot;1:\n&quot;</span>					\</span></span><br><span class="line"><span class="meta">		     : <span class="meta-string">&quot;=a&quot;</span> (dummy)				\</span></span><br><span class="line"><span class="meta">		     : <span class="meta-string">&quot;a&quot;</span> (count)				\</span></span><br><span class="line"><span class="meta">		     : <span class="meta-string">&quot;memory&quot;</span>, <span class="meta-string">&quot;ecx&quot;</span>, <span class="meta-string">&quot;edx&quot;</span>);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __used noinline <span class="keyword">void</span> __sched</span><br><span class="line">__mutex_lock_slowpath(<span class="keyword">atomic_t</span> *lock_count)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*container_of，内核的巧妙设计，请阅读源码*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span> =</span> container_of(lock_count, struct mutex, count);</span><br><span class="line">	__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="literal">NULL</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># define __used			__attribute__((__unused__))</span></span><br><span class="line"><span class="comment">告诉编译器无论 GCC 是否发现这个函数的调用实例，都要使用这个函数。这对于从汇编代码中调用 C 函数有帮助。</span></span><br><span class="line"><span class="comment">noinline  强制不内联</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">		    struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">  	<span class="comment">/*禁止内核抢占*/</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	当发现没有待处理的服务器并且锁所有者当前正在（不同的）CPU上运行时，尝试旋转获取（fastpath）。</span></span><br><span class="line"><span class="comment">	理由是，如果锁主人正在运行，很可能很快就会解锁。</span></span><br><span class="line"><span class="comment">	由于这需要锁所有者，而且这个互斥体实现不会在锁定字段中原子地跟踪所有者，所以需要非原子地跟踪它。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  	<span class="comment">/*判断 进程描述符 on_cpu 位，以此判断是否在占用cpu(网上查询此标志释义不正确，可查代码自知)</span></span><br><span class="line"><span class="comment">  	在 cpu 上，认为会很快解锁，所以循环等待。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">if</span> (!mutex_can_spin_on_owner(lock))</span><br><span class="line">		<span class="keyword">goto</span> slowpath;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mspin_node</span>  <span class="title">node</span>;</span></span><br><span class="line">		<span class="comment">/*mspin_lock 旋转等待解锁，函数分析在下面*/</span></span><br><span class="line">		mspin_lock(MLOCK(lock), &amp;node);</span><br><span class="line">      	<span class="comment">/*ACCESS_ONCE 保证字段是从内存获取*/</span></span><br><span class="line">		owner = ACCESS_ONCE(lock-&gt;owner);</span><br><span class="line">		<span class="keyword">if</span> (owner &amp;&amp; !mutex_spin_on_owner(lock, owner)) &#123;</span><br><span class="line">			mspin_unlock(MLOCK(lock), &amp;node);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((atomic_read(&amp;lock-&gt;count) == <span class="number">1</span>) &amp;&amp;</span><br><span class="line">		    (atomic_cmpxchg(&amp;lock-&gt;count, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">			lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">			mutex_set_owner(lock);</span><br><span class="line">			mspin_unlock(MLOCK(lock), &amp;node);</span><br><span class="line">			preempt_enable();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mspin_unlock(MLOCK(lock), &amp;node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When there&#x27;s no owner, we might have preempted between the</span></span><br><span class="line"><span class="comment">		 * owner acquiring the lock and setting the owner field. If</span></span><br><span class="line"><span class="comment">		 * we&#x27;re an RT task that will live-lock because we won&#x27;t let</span></span><br><span class="line"><span class="comment">		 * the owner complete.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!owner &amp;&amp; (need_resched() || rt_task(task)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The cpu_relax() call is a compiler barrier which forces</span></span><br><span class="line"><span class="comment">		 * everything in this loop to be re-loaded. We don&#x27;t need</span></span><br><span class="line"><span class="comment">		 * memory barriers as we&#x27;ll eventually observe the right</span></span><br><span class="line"><span class="comment">		 * values at the cost of a few extra spins.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		arch_mutex_cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">slowpath:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line">	debug_mutex_add_waiter(lock, &amp;waiter, task_thread_info(task));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;lock-&gt;wait_list);</span><br><span class="line">	waiter.task = task;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MUTEX_SHOW_NO_WAITER(lock) &amp;&amp; (atomic_xchg(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lets try to take the lock again - this is needed even if</span></span><br><span class="line"><span class="comment">		 * we get here for the first time (shortly after failing to</span></span><br><span class="line"><span class="comment">		 * acquire the lock), to make sure that we get a wakeup once</span></span><br><span class="line"><span class="comment">		 * it&#x27;s unlocked. Later on, if we sleep, this is the</span></span><br><span class="line"><span class="comment">		 * operation that gives us the lock. We xchg it to -1, so</span></span><br><span class="line"><span class="comment">		 * that when we release the lock, we properly wake up the</span></span><br><span class="line"><span class="comment">		 * other waiters:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (MUTEX_SHOW_NO_WAITER(lock) &amp;&amp;</span><br><span class="line">		   (atomic_xchg(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * got a signal? (This code gets eliminated in the</span></span><br><span class="line"><span class="comment">		 * TASK_UNINTERRUPTIBLE case.)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">			mutex_remove_waiter(lock, &amp;waiter,</span><br><span class="line">					    task_thread_info(task));</span><br><span class="line">			mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">			spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">			debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">			preempt_enable();</span><br><span class="line">			<span class="keyword">return</span> -EINTR;</span><br><span class="line">		&#125;</span><br><span class="line">		__set_task_state(task, state);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* didn&#x27;t get the lock, go to sleep: */</span></span><br><span class="line">		spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">		schedule_preempt_disabled();</span><br><span class="line">		spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">	<span class="comment">/* got the lock - rejoice! */</span></span><br><span class="line">	mutex_remove_waiter(lock, &amp;waiter, current_thread_info());</span><br><span class="line">	mutex_set_owner(lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set it to 0 if there are no waiters left: */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">		atomic_set(&amp;lock-&gt;count, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mspin_lock</span><span class="params">(struct mspin_node **lock, struct mspin_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mspin_node</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init node */</span></span><br><span class="line">	node-&gt;locked = <span class="number">0</span>;</span><br><span class="line">	node-&gt;next   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	prev = xchg(lock, node);</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	可理解为 prev = lock;</span></span><br><span class="line"><span class="comment">  	lock = node;  node 无变化</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/* Lock acquired */</span></span><br><span class="line">		node-&gt;locked = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ACCESS_ONCE(prev-&gt;next) = node;</span><br><span class="line">	smp_wmb();</span><br><span class="line">	<span class="comment">/* 等待锁持有者放行 */</span></span><br><span class="line">	<span class="keyword">while</span> (!ACCESS_ONCE(node-&gt;locked))</span><br><span class="line">		arch_mutex_cpu_relax();	<span class="comment">// 执行 nop</span></span><br><span class="line">&#125;</span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line">x86</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xchg(ptr, v)	__xchg_op((ptr), (v), xchg, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line">---&gt;&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __xchg_op(ptr, arg, op, lock)					\</span></span><br><span class="line"><span class="meta">	(&#123;								\</span></span><br><span class="line"><span class="meta">		<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="meta">		定义返回值 __ret</span></span></span><br><span class="line"><span class="comment"><span class="meta">		arg 在刚开始就已经赋给 __ret，也就是说不对 arg进行操作</span></span></span><br><span class="line"><span class="comment"><span class="meta">		lock 传参为&quot;&quot;，xchg 指令有 lock 功能</span></span></span><br><span class="line"><span class="comment"><span class="meta">		xchg 释义为：</span></span></span><br><span class="line"><span class="comment"><span class="meta">			TEMP ← DEST;</span></span></span><br><span class="line"><span class="comment"><span class="meta">			DEST ← SRC;</span></span></span><br><span class="line"><span class="comment"><span class="meta">			SRC ← TEMP;</span></span></span><br><span class="line"><span class="comment"><span class="meta">		*/</span></span></span><br><span class="line">	        __typeof__ (*(ptr)) __ret = (arg);			\</span><br><span class="line">		<span class="keyword">switch</span> (<span class="keyword">sizeof</span>(*(ptr))) &#123;				\</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">case</span> __X86_CASE_B:					\</span><br><span class="line">			<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(lock #op <span class="string">&quot;b %b0, %1\n&quot;</span>		\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : <span class="string">&quot;+q&quot;</span> (__ret), <span class="string">&quot;+m&quot;</span> (*(ptr))	\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;		\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">case</span> __X86_CASE_W:					\</span><br><span class="line">			<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(lock #op <span class="string">&quot;w %w0, %1\n&quot;</span>		\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : <span class="string">&quot;+r&quot;</span> (__ret), <span class="string">&quot;+m&quot;</span> (*(ptr))	\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;		\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">		<span class="comment">// 4</span></span><br><span class="line">		<span class="keyword">case</span> __X86_CASE_L:					\</span><br><span class="line">			<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(lock #op <span class="string">&quot;l %0, %1\n&quot;</span>		\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : <span class="string">&quot;+r&quot;</span> (__ret), <span class="string">&quot;+m&quot;</span> (*(ptr))	\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;		\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">		<span class="comment">// 8</span></span><br><span class="line">		<span class="keyword">case</span> __X86_CASE_Q:					\</span><br><span class="line">			<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(lock #op <span class="string">&quot;q %q0, %1\n&quot;</span>		\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : <span class="string">&quot;+r&quot;</span> (__ret), <span class="string">&quot;+m&quot;</span> (*(ptr))	\</span></span></span><br><span class="line"><span class="params"><span class="function">				      : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>)</span></span>;		\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">		<span class="keyword">default</span>:						\</span><br><span class="line">			__ #<span class="meta"># op ## _wrong_size();			\</span></span><br><span class="line"><span class="meta">		&#125;							\</span></span><br><span class="line"><span class="meta">		__ret;							\</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="mutex-unlock"><a href="#mutex-unlock" class="headerlink" title="mutex_unlock"></a>mutex_unlock</h3><p>TODO</p><h2 id="完成变量"><a href="#完成变量" class="headerlink" title="完成变量"></a>完成变量</h2><h3 id="init-completion"><a href="#init-completion" class="headerlink" title="init_completion"></a>init_completion</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> done;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_completion</span><span class="params">(struct completion *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x-&gt;done = <span class="number">0</span>;</span><br><span class="line">	init_waitqueue_head(&amp;x-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_waitqueue_head(q)				\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">		__init_waitqueue_head((q), #q, &amp;__key);	\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="comment">//init the spinlock and the list</span></span><br><span class="line"><span class="keyword">void</span> __init_waitqueue_head(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;q-&gt;lock);</span><br><span class="line">	lockdep_set_class_and_name(&amp;q-&gt;lock, key, name);</span><br><span class="line">	INIT_LIST_HEAD(&amp;q-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-for-completion"><a href="#wait-for-completion" class="headerlink" title="wait_for_completion"></a>wait_for_completion</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">wait_for_completion</span><span class="params">(struct completion *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> __sched</span></span><br><span class="line"><span class="function"><span class="title">wait_for_common</span><span class="params">(struct completion *x, <span class="keyword">long</span> timeout, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __wait_for_common(x, schedule_timeout, timeout, state);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __sched</span><br><span class="line">__wait_for_common(struct completion *x,</span><br><span class="line">		  <span class="keyword">long</span> (*action)(<span class="keyword">long</span>), <span class="keyword">long</span> timeout, <span class="keyword">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;x-&gt;wait.lock);</span><br><span class="line">	timeout = do_wait_for_common(x, action, timeout, state);</span><br><span class="line">	spin_unlock_irq(&amp;x-&gt;wait.lock);</span><br><span class="line">	<span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __sched</span></span><br><span class="line"><span class="function"><span class="title">do_wait_for_common</span><span class="params">(struct completion *x,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">long</span> (*action)(<span class="keyword">long</span>), <span class="keyword">long</span> timeout, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x-&gt;done) &#123;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	#define DECLARE_WAITQUEUE(name, tsk)					\</span></span><br><span class="line"><span class="comment">			wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br><span class="line"><span class="comment">		--&gt;&gt;</span></span><br><span class="line"><span class="comment">		#define __WAITQUEUE_INITIALIZER(name, tsk) &#123;				\</span></span><br><span class="line"><span class="comment">        .private	= tsk,						\</span></span><br><span class="line"><span class="comment">        .func		= default_wake_function,			\</span></span><br><span class="line"><span class="comment">        .task_list	= &#123; NULL, NULL &#125; &#125;</span></span><br><span class="line"><span class="comment">		--&gt;&gt;</span></span><br><span class="line"><span class="comment">		int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,</span></span><br><span class="line"><span class="comment">			  void *key)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">        	try_to_wake_up 改变状态成功则 return  success = 1;</span></span><br><span class="line"><span class="comment">            return try_to_wake_up(curr-&gt;private, mode, wake_flags);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">       	*/</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	定义一个等待队列；更改flags 并加入到 完成变量的 等待队列中。</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		DECLARE_WAITQUEUE(wait, current);		</span><br><span class="line">		__add_wait_queue_tail_exclusive(&amp;x-&gt;wait, &amp;wait);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	state = TASK_UNINTERRUPTIBLE;</span></span><br><span class="line"><span class="comment">          	signal_pending_state 前面分析过</span></span><br><span class="line"><span class="comment">          	*/</span></span><br><span class="line">			<span class="keyword">if</span> (signal_pending_state(state, current)) &#123;</span><br><span class="line">				timeout = -ERESTARTSYS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">          	<span class="comment">/*设置当前进程状态；之后解锁进行进程调度*/</span></span><br><span class="line">			__set_current_state(state);</span><br><span class="line">			spin_unlock_irq(&amp;x-&gt;wait.lock);</span><br><span class="line">			timeout = action(timeout);</span><br><span class="line">			spin_lock_irq(&amp;x-&gt;wait.lock);</span><br><span class="line">		&#125; <span class="keyword">while</span> (!x-&gt;done &amp;&amp; timeout);</span><br><span class="line">		</span><br><span class="line">		__remove_wait_queue(&amp;x-&gt;wait, &amp;wait);</span><br><span class="line">		<span class="keyword">if</span> (!x-&gt;done)</span><br><span class="line">			<span class="keyword">return</span> timeout;</span><br><span class="line">	&#125;</span><br><span class="line">	x-&gt;done--;</span><br><span class="line">	<span class="keyword">return</span> timeout ?: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可自己分析函数变体 wait_for_completion_*。</p><h3 id="complete"><a href="#complete" class="headerlink" title="complete"></a>complete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(struct completion *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);</span><br><span class="line">  	<span class="comment">/*增加完成标志*/</span></span><br><span class="line">	x-&gt;done++;</span><br><span class="line">	__wake_up_common(&amp;x-&gt;wait, TASK_NORMAL, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">wait_queue_t</span> *curr, *next;</span><br><span class="line">	<span class="comment">/*循环列表中每一个 queue，第一个唤醒成功 则退出；</span></span><br><span class="line"><span class="comment">	唤醒之后就到了 do_wait_for_common 中继续执行代码；</span></span><br><span class="line"><span class="comment">	循环列表内部 条件从左至右，因此，成功 nr_exclusive个就退出*/</span></span><br><span class="line">	list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span><br><span class="line">				(flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以自己分析 函数变体 complete_all。</p><h2 id="大内核锁（BKL）"><a href="#大内核锁（BKL）" class="headerlink" title="大内核锁（BKL）"></a>大内核锁（BKL）</h2><p>对整个内核加锁，现在已不在使用。</p><h2 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h2><p>顺序锁，简称seq锁，是在2.6版本内核中引入的一种新型锁。这种锁提供了一种很简单的机制，用于读写共享数据。实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过。此外，如果读取的值是偶数，那么久表明写操作没有发生（锁的初始值是0，写锁会使值成奇数，释放会使值变成偶数）。</p><h3 id="初始化-DEFINE-SEQLOCK"><a href="#初始化-DEFINE-SEQLOCK" class="headerlink" title="初始化 DEFINE_SEQLOCK"></a>初始化 DEFINE_SEQLOCK</h3><p>seq锁的基本结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个计数器；一个自旋锁*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> <span class="title">seqcount</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">seqlock_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SEQLOCK(x) \</span></span><br><span class="line"><span class="meta">		seqlock_t x = __SEQLOCK_UNLOCKED(x)</span></span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SEQLOCK_UNLOCKED(lockname)			\</span></span><br><span class="line"><span class="meta">	&#123;						\</span></span><br><span class="line"><span class="meta">		<span class="comment">/*#define SEQCNT_ZERO &#123; 0 &#125;*/</span></span></span><br><span class="line">		.seqcount = SEQCNT_ZERO,		\</span><br><span class="line">		.lock =	__SPIN_LOCK_UNLOCKED(lockname)	\</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>初始化即为 将计数值为0并初始化自旋锁。也可以利用宏 seqlock_init进行初始化。</p><h3 id="write-seqlock"><a href="#write-seqlock" class="headerlink" title="write_seqlock"></a>write_seqlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqlock</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*先加锁，然后计数加一*/</span></span><br><span class="line">	spin_lock(&amp;sl-&gt;lock);</span><br><span class="line">	write_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqcount_begin</span><span class="params">(<span class="keyword">seqcount_t</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s-&gt;sequence++;</span><br><span class="line">	smp_wmb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-sequnlock"><a href="#write-sequnlock" class="headerlink" title="write_sequnlock"></a>write_sequnlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_sequnlock</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/*计数加一 之后 解锁*/</span></span><br><span class="line">	write_seqcount_end(&amp;sl-&gt;seqcount);</span><br><span class="line">	spin_unlock(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqcount_end</span><span class="params">(<span class="keyword">seqcount_t</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	smp_wmb();</span><br><span class="line">	s-&gt;sequence++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写的顺序锁基本无难度，下面举例看一下read的用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the device for a periodic tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick_setup_periodic</span><span class="params">(struct clock_event_device *dev, <span class="keyword">int</span> broadcast)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			seq = read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">			next = tick_next_period;</span><br><span class="line">		&#125; <span class="keyword">while</span> (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line">		……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-seqbegin"><a href="#read-seqbegin" class="headerlink" title="read_seqbegin"></a>read_seqbegin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">read_seqbegin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> read_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">read_seqcount_begin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">seqcount_t</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> ret = __read_seqcount_begin(s);</span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> __read_seqcount_begin(<span class="keyword">const</span> <span class="keyword">seqcount_t</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> ret;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	ret = ACCESS_ONCE(s-&gt;sequence);</span><br><span class="line">  	<span class="comment">/*为真表示奇数，write已加锁*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		cpu_relax();</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*返回之后，write又加锁了咋办？继续看*/</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-seqretry"><a href="#read-seqretry" class="headerlink" title="read_seqretry"></a>read_seqretry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">read_seqretry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">seqlock_t</span> *sl, <span class="keyword">unsigned</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> read_seqcount_retry(&amp;sl-&gt;seqcount, start);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read_seqcount_retry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">seqcount_t</span> *s, <span class="keyword">unsigned</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">return</span> __read_seqcount_retry(s, start);</span><br><span class="line">&#125;</span><br><span class="line">--&gt;&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __read_seqcount_retry(<span class="keyword">const</span> <span class="keyword">seqcount_t</span> *s, <span class="keyword">unsigned</span> start)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">/*不相同表示读后又被写了，那么继续循环！*/</span></span><br><span class="line">	<span class="keyword">return</span> unlikely(s-&gt;sequence != start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seq锁有助于提供一种非常轻量级和具有扩展性的外观。但是seq锁对写者更有利。seq锁在遇到如下需求时将是最理想的选择：</p><ul><li>数据存在很多读者。</li><li>数据写者很少。</li><li>写者很少，但是希望写优先于读，而且不允许读者让写着饥饿。</li><li>数据简单，如简单结构，甚至是简单的整型——在某些场合，是不能使用原子量的。（啥场合暂时未遇到）</li></ul><p>jiffies中利用seq锁（函数 get_jiffies_64）。</p><h2 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h2><p>由于内核是抢占性的，内核中的进程在任何时刻都可能停下来以便另一个具有更高优先权的进程运行。这意味着一个任务与被枪占的任务可能会在同一个临界区内运行。为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标记。如果一个自旋锁被持有，内核便不能进行抢占。因为内核抢占和SMP面对相同的并发问题，并且内核已经是SMP安全的（SMP-safe），所以，这种简单的变化使得内核也是抢占安全的（preempt-safe）。</p><p>实际中，某些情况并不需要自旋锁，但是仍然需要关闭内核抢占。最频繁出现的情况就是每个处理器上的数据。如果数据对每个处理器是唯一的，那么，这样的数据可能就不需要使用锁来保护，因为数据只能被一个处理器访问。如果自旋锁没有被持有，内核又是抢占式的，那么一个新调度的任务就可能访问同一个变量。</p><p>为了解决这个问题，可以通过preempt_disable()禁止内核抢占。这是一个可以嵌套调用的函数，可以调用任意次。每次调用都必须有一个相应的preempt_enable()调用。当最后一次preempt_enable()被调用后，内核抢占才重新启用。</p><p>抢占计数存放着被持有锁的数量和preempt_disable()的调用次数，如果计数是0，那么内核可以进行枪占；如果为1或更大的值，那么，内核就不会进行抢占。</p><p>preempt_disable() 和 preempt_enable()实现比较简单，此处不在分析。</p><h2 id="顺序和屏障"><a href="#顺序和屏障" class="headerlink" title="顺序和屏障"></a>顺序和屏障</h2><p>当处理多处理器之间或硬件设备之间的同步问题时，有时需要在你的程序代码中以指定的顺序发出读内存和写内存指令。在和硬件交互时，时常需要确保一个给定的读操作发生在其他读或写操作之前。另外，在多处理器上，可能需要按写数据的顺序读数据。但是编译器和处理器为了提高效率，可能对读和写程序排序（x86处理器不会这样做）。</p><p>不过，所有可能重新排序和写的处理器提供了机器指令来确保顺序要求。同样也可以指示编译器不要对给定点周围的指令序列进行重新排序。这些确保顺序的指令称为屏障（barriers）。</p><p>rmb()方法提供了一个“读”内存屏障，它确保跨越rmb()的载入动作不会发生重排序。</p><p>wmb()方法提供了一个“写”内存屏障，功能和rmb()类似，区别仅仅是它是针对存储而非载入——它确保跨越屏障的存储不发生重排序。</p><p>mb()方法既提供了读屏障也提供了写屏障。载入和存储动作都不会跨越屏障重排序。</p><p>read_barrier_depends()是rmb()的变种，它提供了一个读屏障，但是仅仅是针对后续读操作所依靠的那些载入。因为屏障后的读操作依赖于屏障前的读操作，因此该屏障确保屏障前的读操作在屏障后的读操作之前完成。</p><p>宏smp_rmb()、smp_wmb()、smp_mb()和smp_read_barrier_depends()提供了一个有用的优化。在SMP内核中它们被定义成常用的内存屏障，而在单处理机内核中，它们被定义成编译器的屏障。</p><p>barrier()方法可以防止编译器跨屏障对载入或存储操作进行优化。编译器不会重新组织存储或载入操作，而防止改变C代码的效果和现有数据的依赖关系。但是，它不知道在当前上下文之外会发生什么事。</p><p><strong>注意</strong>，对于不同的体系结构，屏障的实际效果差别很大。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs-2.29/as/index.html">GNU Assembler (GAS)手册</a></p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/38695058/what-long-0xxxxxxxxx-stands-for-in-asm">What .long 0xXXXXXXXX stands for in asm?</a></p><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E26502_01/html/E28388/toc.html">x86 Assembly Language Reference Manual</a></p><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangxinrun/article/details/5843393">lock指令</a></p><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zacklin/article/details/7445442">原子操作与 x86 上的 lock 指令前缀</a></p><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/ture010love/article/details/7663008">Linux 内核 LOCK_PREFIX 的含义</a></p><p><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/X86_Assembly/Shift_and_Rotate">X86 Assembly/Shift and Rotate</a></p><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南</a></p><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/del/archive/2010/04/16/1713886.html">学 Win32 汇编</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E9%94%81/" rel="tag"># 锁</a> <a href="/tags/%E5%AE%8C%E6%88%90%E5%8F%98%E9%87%8F/" rel="tag"># 完成变量</a> <a href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag"># 信号量</a> <a href="/tags/%E4%BA%92%E6%96%A5%E4%BD%93/" rel="tag"># 互斥体</a> <a href="/tags/%E9%A1%BA%E5%BA%8F%E9%94%81/" rel="tag"># 顺序锁</a> <a href="/tags/%E5%86%85%E6%A0%B8%E5%B1%8F%E9%9A%9C/" rel="tag"># 内核屏障</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E5%86%85%E6%A0%B8/Linux-RCU%E9%94%81%E6%9C%BA%E5%88%B6.html" rel="prev" title="Linux RCU锁机制"><i class="fa fa-chevron-left"></i> Linux RCU锁机制</a></div><div class="post-nav-item"> <a href="/Linux%E5%86%85%E6%A0%B8/Linux-Namespace%E7%AE%80%E4%BB%8B.html" rel="next" title="Linux Namespace简介">Linux Namespace简介<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "Linux内核/Linux-内核同步方式及原理.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>