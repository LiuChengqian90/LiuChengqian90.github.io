---
title: 分析数据结构中的各种树
date: 2019-09-01 20:57:52
categories:
tags:
  - 树
  - 
typora-root-url: ../../../source
---

## 树

### 定义

树是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。具有以下特点：

- 每个结点有零个或多个子结点；
- 没有父结点的结点称为根结点；
- 每一个非根结点有且只有一个父结点；
- 除了根结点外，每个子结点可以分为多个不相交的子树；

空集合也是树，称为空树。空树中没有结点。

### 相关定义

- 结点的度：一个结点含有的子树的个数称为该结点的度；
- **叶结点或终端结点**：度为0的结点称为叶结点；
- 非终端结点或分支结点：度不为0的结点；
- 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；
- 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；
- 兄弟结点：具有相同父结点的结点互称为兄弟结点；
- 树的度：一棵树中，最大的结点的度称为树的度；
- 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
- **树的高度或深度**：树中结点的最大层次；
- 堂兄弟结点：双亲在同一层的结点互为堂兄弟；
- 结点的祖先：从根到该结点所经分支上的所有结点；
- 子孙：以某结点为根的子树中任一结点都称为该结点的子孙；
- 森林：由m（m>=0）棵互不相交的树的集合称为森林。

一个普通的树结构如下

![Tree](/images/分析数据结构中的各种树/Tree.png)

## 二叉树

### 定义

**二叉树**是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

### 特点

- 每个结点**最多**有两颗子树，所以二叉树中不存在度大于2的结点。
- 左子树和右子树是有**顺序**的，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是**左子树**还是**右子树**。

### 性质

- 在二叉树的第i层上最多有2i-1 个结点 。（i>=1）

- 二叉树中如果深度为k,那么最多有2k-1个结点。(k>=1）

- n0=n2+1，n0表示度数为0的结点数，n2表示度数为2的结点数。

- 在**完全二叉树**中，具有n个结点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。

- 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：

  ```
  (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;
  (2) 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；
  (3) 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。
  ```

### 斜树

所有的结点都**只有**左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。

### 完美二叉树

在一棵二叉树中，如果所有分支结点**都存在左子树和右子树**，并且所有叶子**都在同一层**上，这样的二叉树称为完美二叉树，也叫做**满二叉树**。

其特点如下：

1. 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。
2. 非叶子结点的度一定是2。
3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

![Perfect-binary-tree](/images/分析数据结构中的各种树/Perfect-binary-tree.png)

### 完全二叉树

对一棵具有n个结点的二叉树**按层编号**，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

![Complete-binary-tree](/images/分析数据结构中的各种树/Complete-binary-tree.png)

**特点**：

1. 叶子结点只能出现在最下层和次下层。
2. 最下层的叶子结点集中在树的左部。
3. 倒数第二层若存在叶子结点，一定在右部连续位置。
4. 如果结点度为1，则该结点只有左孩子，即没有右子树。
5. 同样结点数目的二叉树，完全二叉树深度最小。

**满二叉树一定是完全二叉树，但反过来不一定成立。**

### 完满二叉树

所有非叶子结点的度都是2的树叫做完满二叉树。（**只要你有孩子，你就必然是有两个孩子。**）

![Full-binary-tree](/images/分析数据结构中的各种树/Full-binary-tree.png)

**三者总结**

| **完美二叉树** | Perfect Binary Tree       | Every node except the leaf nodes have two children and every level (last level too) is completely filled. **除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。** |
| -------------- | ------------------------- | ------------------------------------------------------------ |
| **完全二叉树** | Complete Binary Tree      | Every level except the last level is completely filled and all the nodes are left justified. **除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。** |
| **完满二叉树** | Full/Strictly Binary Tree | Every node except the leaf nodes have two children. **除了叶子结点之外的每一个结点都有两个孩子结点。** |

- 完美(Perfect)二叉树一定是完全(Complete)二叉树，但完全(Complete)二叉树不一定是完美(Perfect)二叉树。
- 完美(Perfect)二叉树一定是完满(Full)二叉树，但完满(Full)二叉树不一定是完美(Perfect)二叉树。
- 完全(Complete)二叉树可能是完满(Full)二叉树，完满(Full)二叉树也可能是完全(Complete)二叉树。
- 既是完全(Complete)二叉树又是完满(Full)二叉树也不一定就是完美(Perfect)二叉树。

### 存储

#### 顺序存储

用一组连续的存储单元存放二叉树中的结点。按照二叉树结点**从上至下、从左到右**的顺序存储。

对于一般的二叉树，如果仍按从上至小、从左到右的顺序将树中的结点顺序存储在一维数组中，则数组元素下标之间的关系不能反映二叉树中结点之间的逻辑关系，**只有添加一些并不存在的空结点**，使之成为一棵完全二叉树的形式，然后用一维数组顺序存储。显然，这种存储对于需增加许多空结点才能将一棵二叉树改造成为一棵完全二叉树的存储时，会造成空间的大量浪费，不宜用顺序存储结构。

完全二叉树存储方式

![Complete-array](/images/分析数据结构中的各种树/Complete-array.png)

非完全二叉树存储方式

![Not-complete-array](/images/分析数据结构中的各种树/Not-complete-array.png)

灰色部分表示结点不存在，可以看出，连续存储方式出现了内存空白。

这种方式的存储对于右斜树而言，浪费的内存空间更大。

#### 链式存储

用链式结构来表示一棵二叉树，即用链指针来指示其元素的逻辑关系。（二叉链表）

由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。

定义代码如下：

```c
typedef struct BiTNode{
    TElemType data;//数据
    struct BiTNode *lchild, *rchild;//左右孩子指针
} BiTNode, *BiTree;
```

结构如图所示

![Binary-linked-list-with-root](/images/分析数据结构中的各种树/Binary-linked-list-with-root.png)

![Binary-linked-list](/images/分析数据结构中的各种树/Binary-linked-list.png)

### 遍历

**二叉树的遍历**是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。

二叉树的访问次序可以分为四种：

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

#### 前序遍历

从二叉树的**根结点**出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。

其访问顺序为：根结点->左子树->右子树

![Traversing](/images/分析数据结构中的各种树/Traversing.png)

1. 从根结点出发，此为第一个到达的结点，输出；
2. 左子树遍历是否遍历完成，无则跳到3；右子树是否遍历完成，无则跳到4；叶子结点跳到5；
3. 输出左子树结点，此时，左子树可以理解为“根”，返回2；
4. 输出右子树结点，此时，右子树可以理解为“跟”，返回2；
5. 返回父结点，跳到2；
6. 全遍历完成，退出。

因此，前序遍历的输出为

```c
A
A->B
A->B->D
A->B->D->E
A->B->D->E->G
A->B->D->E->G->C
A->B->D->E->G->C->F
A->B->D->E->G->C->F->H
A->B->D->E->G->C->F->H->I
```

实现代码如下

```c
/*二叉树的前序遍历递归算法*/
void PreOrderTraverse(BiTree T)
{
    if(T==NULL)
	      return;
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
    PreOrderTraverse(T->lchild);    /*再先序遍历左子树*/
    PreOrderTraverse(T->rchild);    /*最后先序遍历右子树*/
}
```

非递归版本

```c
void PreOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S = CreatStack(MAX_SIZE);    //创建并初始化堆栈S
    while(T || !IsEmpty(S))
    {
        while(T)        //一直向左并将沿途节点访问（打印）后压入堆栈 
        {
            printf("%d\n", T->Data);
            Push(S, T);
            T = T->Left;
        }
        if (!IsEmpty(S))
        {
            T = Pop(S);    //节点弹出堆栈
            T = T->Right;  //转向右子树
        }
    }
}
```

#### 中序遍历

对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找最左边的结点i，其必然为叶子，然后遍历i的父结点，再遍历i的兄弟结点。随着递归的逐渐出栈，最终完成遍历。

其访问顺序为：左子树->根结点->右子树

对于上图其输出顺序为

```C
D
D->B
D->B->G
D->B->G->E
D->B->G->E->A
D->B->G->E->A->C
D->B->G->E->A->C->H
D->B->G->E->A->C->H->F
D->B->G->E->A->C->H->F->I
```

其实现代码如下

```c
/*二叉树的中序遍历递归算法*/
void InOrderTraverse(BiTree T)
{
    if(T==NULL)
		    return;
    InOrderTraverse(T->lchild); /*中序遍历左子树*/
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
    InOrderTraverse(T->rchild); /*最后中序遍历右子树*/
}
```

非递归版本

```c
void InOrderTraversal(BinTree BT)
{ 
    BinTree T = BT;
    Stack S = CreatStack(MaxSize); //创建并初始化堆栈S
    while(T || !IsEmpty(S))
　　{
    　　while(T)    //一直向左并将沿途节点压入堆栈
    　　{ 
       　　 Push(S,T);
        　　T = T->Left;
    　　}
    　　if(!IsEmpty(S))
    　　{
       　　 T = Pop(S);                //节点弹出堆栈
       　　 printf("%d\n", T->Data);    //（访问） 打印结点
      　　  T = T->Right;              //转向右子树
    　　}
　　}
}
```

#### 后序遍历

对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找**最左边的结点**i，其必然为叶子，然后遍历i的兄弟结点，再遍历i的父结点。随着递归的逐渐出栈，最终完成遍历。

其访问顺序为：左子树->右子树->根结点

对于上图其输出顺序为

```c
D
D->G
D->G->E
D->G->E->B
D->G->E->B->H
D->G->E->B->H->I
D->G->E->B->H->I->F
D->G->E->B->H->I->F->C
D->G->E->B->H->I->F->C->A
```

其实现代码如下

```c
/*二叉树的后序遍历递归算法*/
void PostOrderTraverse(BiTree T)
{
    if(T==NULL)
		    return;
    PostOrderTraverse(T->lchild);   /*先后序遍历左子树*/
    PostOrderTraverse(T->rchild);   /*再后续遍历右子树*/
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
}
```

非递归版本

```c
void PostOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S1 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S1
    Stack S2 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S2   
    while(T || !IsEmpty(S1))
    {
        while(T)        //一直向右并将沿途节点访问（压入S2）后压入堆栈S1 
        {
            Push(S2, T);
            Push(S1, T);
            T = T->Right;
        }
        if (!IsEmpty(S1))
        {
            T = Pop(S1);    //节点弹出堆栈
            T = T->Left;  //转向左子树
        }
    }
    while(!IsEmpty(S2))    //访问（打印）S2中元素
    {
        T = Pop(S2);
        printf("%d\n", T->Data);
    }          
}
```

#### 层序遍历

层次遍历就是按照树的层次自上而下、自左而右的遍历二叉树。

实现代码如下

```c
#include <deque>
using namespace std;

template<typename T, typename VST >
void levelIterationTraverse(BiNodePos(T) x, VST& visit)
{
    deque<BiNodePos(T)> q;
    q.push_back(x);
    while (!q.empty())
    {
        x = q.front(); q.pop_front();
        visit(x.data);
        if (x->lChild) q.push_back(x->lChild);
        if (x->rChild) q.push_back(x->rChild);
    }
}//O(n)
```

## 二叉查找树

二叉排序树

https://www.jianshu.com/p/912357993486

https://www.cnblogs.com/shixiangwan/p/7530015.html

## AVL树

平衡二叉树

## 红黑树

## B树

## B+树

## 字典树

## 后缀树

## 广义后缀树

## 哈夫曼树

[https://blog.csdn.net/csdn_aiyang/article/details/84977814#%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91](https://blog.csdn.net/csdn_aiyang/article/details/84977814#第四节：最优二叉树——哈夫曼树)

## 树与森林

## 优秀资料

[深入学习二叉树(一) 二叉树基础](https://www.jianshu.com/p/bf73c8d50dc2)

[常用数据结构——树](https://www.jianshu.com/p/912357993486)

[完美二叉树, 完全二叉树和完满二叉树](https://www.cnblogs.com/idorax/p/6441043.html)

[二叉树的遍历](https://www.cnblogs.com/llhthinker/p/4747962.html)