---
title: 分析数据结构中的各种树
date: 2019-09-01 20:57:52
categories:
tags:
  - 树
  - 
typora-root-url: ../../../source
---

## 树

### 定义

树是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。具有以下特点：

- 每个结点有零个或多个子结点；
- 没有父结点的结点称为根结点；
- 每一个非根结点有且只有一个父结点；
- 除了根结点外，每个子结点可以分为多个不相交的子树；

空集合也是树，称为空树。空树中没有结点。

### 相关定义

- 结点的度：一个结点含有的子树的个数称为该结点的度；
- **叶结点或终端结点**：度为0的结点称为叶结点；
- 非终端结点或分支结点：度不为0的结点；
- 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；
- 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；
- 兄弟结点：具有相同父结点的结点互称为兄弟结点；
- 树的度：一棵树中，最大的结点的度称为树的度；
- 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
- **树的高度或深度**：树中结点的最大层次；
- 堂兄弟结点：双亲在同一层的结点互为堂兄弟；
- 结点的祖先：从根到该结点所经分支上的所有结点；
- 子孙：以某结点为根的子树中任一结点都称为该结点的子孙；
- 森林：由m（m>=0）棵互不相交的树的集合称为森林。

一个普通的树结构如下

![Tree](/images/分析数据结构中的各种树/Tree.png)

## 二叉树

### 定义

**二叉树**是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

### 特点

- 每个结点**最多**有两颗子树，所以二叉树中不存在度大于2的结点。
- 左子树和右子树是有**顺序**的，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是**左子树**还是**右子树**。

### 性质

- 在二叉树的第i层上最多有2i-1 个结点 。（i>=1）

- 二叉树中如果深度为k,那么最多有2k-1个结点。(k>=1）

- n0=n2+1，n0表示度数为0的结点数，n2表示度数为2的结点数。

- 在**完全二叉树**中，具有n个结点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。

- 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：

  ```
  (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;
  (2) 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；
  (3) 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。
  ```

### 斜树

所有的结点都**只有**左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。

### 完美二叉树

在一棵二叉树中，如果所有分支结点**都存在左子树和右子树**，并且所有叶子**都在同一层**上，这样的二叉树称为完美二叉树，也叫做**满二叉树**。

其特点如下：

1. 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。
2. 非叶子结点的度一定是2。
3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

![Perfect-binary-tree](/images/分析数据结构中的各种树/Perfect-binary-tree.png)

### 完全二叉树

对一棵具有n个结点的二叉树**按层编号**，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

![Complete-binary-tree](/images/分析数据结构中的各种树/Complete-binary-tree.png)

**特点**：

1. 叶子结点只能出现在最下层和次下层。
2. 最下层的叶子结点集中在树的左部。
3. 倒数第二层若存在叶子结点，一定在右部连续位置。
4. 如果结点度为1，则该结点只有左孩子，即没有右子树。
5. 同样结点数目的二叉树，完全二叉树深度最小。

**满二叉树一定是完全二叉树，但反过来不一定成立。**

### 完满二叉树

所有非叶子结点的度都是2的树叫做完满二叉树。（**只要你有孩子，你就必然是有两个孩子。**）

![Full-binary-tree](/images/分析数据结构中的各种树/Full-binary-tree.png)

**三者总结**

| **完美二叉树** | Perfect Binary Tree       | Every node except the leaf nodes have two children and every level (last level too) is completely filled. **除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。** |
| -------------- | ------------------------- | ------------------------------------------------------------ |
| **完全二叉树** | Complete Binary Tree      | Every level except the last level is completely filled and all the nodes are left justified. **除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。** |
| **完满二叉树** | Full/Strictly Binary Tree | Every node except the leaf nodes have two children. **除了叶子结点之外的每一个结点都有两个孩子结点。** |

- 完美(Perfect)二叉树一定是完全(Complete)二叉树，但完全(Complete)二叉树不一定是完美(Perfect)二叉树。
- 完美(Perfect)二叉树一定是完满(Full)二叉树，但完满(Full)二叉树不一定是完美(Perfect)二叉树。
- 完全(Complete)二叉树可能是完满(Full)二叉树，完满(Full)二叉树也可能是完全(Complete)二叉树。
- 既是完全(Complete)二叉树又是完满(Full)二叉树也不一定就是完美(Perfect)二叉树。

### 存储

#### 顺序存储

用一组连续的存储单元存放二叉树中的结点。按照二叉树结点**从上至下、从左到右**的顺序存储。

对于一般的二叉树，如果仍按从上至小、从左到右的顺序将树中的结点顺序存储在一维数组中，则数组元素下标之间的关系不能反映二叉树中结点之间的逻辑关系，**只有添加一些并不存在的空结点**，使之成为一棵完全二叉树的形式，然后用一维数组顺序存储。显然，这种存储对于需增加许多空结点才能将一棵二叉树改造成为一棵完全二叉树的存储时，会造成空间的大量浪费，不宜用顺序存储结构。

完全二叉树存储方式

![Complete-array](/images/分析数据结构中的各种树/Complete-array.png)

非完全二叉树存储方式

![Not-complete-array](/images/分析数据结构中的各种树/Not-complete-array.png)

灰色部分表示结点不存在，可以看出，连续存储方式出现了内存空白。

这种方式的存储对于右斜树而言，浪费的内存空间更大。

#### 链式存储

用链式结构来表示一棵二叉树，即用链指针来指示其元素的逻辑关系。（二叉链表）

由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。

定义代码如下：

```c
typedef struct BiTNode{
    TElemType data;//数据
    struct BiTNode *lchild, *rchild;//左右孩子指针
} BiTNode, *BiTree;
```

结构如图所示

![Binary-linked-list-with-root](/images/分析数据结构中的各种树/Binary-linked-list-with-root.png)

![Binary-linked-list](/images/分析数据结构中的各种树/Binary-linked-list.png)

### 遍历

**二叉树的遍历**是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。

二叉树的访问次序可以分为四种：

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

#### 前序遍历

从二叉树的**根结点**出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。

其访问顺序为：根结点->左子树->右子树

![Traversing](/images/分析数据结构中的各种树/Traversing.png)

1. 从根结点出发，此为第一个到达的结点，输出；
2. 左子树遍历是否遍历完成，无则跳到3；右子树是否遍历完成，无则跳到4；叶子结点跳到5；
3. 输出左子树结点，此时，左子树可以理解为“根”，返回2；
4. 输出右子树结点，此时，右子树可以理解为“跟”，返回2；
5. 返回父结点，跳到2；
6. 全遍历完成，退出。

因此，前序遍历的输出为

```c
A
A->B
A->B->D
A->B->D->E
A->B->D->E->G
A->B->D->E->G->C
A->B->D->E->G->C->F
A->B->D->E->G->C->F->H
A->B->D->E->G->C->F->H->I
```

实现代码如下

```c
/*二叉树的前序遍历递归算法*/
void PreOrderTraverse(BiTree T)
{
    if(T==NULL)
	      return;
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
    PreOrderTraverse(T->lchild);    /*再先序遍历左子树*/
    PreOrderTraverse(T->rchild);    /*最后先序遍历右子树*/
}
```

非递归版本

```c
void PreOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S = CreatStack(MAX_SIZE);    //创建并初始化堆栈S
    while(T || !IsEmpty(S))
    {
        while(T)        //一直向左并将沿途节点访问（打印）后压入堆栈 
        {
            printf("%d\n", T->Data);
            Push(S, T);
            T = T->Left;
        }
        if (!IsEmpty(S))
        {
            T = Pop(S);    //节点弹出堆栈
            T = T->Right;  //转向右子树
        }
    }
}
```

#### 中序遍历

对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找最左边的结点i，其必然为叶子，然后遍历i的父结点，再遍历i的兄弟结点。随着递归的逐渐出栈，最终完成遍历。

其访问顺序为：左子树->根结点->右子树

对于上图其输出顺序为

```C
D
D->B
D->B->G
D->B->G->E
D->B->G->E->A
D->B->G->E->A->C
D->B->G->E->A->C->H
D->B->G->E->A->C->H->F
D->B->G->E->A->C->H->F->I
```

其实现代码如下

```c
/*二叉树的中序遍历递归算法*/
void InOrderTraverse(BiTree T)
{
    if(T==NULL)
		    return;
    InOrderTraverse(T->lchild); /*中序遍历左子树*/
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
    InOrderTraverse(T->rchild); /*最后中序遍历右子树*/
}
```

非递归版本

```c
void InOrderTraversal(BinTree BT)
{ 
    BinTree T = BT;
    Stack S = CreatStack(MaxSize); //创建并初始化堆栈S
    while(T || !IsEmpty(S))
　　{
    　　while(T)    //一直向左并将沿途节点压入堆栈
    　　{ 
       　　 Push(S,T);
        　　T = T->Left;
    　　}
    　　if(!IsEmpty(S))
    　　{
       　　 T = Pop(S);                //节点弹出堆栈
       　　 printf("%d\n", T->Data);    //（访问） 打印结点
      　　  T = T->Right;              //转向右子树
    　　}
　　}
}
```

#### 后序遍历

对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找**最左边的结点**i，其必然为叶子，然后遍历i的兄弟结点，再遍历i的父结点。随着递归的逐渐出栈，最终完成遍历。

其访问顺序为：左子树->右子树->根结点

对于上图其输出顺序为

```c
D
D->G
D->G->E
D->G->E->B
D->G->E->B->H
D->G->E->B->H->I
D->G->E->B->H->I->F
D->G->E->B->H->I->F->C
D->G->E->B->H->I->F->C->A
```

其实现代码如下

```c
/*二叉树的后序遍历递归算法*/
void PostOrderTraverse(BiTree T)
{
    if(T==NULL)
		    return;
    PostOrderTraverse(T->lchild);   /*先后序遍历左子树*/
    PostOrderTraverse(T->rchild);   /*再后续遍历右子树*/
    printf("%c", T->data);  /*显示结点数据，可以更改为其他对结点操作*/
}
```

非递归版本

```c
void PostOrderTraversal(BinTree BT)
{
    BinTree T = BT;
    Stack S1 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S1
    Stack S2 = CreatStack(MAX_SIZE);    //创建并初始化堆栈S2   
    while(T || !IsEmpty(S1))
    {
        while(T)        //一直向右并将沿途节点访问（压入S2）后压入堆栈S1 
        {
            Push(S2, T);
            Push(S1, T);
            T = T->Right;
        }
        if (!IsEmpty(S1))
        {
            T = Pop(S1);    //节点弹出堆栈
            T = T->Left;  //转向左子树
        }
    }
    while(!IsEmpty(S2))    //访问（打印）S2中元素
    {
        T = Pop(S2);
        printf("%d\n", T->Data);
    }          
}
```

#### 层序遍历

层次遍历就是按照树的层次自上而下、自左而右的遍历二叉树。

实现代码如下

```c
#include <deque>
using namespace std;

template<typename T, typename VST >
void levelIterationTraverse(BiNodePos(T) x, VST& visit)
{
    deque<BiNodePos(T)> q;
    q.push_back(x);
    while (!q.empty())
    {
        x = q.front(); q.pop_front();
        visit(x.data);
        if (x->lChild) q.push_back(x->lChild);
        if (x->rChild) q.push_back(x->rChild);
    }
}//O(n)
```

## 二叉查找树

**二叉查找树**（Binary Search Tree），也称为**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- 没有键值相等的节点。

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为O(log n)。

中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望O(log n)，最坏O(n)（数列有序，树退化成线性表）。

### 查找算法

1. 若b是空树，则搜索失败，否则：
2. 若x等于b的根节点的数据域之值，则查找成功；否则：
3. 若x小于b的根节点的数据域之值，则搜索左子树；否则：
4. 查找右子树。

```c
Status SearchBST(BiTree T, KeyType key, BiTree f, BiTree &p) {
    // 在根指针T所指二元查找树中递归地查找其关键字等于key的数据元素，若查找成功，
    // 则指针p指向该数据元素节点，并返回TRUE，否则指针指向查找路径上访问的最后
    // 一个节点并返回FALSE，指针f指向T的双亲，其初始调用值为NULL
    if (!T) { // 查找不成功
        p = f;
        return false;
    } else if (key == T->data.key) { // 查找成功
        p = T;
        return true;
    } else if (key < T->data.key) // 在左子树中继续查找
        return SearchBST(T->lchild, key, T, p);
    else // 在右子树中继续查找
        return SearchBST(T->rchild, key, T, p);
}
```

### 插入节点

1. 若b是空树，则将s所指节点作为根节点插入，否则：
2. 若s->data等于b的根节点的数据域之值，则返回，否则：
3. 若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
4. 把s所指节点插入到右子树中。（**新插入节点总是叶子节点**）



**插入之后，以任一根节点为中心，左边所有值都小于根，右边所有值都大于根。**

```c
/* 当二元搜寻树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回 FALSE */
Status InsertBST(BiTree *T, ElemType e) {
    if (!T) {
        s = new BiTNode;
        s->data = e;
        s->lchild = s->rchild = NULL;
        T = s; // 被插节点*s为新的根结点
    } else if (e.key == T->data.key)
        return false;// 关键字等于e.key的数据元素，返回错误
    if (e.key < T->data.key)
        InsertBST(T->lchild, e);  // 将 e 插入左子树
    else
        InsertBST(T->rchild, e);  // 将 e 插入右子树
    return true;
}
```

### 删除节点

在二叉查找树删去一个结点，分三种情况讨论：

1. 若\*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。

2. 若\*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点\*f的左子树（当*p是左子树）或右子树（当\*p是右子树）即可，作此修改也不破坏二叉查找树的特性。

   ![Binary-search-tree-delete-1](/images/分析数据结构中的各种树/Binary-search-tree-delete-1.png)

3. 若\*p结点的**左子树和右子树均不空**。在删去\*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：

   1. 令\*p的左子树为\*f的左/右（依\*p是\*f的左子树还是右子树而定）子树，\*s为\*p左子树的最右下的结点，而\*p的右子树为\*s的右子树；
   2. 令\*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代\*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。

   ![Binary-search-tree-delete-2](/images/分析数据结构中的各种树/Binary-search-tree-delete-2.png)

   **中心思想**：以删除的节点为中心，找到左树中最大的（最右节点）进行替代；或者右树中最小的（最左节点）替代。

   ```c
   Status DeleteBST(BiTree *T, KeyType key) {
       // 若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回
       // TRUE；否则返回FALSE
       if (!T)
           return false; //不存在关键字等于key的数据元素
       else {
           if (key == T->data.key)   //   找到关键字等于key的数据元素
               return Delete(T);
           else if (key < T->data.key)
               return DeleteBST(T->lchild, key);
           else
               return DeleteBST(T->rchild, key);
       }
   }
   
   Status Delete(BiTree *&p) {
       // 该节点为叶子节点，直接删除
       BiTree *q, *s;
       if (!p->rchild && !p->lchild) {
           delete p;
           p = NULL;  // Status Delete(BiTree *&p) 要加&才能使P指向NULL
       } else if (!p->rchild) { // 右子树空则只需重接它的左子树
           q = p->lchild;
           /*
           p->data = p->lchild->data;
           p->lchild=p->lchild->lchild;
           p->rchild=p->lchild->rchild;
           */
           p->data = q->data;
           p->lchild = q->lchild;
           p->rchild = q->rchild;
           delete q;
       } else if (!p->lchild) { // 左子树空只需重接它的右子树
           q = p->rchild;
           /*
           p->data = p->rchild->data;
           p->lchild=p->rchild->lchild;
           p->rchild=p->rchild->rchild;
           */
           p->data = q->data;
           p->lchild = q->lchild;
           p->rchild = q->rchild;
           delete q;
       } else { // 左右子树均不空
           q = p;
           s = p->lchild;
           while (s->rchild) {
               q = s;
               s = s->rchild;
           } // 转左，然后向右到尽头
           p->data = s->data;  // s指向被删结点的“前驱”
           if (q != p)
               q->rchild = s->lchild;  // 重接*q的右子树
           else
               q->lchild = s->lchild;  // 重接*q的左子树
           delete s;
       }
       return true;
   }
   ```

### 遍历

可参考本章“二叉树”一节的四种遍历。

### 构造一棵二叉查找树

用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为O(n<sup>2</sup>)。

例如，若该组数值已经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树。自平衡二叉查找树可以克服上述缺点，其时间复杂度为O(*n*log *n*)。一方面，树排序的问题使得CPU Cache性能较差，特别是当节点是动态内存分配时。而堆排序的CPU Cache性能较好。另一方面，树排序是最优的增量排序（incremental sorting）算法，保持一个数值序列的有序性。

树的构造其核心为对值的插入，“插入节点”一节已实现。

### 二叉查找树的性能



### 二叉查找树的优化



## AVL树

平衡二叉树

## 红黑树

## B树

## B+树

## 字典树

## 后缀树

## 广义后缀树

## 哈夫曼树

[https://blog.csdn.net/csdn_aiyang/article/details/84977814#%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91](https://blog.csdn.net/csdn_aiyang/article/details/84977814#第四节：最优二叉树——哈夫曼树)

## 树与森林

## 优秀资料

[深入学习二叉树(一) 二叉树基础](https://www.jianshu.com/p/bf73c8d50dc2)

[常用数据结构——树](https://www.jianshu.com/p/912357993486)

[完美二叉树, 完全二叉树和完满二叉树](https://www.cnblogs.com/idorax/p/6441043.html)

[二叉树的遍历](https://www.cnblogs.com/llhthinker/p/4747962.html)

[二叉搜索树](https://zh.wikipedia.org/wiki/二元搜尋樹)