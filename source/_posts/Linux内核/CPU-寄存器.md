---
title: CPU 寄存器
date: 2017-09-09 00:46:05
categories: Linux内核
tags:
  - 寄存器
  - CPU
typora-root-url: ../../../source
---

　　寄存器是中央处理器内的组成部分，是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。

　　寄存器是集成电路中非常重要的一种存储单元，通常由[D触发器](https://baike.baidu.com/item/D%E8%A7%A6%E5%8F%91%E5%99%A8)组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。

　　寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。寄存器是内存阶层中的最顶端，也是系统获得操作资料的最快速途径。寄存器通常都是以他们可以保存的位元数量来估量，举例来说，一个“8位元寄存器”或“32位元寄存器”。

## 16位寄存器

以8086（16位处理器，14个寄存器）为例。按其用途可分为：

- 通用寄存器（8个）：

  - 数据寄存器

    AH&AL=AX(accumulator)：累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外,所有的[I/O指令](https://baike.baidu.com/item/I%252FO%E6%8C%87%E4%BB%A4)都使用这一寄存器与外界设备传送数据。

    BH&BL=BX(base)：基址寄存器，常用于地址索引。

    CH&CL=CX(count)：计数寄存器，常用于计数，常用于保存计算值。如在[移位指令](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4),循环(loop)和串处理指令中用作隐含的计数器。

    DH&DL=DX(data)：数据寄存器，常用于数据传递。

    这4个16位的寄存器可以分为高8位：AH，BH，CH，DH。以及低8位：AL，BL，CL，DL。这2组8位寄存器可以分别寻址，并单独使用。

  - 指针寄存器和变址寄存器：

    SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置。

    BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置。

    SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针。

    DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。

    这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。

- 指令指针（1个）：

  指令指针（Instruction Pointer，IP）是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。

  BIU是80x86微处理系统芯片中的两个基本功能部件之一，中文为总线接口部件（Bus Interface Unit）。BIU是和总线打交道的接口部件，它根据执行单元(Execution Unit)的请求，执行8086 CPU 对存储器或 I/O 接口的总线操作，完成数据传送，BIU由指令队列缓冲器，16位指令指针寄存器CS、DS、SS和ES，地址产生器和段寄存器，总线控制逻辑等部分构成。

- 标志寄存器（1个）：

  标志寄存器（Flags Register，FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。

  在FR中有意义的有9位，其中6位是状态位，3位是控制位。
  ![16位标志寄存器](/images/CPU 寄存器/16位标志寄存器.jpg)

| 标志                        | 描述                                       |
| ------------------------- | ---------------------------------------- |
| CF(carry flag)            | 进位标志，主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 |
| PF(parity flag)           | 奇偶标志，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 |
| AF(adjust flag)           | 辅助进位标志，存在下列情况值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。 |
| ZF(zero flag)             | 零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 |
| SF(sign flag)             | 符号标志，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。 |
| TF(trap flag)             | 跟踪标志，可用于程序调试。TF标志没有专门的指令来设置或清除。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。 |
| IF(interrupt enable flag) | 中断允许标志，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 |
| DF(direction flag)        | 方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。        |
| OF(overflow flag)         | 溢出标志，用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 |

- 段寄存器（4个）：
  - CS（Code Segment）：代码段寄存器
  - DS（Data Segment）：数据段寄存器 
  - SS（Stack Segment）：堆栈段寄存器
  - ES（Extra Segment）：附加段寄存器

当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻　址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。

备注：由于所讲的是16位cpu，IP寄存器的位数为16，即：偏移地址为16位，2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。

## 32位寄存器

32位CPU 寄存器及数据结构图：

![32位CPU 寄存器及数据结构](/images/CPU 寄存器/32位CPU 寄存器及数据结构.png)

- 通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI

  - 尽管这8个通用寄存器大多时候是通用的，可以用作任何用途，但是在某些情况下，他们也有隐含的用法。比如ECX、ESI和EDI在串循环操作中分别用作计数器、源和目标。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。
  - EAX, EBX, ECX, EDX都可以作为32位寄存器、16位寄存器或者8位寄存器使用。用法类似16位数据寄存器。
  - EBP和ESP是32位寄存器，也可作为16位寄存器BP, SP使用，常用于椎栈操作。
  - EDI和ESI常用于串操作，EDI用于寻址目标数据串，ESI用于寻址源数据串。

- 标志寄存器（1个）：EFLAGS

  控制任务状态和模式切换、中断处理、指令追踪和访问权限控制。寄存器中的标志位需要特权指令代码才可以修改(特权指令:运行在内核态下的代码)。

  在16位标志寄存器的基础上增加了几个标志：

![EFLAGS](/images/CPU 寄存器/EFLAGS.jpg)

 

| 标志                                  | 描述                                       |
| ----------------------------------- | ---------------------------------------- |
| IOPL(I/O privilege level field)     | 指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 |
| NT(Nested task flag)                | 控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。    |
| RF(Resume flag)                     | 控制处理器对调试异常的响应。                           |
| VM(Virtual-8086 mode flag)          | 置1以允许虚拟8086模式，清除则返回保护模式。                 |
| AC(Alignment check flag)            | 该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。 |
| VIF(Virtual interrupt flag)         | 该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions) |
| VIP(Virtual interrupt pending flag) | 该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。(Software sets and clears this flag; the processor only reads it)与VIF标志结合使用。 |
| ID(Identification flag)             | 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。          |

 

- 控制寄存器（Control Register）（5个）：CR0-CR4

  控制寄存器决定处理器的操作模式和当前执行任务的一些特征。

  CR0：控制系统的工作模式和处理器的状态；x86\_32的CR0为32bit。X86\_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit4其他所有位都是可读可写的。


![控制寄存器](/images/CPU 寄存器/控制寄存器.jpg)

| 标志                        | 描述                                      |
| ------------------------- | --------------------------------------- |
| PE(Protected-Mode Enable) | PE=0，表示CPU处于实模式；PE=1表CPU处于保护模式，并使用分段机制。 |
| MP                        | 协处理器监视标志位                               |
| EM                        | 该位表明是否需要仿真协处理器的功能                       |
| TS                        | 每当任务切换时就设置该位，并且在解释协处理器指令之前测试该位          |
| ET                        | 扩展类型。设置有效位时，支持 ntel 387 DX 数学协处理器指令     |
| NE                        | 数字错误标志位(与浮点协处理器共同使用)                    |
| WP                        | 写保护                                     |
| AM                        | 对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)           |
| NW                        | 直写无效(直写：高速缓存中的数据始终保持与主存储器中数据匹配，也叫做通写 )  |
| CD                        | cache 缺失设置位                             |
| PG(Paging Enable)         | 控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。        |

​	CR1：保留

​	CR2：存放发生页错误时的虚拟地址

![CR2](/images/CPU 寄存器/CR2.jpg)

 	CR3：用来存放最高级页目录地址(物理地址），各级页表项中存放的也是物理地址。

![CR3](/images/CPU 寄存器/CR3.jpg)

| 标志                            | 描述                                       |
| ----------------------------- | ---------------------------------------- |
| PWT(Page-Level Writethrough)  | 控制cache采取直写还是回写的策略。当设置清空时，回写有效。当置位时，直写有效 |
| PCD(Page-Level Cache Disable) | PCD=1，表示最高目录表不可缓存，PCD=0，相反               |

- Figure 3-4中，不使用PAE技术，有两层页表。最高层为页目录有1024项，占用4KB。page_directory_table base address为物理地址，指向4KB对齐的页目录地址。

- Figure 3-5中，使用PAE技术，三层页表寻址。最高层为页目录指针，4项，占用32B空间。所以  page_directory_table base address为27位，指向32B对齐的页目录指针表。  ​


  CR4：一些结构的扩展。表明对于特定的处理器和操作系统执行支持。

![CR4](/images/CPU 寄存器/CR4.jpg)

| 标志                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| VME(virtual 8086 mode extension)         | 虚拟8086模式扩展位。VME=1，允许虚拟8086扩展，即允许8086模式和虚拟8086中断。VME=0，禁止虚拟8086模式扩展。 |
| PVI(protected mode virtual interrupts)   | 保护模式虚拟中断位。PVI=1，允许保护模式虚拟中断。PVI=0，禁止保护模式虚拟中断。 |
| TSD(time stamp disable)                  | 禁止RDTSC指令位。TSD=0，则允许RDTSC（读时间标志计算器）指令在任何特权级上执行。TSD=1，仅允许RDTSC指令在0级特权级上执行，否则将发生一般保护模式异常。 |
| DE(debugging extensions)                 | 调试扩展位。DE=1，允许输入/输出断点。DE=0，不支持输入/输出断点。    |
| PSE(page size extensions)                | 允许页容量大小扩展位。PSE=1，允许每页容量为4MB。PSE=0，只允许每页容量为4KB。 |
| PAE(physical address extension)          | 允许物理地址扩展位。PAE=1，允许采用32位以上的物理地址（包括32位和64位地址）。PAE=0，只允许采用32位物理地址。 |
| MCE(machine check exception)             | 允许机器检查异常位。MCE=1，允许机器检查异常。MCE=0，不允许机器检查异常。 |
| PGE(Page-Global Enable)                  | 将PGE设置为1可启用全局页面机制。将该位清除为0将禁用该机制。当启用PGE时，系统软件可以将页面转换层级的最低级别的全局页面（G）位设置为1，表示页面翻译是全局的。当页面翻译表基地址（CR3）更新时，标记为全局的页面翻译在TLB中不会失效。 |
| PCE(Performance-Monitoring Counter Enable) | 将PCE设置为1允许在任何权限级别运行的软件使用RDPMC指令。软件使用RDPMC指令读取性能监视MSRs PerfCtrn。 将PCE清除为0仅允许最特权的软件（CPL = 0）使用RDPMC指令。 |
| OSFXSR(FXSAVE/FXRSTOR Support)           | 设置为1，以使能256位和128位媒体指令。当该位设置为1时，它还指示系统软件使用FXSAVE和FXRSTOR指令来保存和恢复x87,64位介质和128位介质指令的处理器状态。 |
| OSXMMEXCPT(Unmasked Exception Support)   | 当系统软件支持SIMD浮点异常（#XF）来处理未屏蔽的256位和128位媒体浮点错误时，系统软件必须将OSXMMEXCPT位设置为1。将OSXMMEXCPT位清除为0表示不支持#XF处理程序。 当OSXMMEXCPT = 0时，未屏蔽的128位媒体浮点异常会导致无效操作码异常 |
| OSXSAVE(XSAVE and Extended States)       | 设置为1，则操作系统支持XGETBV，XSETBV，XSAVE和XRSTOR指令。处理器也将能够执行XGETBV和XSETBV指令，以读写XCR0。 |

- 调试寄存器（Debug Register）（8个）：DR0-DR7

![DR](/images/CPU 寄存器/DR.jpg)

 

​	调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。

​	DR0-DR3：保留32位断点的线性地址。

​	DR4-DR5：保留。

​	DR6：

| 标志    | 描述                                      |
| ----- | --------------------------------------- |
| B0-B3 | 断点状态的监测                                 |
| BD    | 调试寄存器访问监测。置位，表明在指令流中，下一条指令将访问其中的一个调试寄存器 |
| BS    | 单步执行标志位                                 |
| BT    | 任务转换标志位                                 |

​	DR7：

| 标志          | 描述                           |
| ----------- | ---------------------------- |
| L0-L3       | 局部断点使能标志位                    |
| G0-G3       | 全局断点使能标志位                    |
| LE GE       | 置位，表明处理器可以监测导致数据断点的指令。推荐置位为1 |
| GD          | 通用监测使能标志位。表明是否开启调试寄存器保护      |
| LEN0 - LEN3 | 用来表明相应断点地址寄存器内存位置的大小         |
| R/W0 - R/W3 | 相应断点的状态                      |

- 系统地址寄存器（4个）：GDTR、IDTR、LDTR和TR

  GDTR：全局描述符表寄存器，是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。

  IDTR：中断描述符表寄存器，是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。

  LDTR：局部描述符表寄存器，是一个16位寄存器，用来存放局部描述符表LDT的16位选择符。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。

  TR：任务状态寄存器，是一个16位寄存器，用来存放任务状态段TSS的16位选择符。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。

- 16位段寄存器（6个）：CS、DS、ES、FS、GS、SS

  段寄存器有两部分，一部分是编程可见的选择器寄存器，为6个16位寄存器，对应在另一部分有6个64位的描述符寄存器，后一部分是编程不可见的。

  在实地址方式或虚拟8086方式，描述符寄存器不起作用，选择器寄存器退化成16位CPU的段寄存器功能，存放内存段的段基址——段首地址的高16位，其中CS对应于代码段、SS对应于堆栈段，DS对应于数据段，ES对应于附加数据段，在串操作时，DS和ES分别对应于源数据段和目的数据段。FS和GS没有定义。

- 其他寄存器：EIP、TSC等

  - 指令指针指示器--EIP

    32位寄存器，低16位称为IP，用于兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目。所以称EIP为指令指针。

  - 时间戳寄存器--TSC

    每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。

  - 浮点寄存器

    由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。

## 主要技术

重命名技术：寄存器重命名，是CPU在解码过程中对寄存器进行重命名，解码器把“其它”的寄存器名字变为“通用”的寄存器名字，本质上是通过一个表格把x86寄存器重新映射到其它寄存器，这样可以让实际使用到的寄存器远大于8个。这样做的好处除了便于前面指令发生意外或分支预测出错时取消外，还避免了由于两条指令写同一个寄存器时的等待。

乱序执行技术：采用乱序执行技术使CPU内部电路满负荷运转并相应提高了CPU运行程序的速度。类似多个CPU同步执行。

## 特点

寄存器又分为内部寄存器与外部寄存器，所谓内部寄存器，其实也是一些小的存储单元，也能存储数据。但同存储器相比，寄存器又有自己独有的特点：

1. 寄存器位于CPU内部，数量很少，仅十四个
2. 寄存器所能存储的数据位数根据处理器类型不同而不同（8bit、16bit及32bit）
3. 每个内部寄存器都有一个名字，而没有类似存储器的地址编号

## 参考资料

[80X86寄存器详解](http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2501972.html)

[寄存器（百度百科）](https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682?fr=aladdin)

[Intel X86 CPU系列的寄存器](http://blog.chinaunix.net/uid-27717694-id-3943419.html)

[CR0-4寄存器介绍](http://blog.sina.com.cn/s/blog_85998e38010122wq.html)EFLAGS