<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><meta name="hexo-config" content="{&quot;hostname&quot;:&quot;chengqian90.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;AF7ILS3DFM&quot;,&quot;apiKey&quot;:&quot;d6766fc778aa1a2b67445c7a40b5dc75&quot;,&quot;indexName&quot;:&quot;hexo_github&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}"><meta name="description" content="树定义树是一种数据结构，它是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。具有以下特点："><meta property="og:type" content="article"><meta property="og:title" content="分析数据结构中的各种树"><meta property="og:url" content="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91.html"><meta property="og:site_name" content="小刘的杂货铺"><meta property="og:description" content="树定义树是一种数据结构，它是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。具有以下特点："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Tree.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Complete-array.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Not-complete-array.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-linked-list-with-root.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-linked-list.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Traversing.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Perfect-binary-tree.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Complete-binary-tree.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Full-binary-tree.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-search-tree-delete-1.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-search-tree-delete-2.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/BST-height.gif"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LL-right-rotation.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LL-right-rotation-2.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RR-left-rotation.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LR-left-right-rotation.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RL-right-left-rotation.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RBT-1.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RBT-ROTATE.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/4M-B-T.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-1.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-2.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-3.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-4.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-5.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-6.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-7.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-8.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-9.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-10.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-1.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-2.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-3.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-4.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-5.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-6.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-7.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-8.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-9.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-1.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-2.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-3.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-4.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-5.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-6.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-7.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-8.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-9.png"><meta property="og:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-10.png"><meta property="article:published_time" content="2019-09-01T12:57:52.000Z"><meta property="article:modified_time" content="2021-03-02T12:17:05.000Z"><meta property="article:author" content="Chengqian"><meta property="article:tag" content="树"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://chengqian90.com/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Tree.png"><link rel="canonical" href="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91.html"><meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}"><meta name="hexo-config-calendar" content=""><title>分析数据结构中的各种树 | 小刘的杂货铺</title><script data-pjax src="/js/load-config.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119899037-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-119899037-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9b18612675d198048222a1c96dd7555";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="小刘的杂货铺" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">小刘的杂货铺</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">In order to be irreplaceable, one must always be different</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-top"><a href="/top/" rel="section"><i class="fa fa-signal fa-fw"></i>top</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.</span> <span class="nav-text">相关定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">2.3.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.</span> <span class="nav-text">存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.2.</span> <span class="nav-text">链式存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.4.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%9C%E6%A0%91"><span class="nav-number">2.6.</span> <span class="nav-text">斜树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.7.</span> <span class="nav-text">完美二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.8.</span> <span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.9.</span> <span class="nav-text">完满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">2.10.</span> <span class="nav-text">二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">2.10.1.</span> <span class="nav-text">查找算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="nav-number">2.10.2.</span> <span class="nav-text">插入节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">2.10.3.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-1"><span class="nav-number">2.10.4.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">2.10.5.</span> <span class="nav-text">构造一棵二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">2.10.6.</span> <span class="nav-text">二叉查找树的性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.10.7.</span> <span class="nav-text">二叉查找树的优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="nav-number">2.11.</span> <span class="nav-text">笛卡尔树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVP%E6%A0%91"><span class="nav-number">2.12.</span> <span class="nav-text">MVP树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-tree"><span class="nav-number">2.13.</span> <span class="nav-text">Top tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#T%E6%A0%91"><span class="nav-number">2.14.</span> <span class="nav-text">T树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">自平衡二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">AVL树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC"><span class="nav-number">3.1.1.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LL-%E5%8F%B3%E6%97%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">LL 右旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RR-%E5%B7%A6%E6%97%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">RR 左旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LR-%E5%85%88%E5%B7%A6%E6%97%8B%E5%90%8E%E5%8F%B3%E6%97%8B"><span class="nav-number">3.1.4.</span> <span class="nav-text">LR 先左旋后右旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RL-%E5%85%88%E5%8F%B3%E6%97%8B%E5%90%8E%E5%B7%A6%E6%97%8B"><span class="nav-number">3.1.5.</span> <span class="nav-text">RL 先右旋后左旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.6.</span> <span class="nav-text">插入和删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E6%BC%94%E7%A4%BA"><span class="nav-number">3.1.7.</span> <span class="nav-text">在线演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">3.2.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">3.2.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">红黑树的左旋右旋</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AA%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">AA树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BE%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">3.4.</span> <span class="nav-text">左倾红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91"><span class="nav-number">3.5.</span> <span class="nav-text">替罪羊树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B8%E5%B1%95%E6%A0%91"><span class="nav-number">3.6.</span> <span class="nav-text">伸展树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%A0%86"><span class="nav-number">3.7.</span> <span class="nav-text">树堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">3.8.</span> <span class="nav-text">加权平衡树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">B树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91%E3%80%81B-%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">B树、B-树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.1.</span> <span class="nav-text">B树的插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.2.</span> <span class="nav-text">B树的删除操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">4.2.</span> <span class="nav-text">B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-number">4.2.1.</span> <span class="nav-text">特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.2.</span> <span class="nav-text">B+树的插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.3.</span> <span class="nav-text">B+树的删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E7%9B%B8%E5%AF%B9%E4%BA%8EB-%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.2.4.</span> <span class="nav-text">B+树相对于B-树的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91-1"><span class="nav-number">4.3.</span> <span class="nav-text">B*树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bx%E6%A0%91"><span class="nav-number">4.4.</span> <span class="nav-text">Bx树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UB%E6%A0%91"><span class="nav-number">4.5.</span> <span class="nav-text">UB树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4%E6%A0%91"><span class="nav-number">4.7.</span> <span class="nav-text">2-3-4树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-b-%E6%A0%91"><span class="nav-number">4.8.</span> <span class="nav-text">(a.b)-树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dancing-tree"><span class="nav-number">4.9.</span> <span class="nav-text">Dancing tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#H%E6%A0%91"><span class="nav-number">4.10.</span> <span class="nav-text">H树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">5.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">5.1.</span> <span class="nav-text">二叉堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%A1%B9%E5%A0%86"><span class="nav-number">5.2.</span> <span class="nav-text">二项堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86"><span class="nav-number">5.3.</span> <span class="nav-text">斐波那契堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%81%8F%E6%A0%91"><span class="nav-number">5.4.</span> <span class="nav-text">左偏树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E5%AF%B9%E5%A0%86"><span class="nav-number">5.5.</span> <span class="nav-text">配对堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%9C%E5%A0%86"><span class="nav-number">5.6.</span> <span class="nav-text">斜堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Van-Emde-Boas-tree"><span class="nav-number">5.7.</span> <span class="nav-text">Van Emde Boas tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91-TRIE"><span class="nav-number">6.</span> <span class="nav-text">字典树(TRIE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E6%A0%91"><span class="nav-number">6.1.</span> <span class="nav-text">后缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E6%A0%91"><span class="nav-number">6.2.</span> <span class="nav-text">广义后缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%A0%91"><span class="nav-number">6.3.</span> <span class="nav-text">基数树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">6.4.</span> <span class="nav-text">三叉查找树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X-%E5%BF%AB%E9%80%9F%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">6.5.</span> <span class="nav-text">X-快速前缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Y-%E5%BF%AB%E9%80%9F%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">6.6.</span> <span class="nav-text">Y-快速前缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">6.7.</span> <span class="nav-text">AC自动机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E7%A9%BA%E9%97%B4%E5%88%86%E5%89%B2%EF%BC%88BSP%EF%BC%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">二叉空间分割（BSP）树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%8F%89%E6%A0%91"><span class="nav-number">7.1.</span> <span class="nav-text">四叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E5%8F%89%E6%A0%91"><span class="nav-number">7.2.</span> <span class="nav-text">八叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-d%E6%A0%91"><span class="nav-number">7.3.</span> <span class="nav-text">k-d树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8Fk-d%E6%A0%91"><span class="nav-number">7.4.</span> <span class="nav-text">隐式k-d树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VP%E6%A0%91"><span class="nav-number">7.5.</span> <span class="nav-text">VP树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">非二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E6%A0%91"><span class="nav-number">8.1.</span> <span class="nav-text">指数树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9E%8D%E5%90%88%E6%A0%91"><span class="nav-number">8.2.</span> <span class="nav-text">融合树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%A0%91"><span class="nav-number">8.3.</span> <span class="nav-text">区间树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PQ%E6%A0%91"><span class="nav-number">8.4.</span> <span class="nav-text">PQ树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Range-tree"><span class="nav-number">8.5.</span> <span class="nav-text">Range tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPQR%E6%A0%91"><span class="nav-number">8.6.</span> <span class="nav-text">SPQR树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">空间数据分割树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#R%E6%A0%91"><span class="nav-number">9.1.</span> <span class="nav-text">R树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#R-%E6%A0%91"><span class="nav-number">9.2.</span> <span class="nav-text">R*树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#R-%E6%A0%91-1"><span class="nav-number">9.3.</span> <span class="nav-text">R+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X%E6%A0%91"><span class="nav-number">9.4.</span> <span class="nav-text">X树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#M%E6%A0%91"><span class="nav-number">9.5.</span> <span class="nav-text">M树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">9.6.</span> <span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">9.7.</span> <span class="nav-text">可持久化线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E6%A0%91"><span class="nav-number">9.8.</span> <span class="nav-text">希尔伯特树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88R%E6%A0%91"><span class="nav-number">9.9.</span> <span class="nav-text">优先R树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%A0%91"><span class="nav-number">10.</span> <span class="nav-text">其他树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%97%A5%E5%8E%86"><span class="nav-number">10.1.</span> <span class="nav-text">散列日历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%A0%91"><span class="nav-number">10.2.</span> <span class="nav-text">散列树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Finger-tree"><span class="nav-number">10.3.</span> <span class="nav-text">Finger tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E6%A0%91"><span class="nav-number">10.4.</span> <span class="nav-text">顺序统计树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metic-tee"><span class="nav-number">10.5.</span> <span class="nav-text">Metic tee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cover-tree"><span class="nav-number">10.6.</span> <span class="nav-text">Cover tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BK%E6%A0%91"><span class="nav-number">10.7.</span> <span class="nav-text">BK树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Doubly-chained-tee"><span class="nav-number">10.8.</span> <span class="nav-text">Doubly chained tee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iDistance"><span class="nav-number">10.9.</span> <span class="nav-text">iDistance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Link-cut-tree"><span class="nav-number">10.10.</span> <span class="nav-text">Link-cut tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Log-structured-merge-tree"><span class="nav-number">10.11.</span> <span class="nav-text">Log-structured merge-tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-number">10.12.</span> <span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%A0%91-Merkle-tree"><span class="nav-number">10.13.</span> <span class="nav-text">哈希树(Merkle tree)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97"><span class="nav-number">12.</span> <span class="nav-text">树与森林</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99"><span class="nav-number">13.</span> <span class="nav-text">优秀资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Chengqian</p><div class="site-description" itemprop="description">内核/云计算/网络</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">85</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">130</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://chengqian90.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Chengqian"><meta itemprop="description" content="内核/云计算/网络"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小刘的杂货铺"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 分析数据结构中的各种树</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-01 20:57:52" itemprop="dateCreated datePublished" datetime="2019-09-01T20:57:52+08:00">2019-09-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-02 20:17:05" itemprop="dateModified" datetime="2021-03-02T20:17:05+08:00">2021-03-02</time></span><span id="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91.html" class="post-meta-item leancloud_visitors" data-flag-title="分析数据结构中的各种树" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>20k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>19 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。具有以下特点：</p><span id="more"></span><ul><li>每个结点有零个或多个子结点；</li><li>没有父结点的结点称为根结点；</li><li>每一个非根结点有且只有一个父结点；</li><li>除了根结点外，每个子结点可以分为多个不相交的子树；</li></ul><p>空集合也是树，称为空树。空树中没有结点。</p><h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><ul><li><strong>根（Root）</strong>：树中最顶端的节点，根没有父节点。</li><li><strong>叶结点或终端结点</strong>：度为0的结点称为叶结点；</li><li>非终端结点或分支结点：度不为0的结点；</li><li>双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；</li><li>孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；</li><li>子孙：以某结点为根的子树中任一结点都称为该结点的子孙；</li><li>兄弟结点：具有相同父结点的结点互称为兄弟结点；</li><li>堂兄弟结点：双亲在同一层的结点互为堂兄弟；</li><li>结点的度：一个结点含有的<strong>子树的个数</strong>称为该结点的度；</li><li>树的度：一棵树中，<strong>最大的结点的度</strong>称为树的度；</li><li>结点的层次/层级：根为 Level 0 层，根的子节点为 Level 1 层，以此类推。</li><li><strong>树的高度或深度</strong>：树中层的数量。比如只有 Level 0,Level 1,Level 2 则高度为 3；</li><li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林。</li></ul><p>一个普通的树结构如下</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Tree.png" alt="Tree"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>二叉树</strong>是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>每个结点<strong>最多</strong>有两颗子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有<strong>顺序</strong>的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是<strong>左子树</strong>还是<strong>右子树</strong>。</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>在二叉树的第i层上最多有2i-1 个结点 。（i&gt;=1）</p></li><li><p>二叉树中如果深度为k,那么最多有2k-1个结点。(k&gt;=1）</p></li><li><p>n0=n2+1，n0表示度数为0的结点数，n2表示度数为2的结点数。</p></li><li><p>在<strong>完全二叉树</strong>中，具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1，其中[log<sub>2</sub>n]是向下取整。</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 若 i&#x3D;1，则该结点是二叉树的根，无双亲, 否则，编号为 [i&#x2F;2] 的结点为其双亲结点;</span><br><span class="line">(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；</span><br><span class="line">(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</span><br></pre></td></tr></table></figure></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>用一组连续的存储单元存放二叉树中的结点。按照二叉树结点<strong>从上至下、从左到右</strong>的顺序存储。</p><p>对于一般的二叉树，如果仍按从上至小、从左到右的顺序将树中的结点顺序存储在一维数组中，则数组元素下标之间的关系不能反映二叉树中结点之间的逻辑关系，<strong>只有添加一些并不存在的空结点</strong>，使之成为一棵完全二叉树的形式，然后用一维数组顺序存储。显然，这种存储对于需增加许多空结点才能将一棵二叉树改造成为一棵完全二叉树的存储时，会造成空间的大量浪费，不宜用顺序存储结构。</p><p>完全二叉树存储方式</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Complete-array.png" alt="Complete-array"></p><p>非完全二叉树存储方式</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Not-complete-array.png" alt="Not-complete-array"></p><p>灰色部分表示结点不存在，可以看出，连续存储方式出现了内存空白。</p><p>这种方式的存储对于右斜树而言，浪费的内存空间更大。</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>用链式结构来表示一棵二叉树，即用链指针来指示其元素的逻辑关系。（二叉链表）</p><p>由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。</p><p>定义代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>结构如图所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-linked-list-with-root.png" alt="Binary-linked-list-with-root"></p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-linked-list.png" alt="Binary-linked-list"></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><strong>二叉树的遍历</strong>是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。</p><p>二叉树的访问次序可以分为四种：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>从二叉树的<strong>根结点</strong>出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p><p>其访问顺序为：根结点-&gt;左子树-&gt;右子树</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Traversing.png" alt="Traversing"></p><ol><li>从根结点出发，此为第一个到达的结点，输出；</li><li>左子树遍历是否遍历完成，无则跳到3；右子树是否遍历完成，无则跳到4；叶子结点跳到5；</li><li>输出左子树结点，此时，左子树可以理解为“根”，返回2；</li><li>输出右子树结点，此时，右子树可以理解为“跟”，返回2；</li><li>返回父结点，跳到2；</li><li>全遍历完成，退出。</li></ol><p>因此，前序遍历的输出为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">A-&gt;B</span><br><span class="line">A-&gt;B-&gt;D</span><br><span class="line">A-&gt;B-&gt;D-&gt;E</span><br><span class="line">A-&gt;B-&gt;D-&gt;E-&gt;G</span><br><span class="line">A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C</span><br><span class="line">A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C-&gt;F</span><br><span class="line">A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C-&gt;F-&gt;H</span><br><span class="line">A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C-&gt;F-&gt;H-&gt;I</span><br></pre></td></tr></table></figure><p>实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的前序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">	      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);  <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);    <span class="comment">/*再先序遍历左子树*/</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);    <span class="comment">/*最后先序遍历右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreatStack(MAX_SIZE);    <span class="comment">//创建并初始化堆栈S</span></span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)        <span class="comment">//一直向左并将沿途节点访问（打印）后压入堆栈 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;Data);</span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!IsEmpty(S))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S);    <span class="comment">//节点弹出堆栈</span></span><br><span class="line">            T = T-&gt;Right;  <span class="comment">//转向右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找最左边的结点i，其必然为叶子，然后遍历i的父结点，再遍历i的兄弟结点。随着递归的逐渐出栈，最终完成遍历。</p><p>其访问顺序为：左子树-&gt;根结点-&gt;右子树</p><p>对于上图其输出顺序为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D</span><br><span class="line">D-&gt;B</span><br><span class="line">D-&gt;B-&gt;G</span><br><span class="line">D-&gt;B-&gt;G-&gt;E</span><br><span class="line">D-&gt;B-&gt;G-&gt;E-&gt;A</span><br><span class="line">D-&gt;B-&gt;G-&gt;E-&gt;A-&gt;C</span><br><span class="line">D-&gt;B-&gt;G-&gt;E-&gt;A-&gt;C-&gt;H</span><br><span class="line">D-&gt;B-&gt;G-&gt;E-&gt;A-&gt;C-&gt;H-&gt;F</span><br><span class="line">D-&gt;B-&gt;G-&gt;E-&gt;A-&gt;C-&gt;H-&gt;F-&gt;I</span><br></pre></td></tr></table></figure><p>其实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的中序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild); <span class="comment">/*中序遍历左子树*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);  <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild); <span class="comment">/*最后中序遍历右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreatStack(MaxSize); <span class="comment">//创建并初始化堆栈S</span></span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))</span><br><span class="line">　　&#123;</span><br><span class="line">    　　<span class="keyword">while</span>(T)    <span class="comment">//一直向左并将沿途节点压入堆栈</span></span><br><span class="line">    　　&#123; </span><br><span class="line">       　　 Push(S,T);</span><br><span class="line">        　　T = T-&gt;Left;</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">    　　&#123;</span><br><span class="line">       　　 T = Pop(S);                <span class="comment">//节点弹出堆栈</span></span><br><span class="line">       　　 <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;Data);    <span class="comment">//（访问） 打印结点</span></span><br><span class="line">      　　  T = T-&gt;Right;              <span class="comment">//转向右子树</span></span><br><span class="line">    　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找<strong>最左边的结点</strong>i，其必然为叶子，然后遍历i的兄弟结点，再遍历i的父结点。随着递归的逐渐出栈，最终完成遍历。</p><p>其访问顺序为：左子树-&gt;右子树-&gt;根结点</p><p>对于上图其输出顺序为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D</span><br><span class="line">D-&gt;G</span><br><span class="line">D-&gt;G-&gt;E</span><br><span class="line">D-&gt;G-&gt;E-&gt;B</span><br><span class="line">D-&gt;G-&gt;E-&gt;B-&gt;H</span><br><span class="line">D-&gt;G-&gt;E-&gt;B-&gt;H-&gt;I</span><br><span class="line">D-&gt;G-&gt;E-&gt;B-&gt;H-&gt;I-&gt;F</span><br><span class="line">D-&gt;G-&gt;E-&gt;B-&gt;H-&gt;I-&gt;F-&gt;C</span><br><span class="line">D-&gt;G-&gt;E-&gt;B-&gt;H-&gt;I-&gt;F-&gt;C-&gt;A</span><br></pre></td></tr></table></figure><p>其实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的后序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);   <span class="comment">/*先后序遍历左子树*/</span></span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);   <span class="comment">/*再后续遍历右子树*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);  <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S1 = CreatStack(MAX_SIZE);    <span class="comment">//创建并初始化堆栈S1</span></span><br><span class="line">    Stack S2 = CreatStack(MAX_SIZE);    <span class="comment">//创建并初始化堆栈S2   </span></span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T)        <span class="comment">//一直向右并将沿途节点访问（压入S2）后压入堆栈S1 </span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(S2, T);</span><br><span class="line">            Push(S1, T);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!IsEmpty(S1))</span><br><span class="line">        &#123;</span><br><span class="line">            T = Pop(S1);    <span class="comment">//节点弹出堆栈</span></span><br><span class="line">            T = T-&gt;Left;  <span class="comment">//转向左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(S2))    <span class="comment">//访问（打印）S2中元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = Pop(S2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;Data);</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>层次遍历就是按照树的层次自上而下、自左而右的遍历二叉树。</p><p>实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelIterationTraverse</span><span class="params">(BiNodePos(T) x, VST&amp; visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;BiNodePos(T)&gt; q;</span><br><span class="line">    q.push_back(x);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.front(); q.pop_front();</span><br><span class="line">        visit(x.data);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;lChild) q.push_back(x-&gt;lChild);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;rChild) q.push_back(x-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br></pre></td></tr></table></figure><h3 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h3><p>所有的结点都<strong>只有</strong>左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><h3 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h3><p>在一棵二叉树中，如果所有分支结点<strong>都存在左子树和右子树</strong>，并且所有叶子<strong>都在同一层</strong>上，这样的二叉树称为完美二叉树，也叫做<strong>满二叉树</strong>。</p><p>其特点如下：</p><ol><li>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</li><li>非叶子结点的度一定是2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ol><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Perfect-binary-tree.png" alt="Perfect-binary-tree"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一棵具有n个结点的二叉树<strong>按层编号</strong>，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Complete-binary-tree.png" alt="Complete-binary-tree"></p><p><strong>特点</strong>：</p><ol><li>叶子结点只能出现在最下层和次下层。</li><li>最下层的叶子结点集中在树的左部。</li><li>倒数第二层若存在叶子结点，一定在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子，即没有右子树。</li><li>同样结点数目的二叉树，完全二叉树深度最小。</li></ol><p><strong>满二叉树一定是完全二叉树，但反过来不一定成立。</strong></p><h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>所有非叶子结点的度都是2的树叫做完满二叉树。（<strong>只要你有孩子，你就必然是有两个孩子。</strong>）</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Full-binary-tree.png" alt="Full-binary-tree"></p><p><strong>三者总结</strong></p><table><thead><tr><th><strong>完美二叉树</strong></th><th>Perfect Binary Tree</th><th>Every node except the leaf nodes have two children and every level (last level too) is completely filled. <strong>除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。</strong></th></tr></thead><tbody><tr><td><strong>完全二叉树</strong></td><td>Complete Binary Tree</td><td>Every level except the last level is completely filled and all the nodes are left justified. <strong>除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。</strong></td></tr><tr><td><strong>完满二叉树</strong></td><td>Full/Strictly Binary Tree</td><td>Every node except the leaf nodes have two children. <strong>除了叶子结点之外的每一个结点都有两个孩子结点。</strong></td></tr></tbody></table><ul><li>完美(Perfect)二叉树一定是完全(Complete)二叉树，但完全(Complete)二叉树不一定是完美(Perfect)二叉树。</li><li>完美(Perfect)二叉树一定是完满(Full)二叉树，但完满(Full)二叉树不一定是完美(Perfect)二叉树。</li><li>完全(Complete)二叉树可能是完满(Full)二叉树，完满(Full)二叉树也可能是完全(Complete)二叉树。</li><li>既是完全(Complete)二叉树又是完满(Full)二叉树也不一定就是完美(Perfect)二叉树。</li></ul><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>二叉查找树</strong>（Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li><strong>没有键值相等的节点</strong>。</li></ul><p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为O(logn)。</p><p>中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望O(log n)，最坏O(n)（数列有序，树退化成线性表）。</p><h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在根指针T所指二元查找树中递归地查找其关键字等于key的数据元素，若查找成功，</span></span><br><span class="line">    <span class="comment">// 则指针p指向该数据元素节点，并返回TRUE，否则指针指向查找路径上访问的最后</span></span><br><span class="line">    <span class="comment">// 一个节点并返回FALSE，指针f指向T的双亲，其初始调用值为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!T) &#123; <span class="comment">// 查找不成功</span></span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data.key) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="comment">// 在左子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右子树中继续查找</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li>若b是空树，则将s所指节点作为根节点插入，否则：</li><li>若s-&gt;data等于b的根节点的数据域之值，则返回，否则：</li><li>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li><li>把s所指节点插入到右子树中。（<strong>新插入节点总是叶子节点</strong>）</li></ol><p><strong>插入之后，以任一根节点为中心，左边所有值都小于根，右边所有值都大于根。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当二元搜寻树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回 FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = s; <span class="comment">// 被插节点*s为新的根结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 关键字等于e.key的数据元素，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (e.key &lt; T-&gt;data.key)</span><br><span class="line">        InsertBST(T-&gt;lchild, e);  <span class="comment">// 将 e 插入左子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        InsertBST(T-&gt;rchild, e);  <span class="comment">// 将 e 插入右子树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>在二叉查找树删去一个结点，分三种情况讨论：</p><ol><li><p>若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</p></li><li><p>若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉查找树的特性。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-search-tree-delete-1.png" alt="Binary-search-tree-delete-1"></p></li><li><p>若*p结点的<strong>左子树和右子树均不空</strong>。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：</p><ol><li>令*p的左子树为*f的左/右（依*p是*f的左子树还是右子树而定）子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；</li><li>令*p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代*p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。</li></ol><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/Binary-search-tree-delete-2.png" alt="Binary-search-tree-delete-2"></p><p><strong>中心思想</strong>：<strong>以删除的节点为中心，找到左树中最大的（最右节点）进行替代；或者右树中最小的（最左节点）替代。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素，并返回</span></span><br><span class="line">    <span class="comment">// TRUE；否则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//不存在关键字等于key的数据元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == T-&gt;data.key)   <span class="comment">//   找到关键字等于key的数据元素</span></span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *&amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该节点为叶子节点，直接删除</span></span><br><span class="line">    BiTree *q, *s;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;rchild &amp;&amp; !p-&gt;lchild) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// Status Delete(BiTree *&amp;p) 要加&amp;才能使P指向NULL</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild) &#123; <span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">        q = p-&gt;lchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;lchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;lchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;lchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123; <span class="comment">// 左子树空只需重接它的右子树</span></span><br><span class="line">        q = p-&gt;rchild;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p-&gt;data = p-&gt;rchild-&gt;data;</span></span><br><span class="line"><span class="comment">        p-&gt;lchild=p-&gt;rchild-&gt;lchild;</span></span><br><span class="line"><span class="comment">        p-&gt;rchild=p-&gt;rchild-&gt;rchild;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p-&gt;data = q-&gt;data;</span><br><span class="line">        p-&gt;lchild = q-&gt;lchild;</span><br><span class="line">        p-&gt;rchild = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不空</span></span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125; <span class="comment">// 转左，然后向右到尽头</span></span><br><span class="line">        p-&gt;data = s-&gt;data;  <span class="comment">// s指向被删结点的“前驱”</span></span><br><span class="line">        <span class="keyword">if</span> (q != p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;  <span class="comment">// 重接*q的右子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;  <span class="comment">// 重接*q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可参考本章“二叉树”一节的四种遍历。</p><h4 id="构造一棵二叉查找树"><a href="#构造一棵二叉查找树" class="headerlink" title="构造一棵二叉查找树"></a>构造一棵二叉查找树</h4><p>用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为O(n<sup>2</sup>)。</p><p>例如，若该组数值已经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树。自平衡二叉查找树可以克服上述缺点，其时间复杂度为O(<em>n</em>log <em>n</em>)。一方面，树排序的问题使得CPU Cache性能较差，特别是当节点是动态内存分配时。而堆排序的CPU Cache性能较好。另一方面，树排序是最优的增量排序（incremental sorting）算法，保持一个数值序列的有序性。</p><p>树的构造其核心为对值的插入，“插入节点”一节已实现。</p><h4 id="二叉查找树的性能"><a href="#二叉查找树的性能" class="headerlink" title="二叉查找树的性能"></a>二叉查找树的性能</h4><p>每个结点的C<sub>i</sub>为该结点的层次数。最坏情看看看况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为n，其平均查找长度为$$\frac{n+1}{2}$$（和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和log<sub>2</sub>n 成正比 O(log<sub>2</sub>n)。</p><h4 id="二叉查找树的优化"><a href="#二叉查找树的优化" class="headerlink" title="二叉查找树的优化"></a>二叉查找树的优化</h4><p>一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了<strong>平衡树</strong>。在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。</p><h3 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91">笛卡尔树</a></p><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/cartesian-tree/">笛卡尔树</a></p><p><a target="_blank" rel="noopener" href="https://www.zybuluo.com/KirinBill/note/871204">笛卡尔树学习笔记</a></p><p><a target="_blank" rel="noopener" href="https://fangjian0423.github.io/2016/04/09/heap-heapsort/">堆、二叉堆、堆排序</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1cfdcee48003">算法入门：堆排序</a></p><h3 id="MVP树"><a href="#MVP树" class="headerlink" title="MVP树"></a>MVP树</h3><p>todo</p><h3 id="Top-tree"><a href="#Top-tree" class="headerlink" title="Top tree"></a>Top tree</h3><h3 id="T树"><a href="#T树" class="headerlink" title="T树"></a>T树</h3><h2 id="自平衡二叉查找树"><a href="#自平衡二叉查找树" class="headerlink" title="自平衡二叉查找树"></a>自平衡二叉查找树</h2><p>自平衡二叉查找树（Self-Balancing Binary Search Tree）的运行时间与树的高度（Height）有关系。一棵树的高度指的是从树的根开始所能到达的最长的路径长度。树的高度可被递归性地定义为：</p><ul><li>如果节点没有子节点，则高度为 0；</li><li>如果节点只有一个子节点，则高度为该子节点的高度加 1；</li><li>如果节点有两个子节点，则高度为两个子节点中高度较高的加 1；</li></ul><p>计算树的高度要从叶子节点开始，首先将叶子节点的高度置为 0，然后根据上面的规则向上计算父节点的高度。以此类推直到树中所有的节点高度都被标注后，则根节点的高度就是树的高度。</p><p>下图显示了几棵已经计算好高度的BST树</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/BST-height.gif" alt="BST-height"></p><p><strong>如果树中节点的数量为 n，则一棵满足O(log<sub>2</sub>n) 渐进运行时间的 BST 树的高度应接近于比 log<sub>2</sub>n 小的最大整数。</strong></p><p>树-a的节点数量为10，而高度为4，log<sub>2</sub>10 = 3.3219，比 3.3219 小的最大整数是 3，所以树-a最理想的高度应该是3。（情况最好）</p><p>树-b的节点数量为8，而高度为3，所以log<sub>2</sub>8 = 3，结果正好与树的高度相等。</p><p>树-c的节点数量是 5，所以log<sub>2</sub>5 = 2.3219，则理想高度为 2，但实际上是 4。（情况最差）</p><p>我们可以通过移动距离最远的节点到中间的某个非叶子节点，以减少数的高度，以使该树的高度与节点数量的比例达到最优。</p><p>实际上我们真正面对的问题是<strong>如何保证 BST 的拓扑结构始终保持树高度与节点数量的最佳比例</strong>。在不试图让数据源决定数据顺序的情况下，新的节点插入后仍然可以保持 BST 树的平衡（balanced）。这种能够始终维持树平衡状态的数据结构称为自平衡二叉查找树（self-balancing binary search tree）。</p><p>一棵平衡树指的是树能够保持其高度与广度能够保持预先定义的比例。不同的数据结构可以定义不同的比例以保持平衡，但所有的比例都趋向于log<sub>2</sub>n。那么，一颗自平衡的 BST 也同样呈现出 O(log<sub>2</sub>n) 的渐进运行时间。</p><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树得名于它的发明者<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA">G. M. Adelson-Velsky</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1">Evgenii Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p><p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的<strong>高度</strong>（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><p>在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n) 。增加和删除元素的操作则可能需要借由一次或多次<strong>树旋转</strong>，以实现树的重新平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeGetBalanceFactor</span><span class="params">(<span class="keyword">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x-&gt;left-&gt;height - x-&gt;right-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–<strong>旋转</strong>。</p><p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><ul><li><strong>左旋和右旋</strong>都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。</li><li>如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。</li><li>如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。</li></ul><p>插入节点时分四种情况，四种情况对应的旋转方法是不同的：</p><p>对于被破坏平衡的节点 a 来说：</p><table><thead><tr><th>插入方式</th><th>描述</th><th>旋转方式</th></tr></thead><tbody><tr><td>LL</td><td>在a的<strong>左子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td><td>右旋</td></tr><tr><td>RR</td><td>在a的<strong>右子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td><td>左旋</td></tr><tr><td>LR</td><td>在a的<strong>左子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td><td>先左旋后右旋</td></tr><tr><td>RL</td><td>在a的<strong>右子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td><td>先右旋后左旋</td></tr></tbody></table><h4 id="LL-右旋"><a href="#LL-右旋" class="headerlink" title="LL 右旋"></a>LL 右旋</h4><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LL-right-rotation.png" alt="LL-right-rotation"></p><p>新插入节点 3 破坏了树的平衡性，因此不平衡的树一定位于 3 所在子树上。<strong>找离新插入的节点最近的不平衡的树进行调整</strong>，上图中就是 6（左子树高度为2，右子树高度为0，差2）。</p><p>子树 6-&gt;4-&gt;3 为不平衡树，需要对其进行调整，对 4 进行右旋，使高度差减1，从而达到平衡状态。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LL-right-rotation-2.png" alt="LL-right-rotation-2"></p><p>右旋操作，就是把上图中的 6 节点和 4 节点进行“父子交换”。在仅有这三个节点时候，是十分简单的。但是当 4 节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：<strong>抛弃右孩子，将之和旋转后的节点 6 相连，成为节点 6 的左孩子</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">nodeptr_t</span> <span class="title">treeRotateRight</span><span class="params">(<span class="keyword">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> left = root-&gt;left;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = left-&gt;right; <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left-&gt;right = root; <span class="comment">// 调换父子关系</span></span><br><span class="line"></span><br><span class="line">    left-&gt;height = max(treeHeight(left-&gt;left), treeHeight(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = max(treeHeight(right-&gt;left), treeHeight(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RR-左旋"><a href="#RR-左旋" class="headerlink" title="RR 左旋"></a>RR 左旋</h4><p>左旋和右旋类似，都是单旋。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RR-left-rotation.png" alt="RR-left-rotation"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">nodeptr_t</span> <span class="title">treeRotateLeft</span><span class="params">(<span class="keyword">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    left-&gt;height = max(treeHeight(left-&gt;left), treeHeight(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = max(treeHeight(right-&gt;left), treeHeight(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LR-先左旋后右旋"><a href="#LR-先左旋后右旋" class="headerlink" title="LR 先左旋后右旋"></a>LR 先左旋后右旋</h4><p>左旋一次后，不平衡状况依然存在，还需要再次进行旋转。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/LR-left-right-rotation.png" alt="LR-left-right-rotation"></p><h4 id="RL-先右旋后左旋"><a href="#RL-先右旋后左旋" class="headerlink" title="RL 先右旋后左旋"></a>RL 先右旋后左旋</h4><p>类似 LR 情况。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RL-right-left-rotation.png" alt="RL-right-left-rotation"></p><p>LR 和 RL 实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">nodeptr_t</span> <span class="title">treeRebalance</span><span class="params">(<span class="keyword">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = treeGetBalanceFactor(root);</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &gt; <span class="number">0</span>) <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;left) &lt;= <span class="number">0</span>) &#123; <span class="comment">//LR</span></span><br><span class="line">        root-&gt;left = treeRotateLeft(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> treeRotateRight(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((factor &lt; <span class="number">-1</span> &amp;&amp; treeGetBalanceFactor(root-&gt;right) &gt; <span class="number">0</span>) &#123; <span class="comment">// RL</span></span><br><span class="line">        root-&gt;right = treeRotateRight(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> treeRotateLeft(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Nothing happened.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25806863/article/details/74755131">AVL树的旋转图解和简单实现</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34899732">详解 AVL 树（基础篇）</a></p><h4 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h4><p>利用递归来实现AVL树的插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeInsert</span><span class="params">(<span class="keyword">nodeptr_t</span> *rootptr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> newNode;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">        assert(newNode);</span><br><span class="line"></span><br><span class="line">        newNode-&gt;data = value;</span><br><span class="line">        newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        *rootptr = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            treeInsert(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            treeInsert(&amp;root-&gt;left,value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    treeRebalance(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除也同样使用递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeDelete</span><span class="params">(<span class="keyword">nodeptr_t</span> *rootptr, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> *toFree;</span><br><span class="line">    <span class="keyword">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                root-&gt;data = treeDeleteMin(&amp;(root-&gt;right));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toFree = root;</span><br><span class="line">                *rootptr = toFree-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(toFree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            treeDelete(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            treeDelete(&amp;root-&gt;left,value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeRebalance(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h4><p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">此网站</a>可以看到 AVL 树的可视化，墙裂推荐。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。</p><p><strong>黑色高度</strong>： 从根节点到叶节点的路径上黑色节点的个数。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RBT-1.png" alt="RBT-1"></p><ol><li>每个节点要么是红色，要么是黑色；</li><li><strong>根节点永远是黑色的；</strong></li><li>所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；</li><li>每个红色节点的两个子节点一定都是黑色；</li><li>从任一节点到其子树中每个叶子节点的路径都<strong>包含相同数量的黑色节点；</strong></li></ol><p><em><strong>注意：</strong></em><br><strong>性质 3</strong> ：红黑树的<strong>每个叶子节点都是空节点，并且叶子节点都是黑色</strong>。</p><p><strong>性质 4</strong> ：从每个根到节点的路径上<strong>不会有两个连续的红色节点，但黑色节点是可以连续的。</strong></p><p>因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑</p><p>相间，树的高度为 2(N - 1) 。</p><p><strong>性质 5</strong> ：红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。</p><h4 id="红黑树的左旋右旋"><a href="#红黑树的左旋右旋" class="headerlink" title="红黑树的左旋右旋"></a>红黑树的左旋右旋</h4><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/RBT-ROTATE.png" alt="RBT-ROTATE"></p><p>红黑树左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。</p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31805309">漫画：什么是红黑树？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/58371f13a22b9d006882902d">面试旧敌之红黑树</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p><h3 id="AA树"><a href="#AA树" class="headerlink" title="AA树"></a>AA树</h3><p><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-glukopyi-tc.html">AA树—简单的红黑树</a></p><h3 id="左倾红黑树"><a href="#左倾红黑树" class="headerlink" title="左倾红黑树"></a>左倾红黑树</h3><h3 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h3><h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><h3 id="树堆"><a href="#树堆" class="headerlink" title="树堆"></a>树堆</h3><h3 id="加权平衡树"><a href="#加权平衡树" class="headerlink" title="加权平衡树"></a>加权平衡树</h3><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树也称B-树,它是一颗多路平衡查找树。描述一颗B树时需要指定它的阶数，阶数表示了<strong>一个结点最多有多少个孩子结点</strong>，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。</p><h3 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B-树"></a>B树、B-树</h3><p>m阶B树定义：</p><ol><li><strong>每个结点关键字个数n取值范围为 Math.ceil(m/2)-1 &lt;= n &lt;= m-1</strong>；</li><li><strong>根结点</strong>最少可以只有1个关键字；</li><li>每个结点中的关键字都<strong>按照从小到大的顺序</strong>排列，<strong>每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它</strong>；</li><li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li></ol><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/4M-B-T.png" alt="4M-B-T"></p><p>上图是一颗阶数为4的B树。在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，</p><p>B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。</p><p><strong>我们将一个key和其对应的data称为一个记录</strong>。<strong>但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体</strong>。在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速速，此时B树中的key</p><p>就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。</p><h4 id="B树的插入操作"><a href="#B树的插入操作" class="headerlink" title="B树的插入操作"></a>B树的插入操作</h4><p>插入操作是指插入一条记录，即（key, value）的键值对。</p><p>如果B树中已存在需要插入的键值对，则用需要插入的value<strong>替换</strong>旧的value。若B树不存在这个key，则一定是在叶子结点中进行插入操作。</p><ol><li>根据要插入的key的值，<strong>找到叶子结点并插入</strong>。</li><li>判断当前结点key的个数<strong>是否小于等于m-1</strong>，若满足则结束，否则进行第3步。</li><li>以结点<strong>中间的key</strong>为中心分裂成左右两部分，然后将这个中间的<strong>key插入到父结点中</strong>，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。</li></ol><p>以5阶B树为例，在5阶B树中，结点最多有4个key,最少有2个key。</p><ol><li><p>在空树中插入39，此时根结点就一个key，此时根结点也是叶子结点</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-1.png" alt="5M-B-INSERT-1"></p></li><li><p>继续插入22，97和41，根结点此时有4个key</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-2.png" alt="5M-B-INSERT-2"></p></li><li><p>继续插入53，</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-3.png" alt="5M-B-INSERT-3"></p><p>插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-4.png" alt="5M-B-INSERT-4"></p></li><li><p>依次插入13，21，40，同样会造成分裂，结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-5.png" alt="5M-B-INSERT-5"></p></li><li><p>依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-6.png" alt="5M-B-INSERT-6"></p></li><li><p>插入key值为26的记录，插入后的结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-7.png" alt="5M-B-INSERT-7"></p><p>当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-8.png" alt="5M-B-INSERT-8"></p><p>进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-9.png" alt="5M-B-INSERT-9"></p></li><li><p>最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-INSERT-10.png" alt="5M-B-INSERT-10"></p></li></ol><p>在实现B树的代码中，为了使代码编写更加容易，可以将结点中存储记录的数组长度定义为m而非m-1，这样方便底层的结点由于分裂向上层插入一个记录时，上层有多余的位置存储这个记录。同时，每个结点还可以存储它的父结点的引用，这样就不必编写递归程序。</p><p>一般来说，对于确定的m和确定类型的记录，结点大小是固定的，无论它实际存储了多少个记录。但是<strong>分配固定结点大小的方法会存在浪费的情况</strong>，比如key为28,29所在的结点，还有2个key的位置没有使用，但是已经不可能继续在插入任何值了，因为这个结点的前序key是27,后继key是30,所有整数值都用完了。所以如果记录先按key的大小排好序，再插入到B树中，结点的使用率就会很低，最差情况下使用率仅为50%。</p><h4 id="B树的删除操作"><a href="#B树的删除操作" class="headerlink" title="B树的删除操作"></a>B树的删除操作</h4><p>删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。</p><ol><li>如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步</li><li>该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。</li><li>如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</li></ol><p>有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。</p><p>下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key</p><ol><li><p>原始状态</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-1.png" alt="5M-B-DELETE-1"></p></li><li><p>在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-2.png" alt="5M-B-DELETE-2"></p></li><li><p>在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-3.png" alt="5M-B-DELETE-3"></p><p>删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-4.png" alt="5M-B-DELETE-4"></p></li><li><p>在上述情况下接着32，结果如下图。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-5.png" alt="5M-B-DELETE-5"></p><p>当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-6.png" alt="5M-B-DELETE-6"></p><p>当前结点key的个数满足条件，故删除结束。</p></li><li><p>上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-7.png" alt="5M-B-DELETE-7"></p><p>同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-8.png" alt="5M-B-DELETE-8"></p><p>同理，对于当前结点而言只能继续合并了，最后结果如下所示。</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/5M-B-DELETE-9.png" alt="5M-B-DELETE-9"></p><p>合并后结点当前结点满足条件，删除结束。</p></li></ol><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">B树和B+树的插入、删除图文详解</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f2560f0e87f">漫画算法：什么是 B+ 树？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b0cb64e518825157476b4a9#b-%E6%A0%91-1">重温数据结构：理解 B 树、B+ 树特点及使用场景</a></p><p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/61.html">B+树及插入和删除操作详解</a> —— 深度好文、强烈推荐</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>m阶B+树</p><ol><li><strong>每个结点关键字个数n取值范围为 Math.ceil(m/2)-1 &lt;= n &lt;= m</strong>；</li><li><strong>有k个子树的中间节点包含有k个元素（B树中是k-1个元素）；</strong></li><li>每个元素不保存数据，只用来索引，<strong>所有数据都保存在叶子节点</strong>；</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；</li><li><strong>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</strong></li></ol><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-1.png" alt="3M-B+TREE"></p><p>如图所示，B+树中含有两个头指针，<strong>一个指向整棵树的根结点，另一个指向关键字最小的叶子结点</strong>。同时所有的叶子结点依据其关键字的大小自小而大顺序链接，所有的叶子结点构成了一个 sqt 指针为头指针的<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/160.html">链表</a>。</p><p>所以，B+树可以进行两种查找运算：</p><ul><li>利用 sqt 链表做<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/54.html">顺序查找</a></li><li>从树的根结点开始，进行类似于<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/55.html">二分查找</a>的查找方式。</li></ul><p>在 B+树中，所有非终端结点都相当于是终端结点的索引，而所有的数据都存放在终端结点中，所以在从根结点出发做查找操作时，如果非终端结点上的关键字恰好等于给定值，此时并不算查找完成，而是要继续向下直到叶子结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B+树的查找操作，无论查找成功与否，每次查找操作都是走了一条从根结点到叶子结点的路径。</span><br><span class="line">卫星数据：索引元素所指向的数据记录。B-树中每个节点都包含卫星数据，而B+树中，只有叶子节点包含。</span><br></pre></td></tr></table></figure><h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><p>在B+树中插入关键字时，需要注意以下几点：</p><ul><li>插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；</li><li>由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行“分裂”；</li></ul><p>B+树中做插入关键字的操作，有以下 3 种情况：</p><ol><li><p>若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入结束；</p><p>在图1中插入关键字13，其结果如下图2所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-2.png" alt="3M-B+TREE-1"></p></li><li><p>若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含<code>⌊M/2⌋</code>，另一个结点包含<code>⌈M/2⌉</code>。同时，将<code>⌈M/2⌉</code>的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</p><p>在图1中插入关键字95，其结果如下图3所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-3.png" alt="3M-B+TREE-2"></p></li><li><p>在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</p><p>在图1中插入关键字40，其结果如下图所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-4.png" alt="3M-B+TREE-3"></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</span><br><span class="line">例如，在图 1 的 B+树种插入关键字 100，由于其值比 97 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 97 改为 100。改完之后再做分裂操作。</span><br></pre></td></tr></table></figure><h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><p>在 B+树中删除关键字时，有以下几种情况：</p><ol><li><p>找到存储有该关键字所在的结点时，由于该结点中关键字个数大于<code>⌈M/2⌉</code>，做删除操作不会破坏 B+树，则可以直接删除。</p><p>在图 1 所示的 B+树中删除关键字 91，其结果如下图5所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-5.png" alt="3M-B+TREE-4"></p></li><li><p>当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</p><p>在图 1 所示的 B+树中删除关键字 91，其结果如下图所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-6.png" alt="3M-B+TREE-5"></p></li><li><p>当删除该关键字，导致当前结点中关键字个数小于<code>⌈M/2⌉</code>，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。</p><p>在图 1 的 B+树中删除关键字 51，由于其兄弟结点中含有 3 个关键字，所以可以选择借一个关键字，同时修改双亲结点中的索引值，删除之后的 B+树如图7所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-7.png" alt="3M-B+TREE-7"></p></li><li><p>第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。</p><p>在图 7 的 B+树种删除关键字 59，删除之后的 B+树如图8所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-8.png" alt="3M-B+TREE-8"></p></li><li><p>当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。</p><p>在图 6 的 B+树中删除关键字 63，当删除后该结点中只剩关键字 72，且其兄弟结点中只有 2 个关键字，无法实现借的操作，只能进行合并。但是合并后，合并后的效果图如图 9 所示</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-9.png" alt="3M-B+TREE-9"></p></li></ol><p>如图 9 所示，其双亲结点中只有一个关键字，而其兄弟结点中有 3 个关键字，所以可以通过借的操作，来满足 B+树的性质，最终的 B+树如图 10 所示：</p><p><img src="/images/%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%91/3M-B+TREE-10.png" alt="3M-B+TREE-10"></p><p>总之，在 B+树中做删除关键字的操作，采取如下的步骤：</p><ol><li>删除该关键字，如果不破坏 B+树本身的性质，直接完成操作；</li><li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值；</li><li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并。（注意这两种方式有时需要更改其父结点中的索引值。）</li></ol><h4 id="B-树相对于B-树的特点"><a href="#B-树相对于B-树的特点" class="headerlink" title="B+树相对于B-树的特点"></a>B+树相对于B-树的特点</h4><ul><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ul><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><h3 id="Bx树"><a href="#Bx树" class="headerlink" title="Bx树"></a>B<sup>x</sup>树</h3><h3 id="UB树"><a href="#UB树" class="headerlink" title="UB树"></a>UB树</h3><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><h3 id="a-b-树"><a href="#a-b-树" class="headerlink" title="(a.b)-树"></a>(a.b)-树</h3><h3 id="Dancing-tree"><a href="#Dancing-tree" class="headerlink" title="Dancing tree"></a>Dancing tree</h3><h3 id="H树"><a href="#H树" class="headerlink" title="H树"></a>H树</h3><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><h3 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h3><h3 id="斐波那契堆"><a href="#斐波那契堆" class="headerlink" title="斐波那契堆"></a>斐波那契堆</h3><h3 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h3><h3 id="配对堆"><a href="#配对堆" class="headerlink" title="配对堆"></a>配对堆</h3><h3 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h3><h3 id="Van-Emde-Boas-tree"><a href="#Van-Emde-Boas-tree" class="headerlink" title="Van Emde Boas tree"></a>Van Emde Boas tree</h3><h2 id="字典树-TRIE"><a href="#字典树-TRIE" class="headerlink" title="字典树(TRIE)"></a>字典树(TRIE)</h2><h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><h3 id="广义后缀树"><a href="#广义后缀树" class="headerlink" title="广义后缀树"></a>广义后缀树</h3><h3 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h3><h3 id="三叉查找树"><a href="#三叉查找树" class="headerlink" title="三叉查找树"></a>三叉查找树</h3><h3 id="X-快速前缀树"><a href="#X-快速前缀树" class="headerlink" title="X-快速前缀树"></a>X-快速前缀树</h3><h3 id="Y-快速前缀树"><a href="#Y-快速前缀树" class="headerlink" title="Y-快速前缀树"></a>Y-快速前缀树</h3><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><h2 id="二叉空间分割（BSP）树"><a href="#二叉空间分割（BSP）树" class="headerlink" title="二叉空间分割（BSP）树"></a>二叉空间分割（BSP）树</h2><h3 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h3><h3 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h3><h3 id="k-d树"><a href="#k-d树" class="headerlink" title="k-d树"></a>k-d树</h3><h3 id="隐式k-d树"><a href="#隐式k-d树" class="headerlink" title="隐式k-d树"></a>隐式k-d树</h3><h3 id="VP树"><a href="#VP树" class="headerlink" title="VP树"></a>VP树</h3><h2 id="非二叉树"><a href="#非二叉树" class="headerlink" title="非二叉树"></a>非二叉树</h2><h3 id="指数树"><a href="#指数树" class="headerlink" title="指数树"></a>指数树</h3><h3 id="融合树"><a href="#融合树" class="headerlink" title="融合树"></a>融合树</h3><h3 id="区间树"><a href="#区间树" class="headerlink" title="区间树"></a>区间树</h3><h3 id="PQ树"><a href="#PQ树" class="headerlink" title="PQ树"></a>PQ树</h3><h3 id="Range-tree"><a href="#Range-tree" class="headerlink" title="Range tree"></a>Range tree</h3><h3 id="SPQR树"><a href="#SPQR树" class="headerlink" title="SPQR树"></a>SPQR树</h3><h2 id="空间数据分割树"><a href="#空间数据分割树" class="headerlink" title="空间数据分割树"></a>空间数据分割树</h2><h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3><h3 id="R-树"><a href="#R-树" class="headerlink" title="R*树"></a>R*树</h3><h3 id="R-树-1"><a href="#R-树-1" class="headerlink" title="R+树"></a>R+树</h3><h3 id="X树"><a href="#X树" class="headerlink" title="X树"></a>X树</h3><h3 id="M树"><a href="#M树" class="headerlink" title="M树"></a>M树</h3><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h3 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h3><h3 id="希尔伯特树"><a href="#希尔伯特树" class="headerlink" title="希尔伯特树"></a>希尔伯特树</h3><h3 id="优先R树"><a href="#优先R树" class="headerlink" title="优先R树"></a>优先R树</h3><h2 id="其他树"><a href="#其他树" class="headerlink" title="其他树"></a>其他树</h2><h3 id="散列日历"><a href="#散列日历" class="headerlink" title="散列日历"></a>散列日历</h3><h3 id="散列树"><a href="#散列树" class="headerlink" title="散列树"></a>散列树</h3><h3 id="Finger-tree"><a href="#Finger-tree" class="headerlink" title="Finger tree"></a>Finger tree</h3><h3 id="顺序统计树"><a href="#顺序统计树" class="headerlink" title="顺序统计树"></a>顺序统计树</h3><h3 id="Metic-tee"><a href="#Metic-tee" class="headerlink" title="Metic tee"></a>Metic tee</h3><h3 id="Cover-tree"><a href="#Cover-tree" class="headerlink" title="Cover tree"></a>Cover tree</h3><h3 id="BK树"><a href="#BK树" class="headerlink" title="BK树"></a>BK树</h3><h3 id="Doubly-chained-tee"><a href="#Doubly-chained-tee" class="headerlink" title="Doubly chained tee"></a>Doubly chained tee</h3><h3 id="iDistance"><a href="#iDistance" class="headerlink" title="iDistance"></a>iDistance</h3><h3 id="Link-cut-tree"><a href="#Link-cut-tree" class="headerlink" title="Link-cut tree"></a>Link-cut tree</h3><h3 id="Log-structured-merge-tree"><a href="#Log-structured-merge-tree" class="headerlink" title="Log-structured merge-tree"></a>Log-structured merge-tree</h3><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h3 id="哈希树-Merkle-tree"><a href="#哈希树-Merkle-tree" class="headerlink" title="哈希树(Merkle tree)"></a>哈希树(Merkle tree)</h3><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_aiyang/article/details/84977814#%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">https://blog.csdn.net/csdn_aiyang/article/details/84977814#%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91</a></p><h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><h2 id="优秀资料"><a href="#优秀资料" class="headerlink" title="优秀资料"></a>优秀资料</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bf73c8d50dc2">深入学习二叉树(一) 二叉树基础</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/912357993486">常用数据结构——树</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/idorax/p/6441043.html">完美二叉树, 完全二叉树和完满二叉树</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/llhthinker/p/4747962.html">二叉树的遍历</a></p><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/self_balancing_binary_search_tree.html">自平衡二叉查找树</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34899732">详解 AVL 树（基础篇）</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25806863/article/details/74755131">AVL树的旋转图解和简单实现</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E6%A0%91/" rel="tag"># 树</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" rel="prev" title="十大经典排序算法"><i class="fa fa-chevron-left"></i> 十大经典排序算法</a></div><div class="post-nav-item"> <a href="/Linux%E5%B7%A5%E5%85%B7/VIM%E7%9A%84%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C.html" rel="next" title="VIM的分屏操作">VIM的分屏操作<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzIyNS8yOTcwMA=="></div><script src="/js/comments.js"></script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18025897号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chengqian</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.8.6/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.19.0/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"OxuGm1sftgvx1pybK4fNvWEI-gzGzoHsz","app_key":"wVNroDGKbkHDfo8jS43cWkzo","server_url":null,"security":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "数据结构与算法/分析数据结构中的各种树.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>